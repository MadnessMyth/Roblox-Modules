<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXF2A82FCBA14F4EAB9B95CAC22AD32619">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">TextShare</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX35267FEA3C274EADB16A4C0AB2D57004">
			<Properties>
				<ProtectedString name="Source"><![CDATA[--!nocheck
local RunService = game:GetService("RunService")

if not RunService:IsEdit() then
	return
end

local Players = game:GetService("Players")
local StudioService = game:GetService("StudioService")

local MyPlayer = Players.LocalPlayer
local myName = MyPlayer and MyPlayer.Name or "LocalPlayer"

local version = "v1.0.0-release"

local MPL = require("@self/MPL")

local self = MPL.new(plugin)

local icon = {
	unnotified = "rbxassetid://180083674",
	notified = "rbxassetid://180083935",
}

self:CreateToolbar("TextShare")

local TextShareButton = 
	self:CreateButton(
		"TextShare",
		"Chat", "Open chat window.", icon.unnotified
	)

local Networking = false
local Window = self:CreateWindow("Text Share")

Window.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local OpenedVariable = self:Variable("Opened", false)
local SettingOpenedVariable = self:Variable("SettingOpenedVariable", false)
local displayName = self:Variable("displayName", false)
local profilepicture = self:Variable("profilepicture", "")
local profilepictureSize = self:Variable("profilepictureSize", "1x1")

local PFPSize = Vector2.one * 64

OpenedVariable.AlwaysSave = true
SettingOpenedVariable.AlwaysSave = true

Window.Enabled = OpenedVariable:Get()

Window:GetPropertyChangedSignal("Enabled"):Connect(function()
	OpenedVariable:Set(Window.Enabled)
end)

local e = Instance.new("BindableEvent")

self:AssignRBXScriptConnection(TextShareButton.Click:Connect(function()
	Window.Enabled = not Window.Enabled

	if Window.Enabled then
		e:Fire()
	end	
end))

local Connection = script.Connection
Connection.Parent = Window

Connection.Activated:Once(function()
	e:Fire()
end)

e.Event:Wait()

pcall(function()
	myName = StudioService:GetAttribute("Name") or Players:GetNameFromUserIdAsync(StudioService:GetUserId()) or myName
	StudioService:SetAttribute("Name", myName)	
end)

Connection:Destroy()

Window.Enabled = true

Networking = self:EnableNetworkingEngine()

local Frame = script:WaitForChild("Frame")

self:AssignInstance(Frame)

e.Event:Connect(function()
	Frame.TextBox:CaptureFocus()
end)

local seed = buffer.fromstring(tostring(game.GameId).."318wiqjdndmfnuwehr")
local seed2 = buffer.fromstring(tostring(-game.GameId).."qosk92e8u9nm421")
local Cryptography = require("@self/Cryptography")
local zlib = require("@self/luau-zlib")
local compressionConfig = {
	level = 6
}

local heavy_compressionConfig = {
	level = 9
}

local image_compressionConfig = {
	level = 2
}

local filesent, selectfile, send, recv = script:WaitForChild("filesent"),script:WaitForChild("selectfile"), script:WaitForChild("send"), script:WaitForChild("recv")
local userjoined, userleft = script:WaitForChild("userjoined"), script:WaitForChild("userleft")
local capturedscreenshot = script:WaitForChild("capturedscreenshot")
local hover, stophover, click = script:WaitForChild("hover"), script:WaitForChild("stophover"), script:WaitForChild("click")
local click_cogwheel = script:WaitForChild("click-cogwheel")

local SoundService = game:GetService("SoundService")

self:NewSoundContainer()

self:InsertSoundObject(filesent)
self:InsertSoundObject(selectfile)
self:InsertSoundObject(send)
self:InsertSoundObject(recv)

self:InsertSoundObject(userjoined)
self:InsertSoundObject(userleft)

self:InsertSoundObject(capturedscreenshot)

self:InsertSoundObject(hover)
self:InsertSoundObject(stophover)
self:InsertSoundObject(click)

self:InsertSoundObject(click_cogwheel)

local function encrypt(txt, newcompressionConfig)
	local compressionConfig = newcompressionConfig or compressionConfig
	return Cryptography.Encryption.Simon.Encrypt(
		Cryptography.Encryption.Speck.Encrypt(
			buffer.fromstring(zlib.compressZlib(
				txt, compressionConfig)), 
			seed), 
		seed2
	)
end

local function decrypt(txt)
	if not txt then
		return
	end
	
	return zlib.decompressZlib(
		buffer.tostring(
			Cryptography.Encryption.Speck.Decrypt(
				Cryptography.Encryption.Simon.Decrypt(txt, seed2), seed)
		)
	)
end

local messageBoxes = script:WaitForChild("Messages")

Frame.ScrollingFrame:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(function()
	Frame.ScrollingFrame.CanvasPosition = Vector2.new(0, Frame.ScrollingFrame.AbsoluteCanvasSize.Y)
end)

local idcache = {}
local thumbcache = {}


local cg = game:GetService("CoreGui")
local gui = Instance.new("ScreenGui", cg)
gui.Name = "TextShare.Popout"
gui.IgnoreGuiInset = false
gui.ResetOnSpawn = false
gui.Archivable = false
gui.DisplayOrder = 10
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

do
	local uilist = Instance.new("UIListLayout", gui)
	uilist.Padding = UDim.new(0, 0)
	uilist.HorizontalAlignment = Enum.HorizontalAlignment.Center
end

self:AssignInstance(gui)

local TweenService = game:GetService("TweenService")
local ti = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local ti2 = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, false, 0.25)
local ti3 = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local active = 0

local function notify(Thumbnail, Message, parent, persistent)
	local popup = script.Popup:Clone()

	active += 1

	popup.Frame.TextLabel.Text = Message

	if typeof(Thumbnail) == "Content" then
		popup.Frame.ImageLabel.ImageContent = Thumbnail
	else
		popup.Frame.ImageLabel.Image = Thumbnail
	end
	
	popup.GroupTransparency = 1
	popup.Parent = parent or gui

	popup.Frame.Position = UDim2.new(0, 0, -active-1, 0)

	local size = popup.AbsoluteSize
	popup.Size = UDim2.fromOffset(size.X/2, size.Y/2)
	local tween4 = TweenService:Create(popup, ti, {Size = UDim2.fromOffset(size.X, size.Y)})

	local undo_tween = TweenService:Create(popup, ti, {Position = popup.Position, AnchorPoint = popup.AnchorPoint, GroupTransparency = 1})
	local undo_tween2 = TweenService:Create(popup.Frame, ti, {Position = popup.Frame.Position})
	local undo_tween3 = TweenService:Create(popup.UIGradient, ti2, {Offset = popup.UIGradient.Offset})

	local tween = TweenService:Create(popup, ti, {Position = UDim2.new(0, 0, 0, 8), AnchorPoint = Vector2.new(0.5, 1), GroupTransparency = 0})
	local tween2 = TweenService:Create(popup.Frame, ti, {Position = UDim2.new(0, 0, 0, 0)})
	local tween3 = TweenService:Create(popup.UIGradient, ti2, {Offset = -popup.UIGradient.Offset})

	tween:Play()
	tween2:Play()
	tween3:Play()
	tween4:Play()

	local disconnects = {}

	local timer = persistent and math.huge or math.min(10, 3+(#Message/35))
	local timerBroke = false

	task.spawn(function()
		while timer > 0 and not timerBroke do
			timer -= task.wait(1/30)
		end

		undo_tween:Play()
		undo_tween3:Play()

		popup.Size = UDim2.fromOffset(size.X, size.Y)

		local undo_tween4 = TweenService:Create(popup, ti3, {Size = UDim2.fromOffset(size.X, 0)})

		undo_tween4:Play()

		for _,v in disconnects do
			v()
		end

		task.wait(1)

		popup:Destroy()
		active -= 1
	end)

	popup.Frame.MouseButton1Down:Connect(function()
		local b1, b2

		local function disconnect()
			if b1.Connected then
				b1:Disconnect()
			end

			if b2.Connected then
				b2:Disconnect()
			end

			timerBroke = true

			self:RemoveRBXScriptConnection(b1)
			self:RemoveRBXScriptConnection(b2)

			table.remove(disconnects, table.find(disconnects, disconnect))
		end

		table.insert(disconnects, disconnect)

		b1 = popup.Frame.MouseLeave:Once(function()
			timer = 0

			disconnect()
		end)

		b2 = popup.Frame.MouseButton1Up:Once(function()
			disconnect()

			while task.wait() do
				Window.Enabled = not Window.Enabled

				if Window.Enabled then
					break
				end
			end
		end)

		self:AssignRBXScriptConnection(b1)
		self:AssignRBXScriptConnection(b2)
	end)


end

local function displaySystemMessage(Text, notifyEnabled)
	local systemMessageBox = messageBoxes.System:Clone()

	systemMessageBox.Message.Text = Text

	if systemMessageBox.Message.Text == "" then
		systemMessageBox:Destroy()
		return
	end

	systemMessageBox.Parent = Frame.ScrollingFrame

	if notifyEnabled then
		notify("rbxasset://textures/loading/robloxTiltRed.png", Text)

		if Text:find("is leaving this session.") then
			userleft:Play()
		elseif Text:find("joined this session. I'm on version") then
			userjoined:Play()
		end
	end

	return systemMessageBox
end

local function shouldusedisplay()
	if displayName:Get() and displayName:Get() ~= "" then
		return displayName:Get()
	end
end

local function getdisplayof(player)
	local displaynameGetAttribute = player:GetAttribute("displayname")
	
	if displaynameGetAttribute then
		local currentDisplayname = decrypt(buffer.fromstring(displaynameGetAttribute))
		
		if currentDisplayname and currentDisplayname ~= "" then
			return currentDisplayname
		end
	end
end

if Networking then
	local AssetService=game:GetService("AssetService")
	local HttpService = game:GetService("HttpService")

	local function createBlurredEditableImage(editableImage: EditableImage): EditableImage
		local size = editableImage.Size

		local max = Vector2.new(
			math.min(size.X, 1024),
			math.min(size.Y, 1024)
		)

		local newEditableImage = AssetService:CreateEditableImage(
			{Size = max/(max.Magnitude/16)}
		)

		newEditableImage:DrawImageTransformed(
			Vector2.zero, newEditableImage.Size / editableImage.Size, 0, editableImage, {
				CombineType = Enum.ImageCombineType.Overwrite,
				SamplingMode = Enum.ResamplerMode.Default,
				PivotPoint = Vector2.zero
			}
		)

		return newEditableImage
	end

	local TextShare = "TextShare.ChatService"
	local TextMedialine = "TextShare.ChatService_Medialine"

	local BridgeTextMedialine = self:NewRemoteBridge(TextMedialine)
	local BridgeTextShare = self:NewRemoteBridge(TextShare)

	local ignoreids = {}

	local function createFriendlyDataFromImage(inputEditableImage, SizeLimit)
		local editableImage = AssetService:CreateEditableImageAsync(
			inputEditableImage
		)

		local SizeLimit = SizeLimit or Vector2.new(1024, 1024)
		local originalSize = editableImage.Size

		if originalSize.X > SizeLimit.X or originalSize.Y > SizeLimit.Y then
			local scale = math.min(
				SizeLimit.X / originalSize.X,
				SizeLimit.Y / originalSize.Y
			)

			local newSize = Vector2.new(
				math.floor(originalSize.X * scale),
				math.floor(originalSize.Y * scale)
			)

			local newEditableImage = AssetService:CreateEditableImage({
				Size = newSize
			})

			newEditableImage:DrawImageTransformed(
				Vector2.zero,
				Vector2.new(scale, scale),
				0,
				editableImage,
				{
					CombineType = Enum.ImageCombineType.Overwrite,
					SamplingMode = Enum.ResamplerMode.Default,
					PivotPoint = Vector2.zero
				}
			)

			editableImage = newEditableImage
		end

		local pixelsBuffer = editableImage:ReadPixelsBuffer(Vector2.zero, editableImage.Size)

		local santizedBuffers = {}

		for i = 1, editableImage.Size.X * editableImage.Size.Y do
			local pixelIndex = (i - 1) * 4

			santizedBuffers[i] = {buffer.readu8(pixelsBuffer, pixelIndex),buffer.readu8(pixelsBuffer, pixelIndex+1),buffer.readu8(pixelsBuffer, pixelIndex+2),buffer.readu8(pixelsBuffer, pixelIndex+3)}
		end
		
		return santizedBuffers, originalSize, editableImage
	end

	local function loadImageFromData(DecryptedImageData, ImageSizeX, ImageSizeY)
		
		local ImageSizeX, ImageSizeY = tonumber(ImageSizeX), tonumber(ImageSizeY)
				
		local success, result = pcall(function()
			return HttpService:JSONDecode(DecryptedImageData)
		end)
		local pixels = success and result or DecryptedImageData
		local editableImage = AssetService:CreateEditableImage(
			{Size = Vector2.new(ImageSizeX, ImageSizeY)}
		)

		-- Convert from List to Buffers --

		local pixelsBuffer = editableImage:ReadPixelsBuffer(Vector2.zero, editableImage.Size)

		local success = pcall(function()
			for i = 1, editableImage.Size.X * editableImage.Size.Y do
				local pixelIndex = (i - 1) * 4
				local c = pixels[i]
				buffer.writeu8(pixelsBuffer, pixelIndex, c[1])
				buffer.writeu8(pixelsBuffer, pixelIndex + 1, c[2])
				buffer.writeu8(pixelsBuffer, pixelIndex + 2, c[3])
				-- Set alpha to 255 to make all pixels fully opaque.
				buffer.writeu8(pixelsBuffer, pixelIndex + 3, c[4])
			end
		end)
		
		if not success then
			for i,v in pixels do
				local pixelIndex = (i - 1) * 4
				local c = pixels[i]
				buffer.writeu8(pixelsBuffer, pixelIndex, c[1])
				buffer.writeu8(pixelsBuffer, pixelIndex + 1, c[2])
				buffer.writeu8(pixelsBuffer, pixelIndex + 2, c[3])
				-- Set alpha to 255 to make all pixels fully opaque.
				buffer.writeu8(pixelsBuffer, pixelIndex + 3, c[4])
			end
		end

		editableImage:WritePixelsBuffer(Vector2.zero, editableImage.Size, pixelsBuffer)

		return editableImage
	end
	

	local function getuserthumbnail(id)
		local plr = Players:GetPlayerByUserId(id)

		if plr and not thumbcache[plr] then
			local thumbnailGetAttribute = plr:GetAttribute("thumbnail")
			local thumbnailsizeGetAttribute = plr:GetAttribute("thumbnailsize")

			if thumbnailGetAttribute and thumbnailsizeGetAttribute then
				local thumbnail = decrypt(buffer.fromstring(thumbnailGetAttribute))
				local thumbnailsize = decrypt(buffer.fromstring(thumbnailsizeGetAttribute))

				if thumbcache[thumbnailGetAttribute.."+"..thumbnailsizeGetAttribute] then
					return thumbcache[thumbnailGetAttribute.."+"..thumbnailsizeGetAttribute]
				end

				if thumbnail and thumbnailsize then
					local thumbnailsizeexported = string.split(thumbnailsize,"x")

					thumbcache[thumbnailGetAttribute.."+"..thumbnailsizeGetAttribute] = Content.fromObject(loadImageFromData(thumbnail, PFPSize.X, PFPSize.Y))
					return thumbcache[thumbnailGetAttribute.."+"..thumbnailsizeGetAttribute]
				end
			end
		end

		if tonumber(idcache[id]) then
			return idcache[id]
		end

		while idcache[id] == "loading" do
			task.wait()
		end

		idcache[id] = "loading"

		idcache[id] = Players:GetUserThumbnailAsync(
			id, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size48x48
		)
		
		return idcache[id]
	end

	if StudioService:GetUserId() ~= 0 then
		task.spawn(getuserthumbnail,StudioService:GetUserId())
	end

	self:EachRemoteBridge(TextMedialine, function(Firer, BridgeObject, Image, ImageSizeX, ImageSizeY, msgid, spoilered, RealImageSizeX, RealImageSizeY)
		print(Firer, BridgeObject, "image", ImageSizeX, ImageSizeY, msgid, spoilered, RealImageSizeX, RealImageSizeY)
		if msgid then
			if table.find(ignoreids, msgid) then
				return
			end

			table.insert(ignoreids, msgid)

			while #ignoreids > 15 do
				table.remove(ignoreids, 1)
			end
		end

		local isMe = Firer == MyPlayer

		if not isMe then
			recv:Play()
		else
			filesent:Play()
		end

		TextShareButton.Icon = isMe and icon.unnotified or icon.notified

		local messageBox = (isMe
			and messageBoxes.SelfPlayer
			or messageBoxes.OtherPlayer):Clone()

		messageBox.Message:Destroy()

		local msg = script.Message:Clone()
		msg.Parent = messageBox

		local ratio = ImageSizeX / ImageSizeY

		Instance.new("UIAspectRatioConstraint", msg).AspectRatio = ratio

		messageBox.DisplayName.Text = isMe and (shouldusedisplay() or myName) or (getdisplayof(Firer) or Firer.DisplayName)
		messageBox.Username.Text = isMe and "" or "@"..Firer.Name
		-- pfp --

		local id = isMe
			and StudioService:GetUserId() or Firer.UserId

		local output = getuserthumbnail(id)
		
		if typeof(output) == "Content" then
			messageBox.ImageLabel.ImageContent = output
		else
			messageBox.ImageLabel.Image = output
		end

		if isMe then
			msg.AnchorPoint = Vector2.new(1, 0)
			msg.Position = UDim2.new(1, 0, 0, 50)
		end

		msg.Size = UDim2.new(1, 0, 0, ImageSizeY)

		local editableImage = loadImageFromData(decrypt(Image), math.min(RealImageSizeX, ImageSizeX, 1024), math.min(RealImageSizeY, ImageSizeY, 1024))

		if spoilered then
			local clone = msg:Clone()

			local blurredEditableImage = createBlurredEditableImage(editableImage)
			msg.ImageContent = Content.fromObject(editableImage)

			clone.ImageContent = Content.fromObject(blurredEditableImage)
			clone.ZIndex += 1
			clone.Parent = msg.Parent

			local isblurred = true

			local ti = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

			local tweenBlur = TweenService:Create(
				clone, ti, {ImageTransparency = 0}
			)

			local tweenVisible = TweenService:Create(
				clone, ti, {ImageTransparency = 1}
			)

			local spoiler = script.Spoiler:Clone()

			spoiler.Parent = clone

			local spoiler_tweenBlur = TweenService:Create(
				spoiler, ti, {GroupTransparency = 0}
			)

			local spoiler_tweenVisible = TweenService:Create(
				spoiler, ti, {GroupTransparency = 1}
			)

			local spoiler_glowup = TweenService:Create(
				spoiler.Spoiler.TextButton, ti, {TextColor3 = Color3.new(1,1,1), BackgroundTransparency=0}
			)

			local spoiler_glowdown = TweenService:Create(
				spoiler.Spoiler.TextButton, ti, {TextColor3 = spoiler.Spoiler.TextButton.TextColor3, BackgroundTransparency=spoiler.Spoiler.TextButton.BackgroundTransparency}
			)

			local spoilerbg_glowup = TweenService:Create(
				spoiler.Spoiler, ti, {ImageTransparency=0.5}
			)

			local spoilerbg_glowdown = TweenService:Create(
				spoiler.Spoiler, ti, {ImageTransparency=spoiler.Spoiler.ImageTransparency}
			)

			clone.MouseEnter:Connect(function()
				spoiler_glowup:Play()
				spoilerbg_glowup:Play()
			end)

			clone.MouseLeave:Connect(function()
				spoiler_glowdown:Play()
				spoilerbg_glowdown:Play()
			end)

			clone.Activated:Connect(function()
				isblurred = not isblurred

				if isblurred then
					spoiler_tweenBlur:Play()
					tweenBlur:Play()
				else
					spoiler_tweenVisible:Play()
					tweenVisible:Play()
				end
			end)
		else
			msg.Active = false
			msg.ImageContent = Content.fromObject(editableImage)
		end

		messageBox.Parent = Frame.ScrollingFrame

		if not isMe then
			notify(messageBox.ImageLabel.ImageContent, messageBox.DisplayName.Text.." shared an image.")
		end
	end, true)

	self:EachRemoteBridge(TextShare, function(Firer, BridgeObject, WasSystem, Message, msgid, customdisplayname)
		if msgid then
			if table.find(ignoreids, msgid) then
				return
			end

			table.insert(ignoreids, msgid)

			while #ignoreids > 15 do
				table.remove(ignoreids, 1)
			end
		end

		if WasSystem then
			displaySystemMessage(decrypt(Message), true)
		else
			local isMe = Firer == MyPlayer
			TextShareButton.Icon = isMe and icon.unnotified or icon.notified

			if not isMe then
				recv:Play()
			end

			local messageBox = (isMe
				and messageBoxes.SelfPlayer
				or messageBoxes.OtherPlayer):Clone()

			messageBox.Message.Text = decrypt(Message)

			messageBox.DisplayName.Text = isMe and (shouldusedisplay() or myName) or (getdisplayof(Firer) or Firer.DisplayName)
			messageBox.Username.Text = isMe and "" or "@"..Firer.Name

			if messageBox.Message.Text == "" then
				messageBox:Destroy()
				return
			end

			-- pfp --

			local id = isMe
				and StudioService:GetUserId() or Firer.UserId


			local output = getuserthumbnail(id)

			if typeof(output) == "Content" then
				messageBox.ImageLabel.ImageContent = output
			else
				messageBox.ImageLabel.Image = output
			end
			
			messageBox.Parent = Frame.ScrollingFrame

			if not isMe then
				notify(messageBox.ImageLabel.ImageContent, messageBox.DisplayName.Text.." said "..messageBox.Message.Text)
			end
		end
	end, true)

	Frame.TextBox.FocusLost:Connect(function(enterPressed, input)
		if not enterPressed then
			return
		end

		local text = Frame.TextBox.Text

		Frame.TextBox.Text = ""

		input:GetPropertyChangedSignal("UserInputState"):Once(function()
			Frame.TextBox:CaptureFocus()
		end)

		send:Play()

		self:FireRemoteBridge(BridgeTextShare, false, encrypt(text), HttpService:GenerateGUID(false))
	end)

	self:FireRemoteBridge(BridgeTextShare, true, encrypt(myName.." joined this session. I'm on version "..version), HttpService:GenerateGUID(false))

	plugin.Unloading:Once(function()
		MyPlayer:SetAttribute("thumbnailsize", nil)
		MyPlayer:SetAttribute("thumbnail", nil)
		self:FireRemoteBridge(BridgeTextShare, true, encrypt(myName.." is leaving this session."), HttpService:GenerateGUID(false))
	end)

	do
		local x = displaySystemMessage("Encrypted with Simon + Speck using Cryptography and compressed with luau-zlib. This chat is temporary.")
		x.Size = UDim2.new(1, 0, 0, 32)
		x.AutomaticSize = Enum.AutomaticSize.None
		x.Message.AutomaticSize = Enum.AutomaticSize.None
		x.Message.TextScaled = true
		x.Message.Size = UDim2.fromScale(1,1)
		x.Message:ClearAllChildren()
	end

	local openSelectImage = {
		TweenService:Create(Frame.SelectImage.Frame, ti, {Size = UDim2.fromScale(2,2)})
	}
	local closeSelectImage = {
		TweenService:Create(Frame.SelectImage.Frame, ti, {Size = UDim2.fromScale(0,0)})
	}

	for _,v in Frame.SelectImage.Frame:GetChildren() do
		if v:IsA("TextButton") then
			table.insert(openSelectImage, TweenService:Create(
				v, ti, {Size = UDim2.fromScale(1,0.45)}
				)
			)

			table.insert(closeSelectImage, TweenService:Create(
				v, ti, {Size = UDim2.fromScale(0,0)}
				)
			)
		end
	end

	local function handlePicture(c, fileName, customSize)
		-- image confirmation --

		local confirmMenu = Frame.ImageConfirm

		confirmMenu.ImageLabel.ImageContent = c
		confirmMenu.ImageLabel.TextLabel.Text = fileName

		confirmMenu.Frame.Spoilered.Tick.Visible = false

		local connections = {}

		table.insert(connections, confirmMenu.Frame.Spoilered.Activated:Connect(function()
			confirmMenu.Frame.Spoilered.Tick.Visible = not confirmMenu.Frame.Spoilered.Tick.Visible
		end))

		confirmMenu.Visible = true

		local bind = Instance.new("BindableEvent")

		table.insert(connections, confirmMenu.Yes.Activated:Once(function()
			bind:Fire(true)
		end))

		table.insert(connections, confirmMenu.No.Activated:Connect(function()
			bind:Fire(false)
		end))

		for _,v in connections do
			self:AssignRBXScriptConnection(v)
		end

		local result = bind.Event:Wait()

		for _,v in connections do
			self:RemoveRBXScriptConnection(v)

			if v.Connected then
				v:Disconnect()
			end
		end

		confirmMenu.Visible = false

		if not result then
			return
		end

		bind:Destroy()

		local santizedBuffers, originalSize, c = createFriendlyDataFromImage(c)

		local text = HttpService:JSONEncode(santizedBuffers)
		send:Play()


		local size = customSize or c.Size
		self:FireRemoteBridge(BridgeTextMedialine, encrypt(text, image_compressionConfig), originalSize.X, originalSize.Y, HttpService:GenerateGUID(false), confirmMenu.Frame.Spoilered.Tick.Visible, size.X, size.Y)
	end

	local open = false

	local function toggle()
		open = not open

		for _,v in open and openSelectImage or closeSelectImage do
			v:Play()
		end
	end

	Frame.SelectImage.Activated:Connect(toggle)

	local db = false
	Frame.SelectImage.Frame.game.Activated:Connect(function()
		if db then return end db = true
		toggle()
		local Snapshot = script.Snapshot:Clone()

		self:AssignInstance(Snapshot)

		local history = {}

		for _,v: ScriptDocument in game.ScriptEditorService:GetScriptDocuments() do
			if v:IsCommandBar() then
				continue
			end
			
			pcall(function()
				local CursorLine, CursorChar, AnchorLine, AnchorChar = v:GetSelection()
				local s = v:GetScript()
				table.insert(history, function()
					local s = game.ScriptEditorService:OpenScriptDocumentAsync(s) :: ScriptDocument
					
					if s then
						local scriptDoccuments = game.ScriptEditorService:GetScriptDocuments()
						
						for _,v: ScriptDocument in scriptDoccuments do
							if v:GetScript() == s then
								v:RequestSetSelectionAsync(CursorLine, CursorChar, AnchorLine, AnchorChar)
								break
							end
						end
					end
				end)
			end)

			v:CloseAsync()
		end

		Window.Enabled = false

		Snapshot.Parent = gui

		Snapshot.ImageButton.Activated:Wait()

		Snapshot.ImageButton:Destroy()

		local tween = TweenService:Create(Snapshot.ImageLabel, ti, {Size = UDim2.new(1.25, 0, 1.25, 0), ImageTransparency = 1})

		local lastTool = plugin:GetSelectedRibbonTool()
		plugin:SelectRibbonTool(plugin:GetSelectedRibbonTool(), UDim2.new())

		game:GetService("CaptureService"):CaptureScreenshot(function(c)			
			for _, v in history do
				task.spawn(v)
			end
			
			Window.Enabled = true

			capturedscreenshot:Play()

			Snapshot.ImageLabel.Visible = true
			tween:Play()
			plugin:SelectRibbonTool(plugin:GetSelectedRibbonTool(), UDim2.new())

			handlePicture(Content.fromUri(c),"Screenshot - "..os.date())
		end)

		local done = false
		tween.Completed:Once(function()
			Snapshot:Destroy()
			self:RemoveInstance(Snapshot)
			db = false
			done = true
		end)

		task.delay(5, function()
			if not done then
				db = false
			end
		end)
	end)

	local db = false
	Frame.SelectImage.Frame.pc.Activated:Connect(function()
		if db then return end db = true
		toggle()
		selectfile:Play()
		local file = StudioService:PromptImportFileAsync({"png"}) :: File
		db = false
		if file then
			local x = file:GetTemporaryId()
			if x then
				handlePicture(Content.fromUri(x), file.Name)
			end
		end
	end)
	
	do
		local overlay = script:WaitForChild("WindowOverlay")

		local hoverAnim = TweenService:Create(overlay.Settings.Frame.ImageButton, ti, {Rotation = 90})
		local unhoverAnim = TweenService:Create(overlay.Settings.Frame.ImageButton, ti, {Rotation = 0})

		local clickAnim = TweenService:Create(overlay.Settings.Frame, ti, {Rotation = 360})
		local unclickAnim = TweenService:Create(overlay.Settings.Frame, ti, {Rotation = 0})

		local settingsPage = script:WaitForChild("SettingsPage")
		settingsPage.Visible = SettingOpenedVariable:Get()

		local hovered = false
		overlay.Settings.MouseEnter:Connect(function()
			hovered = true
			hover:Play()

			hoverAnim:Play()
		end)

		overlay.Settings.MouseLeave:Connect(function()
			hovered = false
			hover:Play()

			unhoverAnim:Play()
		end)

		overlay.Settings.Activated:Connect(function(i)
			settingsPage.Visible = not SettingOpenedVariable:Get()

			SettingOpenedVariable:Set(settingsPage.Visible)

			if settingsPage.Visible then
				clickAnim:Play()
			else
				unclickAnim:Play()
			end

			click_cogwheel:Play()
		end)

		settingsPage.Parent = Window
		overlay.Parent = Window

		self:AssignInstance(overlay)
		self:AssignInstance(settingsPage)

		-- settings

		-- pfp

		local db = false
		local old = settingsPage.PFP.ImageLabel.ImageContent
		
		local gone = true
		local imagemodified = false
		settingsPage.PFP.X.Activated:Connect(function()
			gone = true
			imagemodified = true
			settingsPage.PFP.ImageLabel.ImageContent = old
		end)
		
		settingsPage.PFP.ImageLabel.Active = true
		settingsPage.PFP.ImageLabel.Activated:Connect(function()
			-- png selector --
			if db then return end db = true
			local file = StudioService:PromptImportFileAsync({"png"}) :: File
			db = false
			if file then
				local x = file:GetTemporaryId()
				if x then
					gone = false
					imagemodified = true
					settingsPage.PFP.ImageLabel.ImageContent = Content.fromUri(x)
				end
			end
		end)
		
		local function update()
			if profilepicture:Get() ~= "" and profilepictureSize:Get() then
				local size = string.split(profilepictureSize:Get(), "x")
				
				local editableimage = loadImageFromData(
					profilepicture:Get(), PFPSize.X, PFPSize.Y
				)
				
				settingsPage.PFP.ImageLabel.ImageContent = Content.fromObject(
					editableimage
				)
				
				MyPlayer:SetAttribute("thumbnailsize", buffer.tostring(encrypt(profilepictureSize:Get())))
				MyPlayer:SetAttribute("thumbnail", buffer.tostring(encrypt(profilepicture:Get(), image_compressionConfig)))
			else
				MyPlayer:SetAttribute("thumbnailsize", nil)
				MyPlayer:SetAttribute("thumbnail", nil)
			end
			
			if displayName:Get() ~= "" and displayName:Get() then
				MyPlayer:SetAttribute("displayname", buffer.tostring(encrypt(displayName:Get(), heavy_compressionConfig)))
			else
				MyPlayer:SetAttribute("displayname", nil)
			end
			
			-- update preview --
			
			settingsPage.Preview.DisplayName.Text = shouldusedisplay() or displayName:Get()
			settingsPage.Preview.Username.Text = "@"..myName
			settingsPage.Preview.Message.Text = "Hi I'm "..shouldusedisplay() or displayName:Get().."."
			settingsPage.Preview.ImageLabel.ImageContent = settingsPage.PFP.ImageLabel.ImageContent
		end

		task.spawn(update)

		-- save
		
		settingsPage.DisplayName.PlaceholderText = myName
		
		if displayName:Get() ~= "" and displayName:Get() then
			settingsPage.DisplayName.Text = displayName:Get()
		else
			settingsPage.DisplayName.Text = ""
		end

		settingsPage.Save.Activated:Connect(function()	
			displayName:Set(settingsPage.DisplayName.Text)
			
			if imagemodified then
				if not gone then
					local editableImage = AssetService:CreateEditableImageAsync(
						settingsPage.PFP.ImageLabel.ImageContent
					)

					local santizedBuffers, originalSize, editableImage = createFriendlyDataFromImage(
						Content.fromObject(editableImage), PFPSize
					)

					settingsPage.PFP.ImageLabel.ImageContent = Content.fromObject(editableImage)
					profilepictureSize:Set(string.format("%dx%d", originalSize.X, originalSize.Y))
					profilepicture:Set(
						HttpService:JSONEncode(santizedBuffers)
					)
				else
					profilepicture:Set(profilepicture.defaultValue)
					profilepictureSize:Set(profilepictureSize.defaultValue)
				end
			end
			
			imagemodified = false
			
			update()
		end)
	end
end

do
	local function update()
		Frame.TextBox.Size = UDim2.new(1, -Frame.SelectImage.AbsoluteSize.X-8, 0.1, 0)
	end

	update()
	Frame.SelectImage:GetPropertyChangedSignal("AbsoluteSize"):Connect(update)
end

Frame.Parent = Window

if not Networking then
	script.NetworkFailureOverlay.Parent = Window
end

--for _,v in self.Variables do
--	v.Value = v.defaultValue
--	v:Save()
--end

-- DATA RESET --

local UpdateChecker = require(script.UpdateChecker)

local OWNER = "madnessmyth"
local REPO  = "Roblox-Modules"
local BRANCH = "main"

local verRes = UpdateChecker.CheckVersionFile(OWNER, REPO, BRANCH, "Plugins/TextShare/LatestVersion", version)
if verRes.ok and verRes.updateAvailable then
	local warnMSG = ("Update available: %s -> %s ( %s )"):format(verRes.current, verRes.latest, "https://github.com/madnessmyth/Roblox-Modules/Plugins/TextShare")

	displaySystemMessage(warnMSG, false)
	notify("rbxassetid://102816031861909", warnMSG, nil, true)	
end

]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">3</token>
				<string name="ScriptGuid">{32D27FE5-14FD-4EDD-829B-17B9BA007A50}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="CanvasGroup" referent="RBX851813DD90C3493FA9EB624DC9C2C87F">
				<Properties>
					<Color3 name="GroupColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="GroupTransparency">0</float>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>1</Y>
					</Vector2>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.121568635</R>
						<G>0.121568635</G>
						<B>0.121568635</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">true</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.122334965</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Popup</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="UIGradient" referent="RBX2B7B9A493B744FDAA5360DD304EDC762">
					<Properties>
						<ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
						<bool name="Enabled">true</bool>
						<Vector2 name="Offset">
							<X>0</X>
							<Y>-1</Y>
						</Vector2>
						<float name="Rotation">-90</float>
						<NumberSequence name="Transparency">0 1 0 1 0 0 </NumberSequence>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UIGradient</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="UICorner" referent="RBX3821275729EB4F3C8853A7097BEC6F55">
					<Properties>
						<UDim name="CornerRadius">
							<S>0</S>
							<O>8</O>
						</UDim>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UICorner</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="UIAspectRatioConstraint" referent="RBX7879FACFF001424D8379095CD186B19D">
					<Properties>
						<float name="AspectRatio">12</float>
						<token name="AspectType">0</token>
						<token name="DominantAxis">0</token>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UIAspectRatioConstraint</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="UIPadding" referent="RBX1991A4CC714B4BD7ACED516904587BAD">
					<Properties>
						<UDim name="PaddingBottom">
							<S>0</S>
							<O>4</O>
						</UDim>
						<UDim name="PaddingLeft">
							<S>0</S>
							<O>4</O>
						</UDim>
						<UDim name="PaddingRight">
							<S>0</S>
							<O>4</O>
						</UDim>
						<UDim name="PaddingTop">
							<S>0</S>
							<O>4</O>
						</UDim>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UIPadding</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBX966519314A7B4694B8AA4EB254BAC121">
					<Properties>
						<Content name="HoverImage"><null></null></Content>
						<Content name="Image"><null></null></Content>
						<Color3 name="ImageColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<Content name="PressedImage"><null></null></Content>
						<token name="ResampleMode">0</token>
						<token name="ScaleType">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<float name="SliceScale">1</float>
						<UDim2 name="TileSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="AutoButtonColor">true</bool>
						<Ref name="HoverHapticEffect">null</Ref>
						<bool name="Modal">false</bool>
						<Ref name="PressHapticEffect">null</Ref>
						<bool name="Selected">false</bool>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.0862745121</R>
							<G>0.0862745121</G>
							<B>0.0862745121</B>
						</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Frame</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="TextLabel" referent="RBXB93A712DC7E74C7A8C231637925B1F69">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">true</bool>
							<string name="Text">LabelLabelLabelLabelLabelLabelLabelLabelLabelLabelLabelLabelLabelLabelLabelLabelLabel</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">32</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">2</token>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.0860627145</XS>
								<XO>0</XO>
								<YS>-0.0143764336</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.903832734</XS>
								<XO>0</XO>
								<YS>0.99999994</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">TextLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX1F1DC4564A65439397D389395E1AF9FE">
						<Properties>
							<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">3</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>3.63593067e-08</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.0745644569</XS>
								<XO>0</XO>
								<YS>0.99999994</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ImageLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBX4CD3CD26004B40DD9877BC2433709999">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UICorner" referent="RBXCC132412618C44C1B1F24E874719E330">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX0CE17D1F8BA44F2C8C1F486B54E20CCE">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX55C5961A1D164A3799A92EEFEDC7E2FF">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[-- MADNESSMYTH PLUGIN LOADER --
-- NAME INSPIRED BY FML | ForgeModLoader

-- EXTERNAL USAGES --
-- t: Runtime typechecker

-- PROVIDES VARIOUS UTILITES --

local UDim2Identity = UDim2.new()

local MPL = {}

local MPLmetadata = {}
MPLmetadata.__index = MPLmetadata

-- Create a toolbar
local t = require("@self/t")

local types = {
	CreateToolbar = t.tuple(t.string),
	CreateButton = t.tuple(t.union(t.instanceIsA("PluginToolbar"), t.optional(t.string)), t.string, t.optional(t.string), t.optional(t.union(t.string, t.number))),
	AssignRBXScriptConnection = t.tuple(t.RBXScriptConnection),
	AssignUnloadingFunction = t.tuple(t["function"]),
	AssignInstance = t.tuple(t["Instance"]),
	SetGridIncrement = t.tuple(t.number),
	CreateWindow = t.tuple(t.string, t.optional(t.DockWidgetPluginGuiInfo));
	SetRibbonTool = t.tuple(t.union(t.EnumItem, t.string, t.number)),
	InsertSoundObject = t.tuple(t.instanceIsA("Sound")),
	SetSelection = t.tuple(t.union(t.Instance, t.array(t.Instance))),
	SetRibbonSpaceMode = t.tuple(t.union(t.boolean, t.literal("local"), t.literal("global"), t.literal("world"))),
	EachRemoteBridge = t.tuple(t.string, t["function"], t.optional(t.boolean)),
	NewRemoteBridge = t.tuple(t.string),

	GetSetting = t.tuple(t.string),
	SetSetting = t.tuple(t.string, t.union(t.string, t.boolean)),

	Variable = t.tuple(t.string, t.optional(t.any))
}

-- Switch function
local function switch(value, cases, default)
	if cases[value] then
		-- Call the case function
		return cases[value]()
	elseif default then
		-- Call default if it exists
		return default()
	end
end

-- Random string + number ID generator
local function generateID(length)
	length = length or 6 -- default string length

	local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	local id = ""

	for i = 1, length do
		local randomIndex = math.random(1, #chars)
		id ..= chars:sub(randomIndex, randomIndex)
	end

	-- Append a random number (e.g., 1000-9999)
	local randomNumber = math.random(1000, 9999)
	id ..= randomNumber

	return id
end

local function resolveAssetId(value: string | number): string
	if not value or value == "" then
		return ""
	end

	local id = tostring(value):match("%d+")
	return id and `rbxassetid://{id}` or ""
end

function MPLmetadata:CreateToolbar(name: string): PluginToolbar
	self:__initCheck()

	self:__resolveType(types.CreateToolbar(name))

	if self.Toolbars[name] then
		self:__error("Can not make a new toolbar with the same name as a previous one.")
	end

	local newToolbar = self.plugin:CreateToolbar(name)

	self.Toolbars[name] = newToolbar

	return newToolbar
end

-- Create a button in a toolbar
function MPLmetadata:CreateButton(toolbar: PluginToolbar | string, name: string, tooltip: string, icon: string | number)
	self:__resolveType(types.CreateButton(toolbar, name, tooltip, icon))

	if typeof(toolbar) == "string" then
		local requestedToolbar = self.Toolbars[toolbar]

		if not requestedToolbar then
			self:__error(`Can not find toolbar with name: {toolbar}`)
		end

		return requestedToolbar:CreateButton(name, tostring(tooltip), resolveAssetId(icon))
	else
		return toolbar:CreateButton(name, tooltip, resolveAssetId(icon))
	end
end

function MPLmetadata:CreateWindow(name: string, dockInfo: DockWidgetPluginGuiInfo?): DockWidgetPluginGui
	self:__initCheck()

	self:__resolveType(types.CreateWindow(name, dockInfo))

	if self.Windows[name] then
		self:__error("Can not make a new window with the same name as a previous one.")
	end

	-- Default DockWidgetPluginGuiInfo if not provided
	local info = dockInfo or DockWidgetPluginGuiInfo.new()

	-- Create the DockWidgetPluginGui
	local success, window = pcall(self.plugin.CreateDockWidgetPluginGuiAsync, self.plugin, name, info)

	if not success then
		self:__error(`Failed to create window '{name}': {tostring(window or "unknown error") or "unknown error"}`)
	end

	window.Name = "MPL/"..name
	window.Title = name

	self.Windows[name] = window

	return window
end


function MPLmetadata:RunningAsLocalFile()
	self:__initCheck()

	return self.plugin.Name:sub(1, 5) == "user_"
end
local PossibleCorruptionKeys = {
	keys = {
		"\n",  -- newline
		"\r",  -- carriage return
		"\t",  -- tab
		"\"",  -- double quote
		"\'",  -- single quote
		"\\",  -- backslash
		"{",
		"}",
		"[",
		"]",
		",",
		":",
		".",
		"\0", -- null byte
		"\b", -- backspace
		"\f", -- form feed
	};

	values = {
		"\\",        -- backslash
		"\"",        -- double quote
		"\n",        -- newline
		"\r",        -- carriage return
		"\t",        -- tab
		"\0",        -- null byte
		"\b",        -- backspace
		"\f",        -- form feed
		utf8.char(0x2028), -- line separator
		utf8.char(0x2029), -- paragraph separator
	};
}

function MPLmetadata:SetSetting(name, value)
	self:__initCheck()

	self:__resolveType(types.SetSetting(name, value ~= nil and value or false), tostring(name):sub(1,10)..", "..tostring(value):sub(1,10)..", failed to save.")

	local checkPerformed = false

	local function performCheck()
		if checkPerformed then
			return
		end

		checkPerformed = true

		for _,toCheckAgainst in PossibleCorruptionKeys.keys do
			local index = name:find(toCheckAgainst, 1, true)
			if not MPL["warnedUserAboutErrorKey "..toCheckAgainst] and index then
				MPL["warnedUserAboutErrorKey "..toCheckAgainst] = true

				if toCheckAgainst == "\n" then
					toCheckAgainst = "\\n"
				end

				warn(`Your set setting's key contains an invaild character that can cause corrupted setting files. Conflicting Character: " {toCheckAgainst} " , Key: "{name}", ({index})`)
			end
		end

		if typeof(value) == "string" then
			for _,toCheckAgainst in PossibleCorruptionKeys.values do
				local index = value:find(toCheckAgainst, 1, true)
				if not MPL["warnedUserAboutErrorValue "..toCheckAgainst] and index then
					MPL["warnedUserAboutErrorValue "..toCheckAgainst] = true

					if toCheckAgainst == "\n" then
						toCheckAgainst = "\\n"
					end

					warn(`Your set setting's Value contains an invaild character that can cause corrupted setting files. Conflicting Character: " {toCheckAgainst} " , Value: "{value}", ({index})`)
				end
			end
		end
	end

	if not MPL.Config.WarningsDisabled then
		performCheck()
	end

	self.plugin:SetSetting(name, value)

	if MPL.Config.AutomaticSetSettingValidation then
		local result = self:GetSetting(name)
		if result ~= value then
			print("Set setting failure, reporting output..")
			performCheck()
			self:__error(`Set setting failed. Key: "{name}", Value: "{value}", Result: "{result}"`)
		end
	end	
end

function MPLmetadata:GetSetting(name: string)
	self:__initCheck()

	self:__resolveType(types.GetSetting(name))

	return self.plugin:GetSetting(name)
end

function MPLmetadata:__resolvePluginPath()
	return "MPL/"..(script.Parent and script.Parent.Name or "null");
end

function MPLmetadata:__error(message)
	error(`{self:__resolvePluginPath()}: {message}`, 3)
end

function MPLmetadata:__resolveType(result, err, msg)
	if result == false or (type(result) == "table" and not result.success) then
		self:__error(err or result.message or (msg or "Type check failed"))
	end
end

function MPLmetadata:AssignInstance(Instance: Instance)
	self:__resolveType(types.AssignInstance(Instance))

	table.insert(self.Unloading, Instance)
end

function MPLmetadata:RemoveInstance(Instance)
	self:__resolveType(types.AssignInstance(Instance))

	local index = table.find(self.Unloading, Instance)

	if index then
		table.remove(self.Unloading, index)
	else
		self:__error("Instance is not found in the unloading list")
	end
end


function MPLmetadata:AssignRBXScriptConnection(RBXScriptConnection: RBXScriptConnection)
	self:__resolveType(types.AssignRBXScriptConnection(RBXScriptConnection))

	table.insert(self.Unloading, RBXScriptConnection)
end

function MPLmetadata:RemoveRBXScriptConnection(RBXScriptConnection)
	self:__resolveType(types.AssignRBXScriptConnection(RBXScriptConnection))

	local index = table.find(self.Unloading, RBXScriptConnection)

	if index then
		table.remove(self.Unloading, index)
	else
		self:__error("RBXScriptConnection is not found in the unloading list")
	end
end

function MPLmetadata:AssignUnloadingFunction(func: () -> ())
	self:__resolveType(types.AssignUnloadingFunction(func))

	table.insert(self.Unloading, func)
end

function MPLmetadata:RemoveUnloadingFunction(func)
	self:__resolveType(types.AssignUnloadingFunction(func))

	local index = table.find(self.Unloading, func)

	if index then
		table.remove(self.Unloading, index)
	else
		self:__error("Function is not found in the unloading list")
	end
end

function MPLmetadata:SetRibbonToolToNone()
	self:__initCheck()

	for _= 1, 2 do
		if self.plugin:GetSelectedRibbonTool() ~= Enum.RibbonTool.None then
			self.plugin:SelectRibbonTool(Enum.RibbonTool.Select, UDim2Identity)
		end
		-- Sets it to Select twice, until its None, selecting Select twice makes it none, you can't directly set it. Odd.
	end
end

local ScriptEditorService = game:GetService("ScriptEditorService")
local StudioService = game:GetService("StudioService")

function MPLmetadata:GetActiveScript()
	return StudioService.ActiveScript
end

function MPLmetadata:OnActiveScriptChanged(callback: () -> ()): RBXScriptConnection
	self:__resolveType(types.AssignUnloadingFunction(callback)) -- Checks for a function.

	return StudioService:GetPropertyChangedSignal("ActiveScript"):Connect(callback)
end

-- Local Space & Global space for ribbon tools
function MPLmetadata:GetRibbonSpaceMode(): boolean
	return StudioService.UseLocalSpace
end

function MPLmetadata:SetRibbonSpaceMode(isLocal: boolean | "local" | "global" | "world" | "Local" | "Global" | "World")
	self:__resolveType(types.SetRibbonSpaceMode(isLocal)) -- Checks for a function.

	if typeof(isLocal) == "boolean" then
		StudioService.UseLocalSpace = isLocal
	else
		StudioService.UseLocalSpace = string.lower(isLocal) == "local" 
	end
end

type Connection = {
	Connected: boolean,
	Disconnect: () -> ()
}

type MadSignal = {
	Connections: { ( ...any ) -> () },

	Fire: (self: MadSignal, ...any) -> (),
	FireThreaded: (self: MadSignal, ...any) -> (),
	Connect: (self: MadSignal, callback: (...any) -> ()) -> Connection,
}

local MadSignal = {}
MadSignal.__index = MadSignal

function MadSignal:Fire(...: any)
	for _, connection in self.Connections do
		connection(...)
	end
end

function MadSignal:FireThreaded(...: any)
	for _, connection in self.Connections do
		task.spawn(connection, ...)
	end
end

function MadSignal:Connect(callback: (...any) -> ())
	local RBXScriptConnection: Connection = {
		Connected = true,
		Disconnect = function() end
	}

	table.insert(self.Connections, callback)

	RBXScriptConnection.Disconnect = function()
		if not RBXScriptConnection.Connected then
			return
		end

		local index = table.find(self.Connections, callback)

		if index then
			RBXScriptConnection.Connected = false
			table.remove(self.Connections, index)
		else
			error("Internal Error: Callback is not found in the connections, garbage collection may have removed it.")
		end
	end

	return RBXScriptConnection
end

function MadSignal.new(): MadSignal
	return setmetatable({
		Connections = {},
	}, MadSignal)
end

local MPLVariable = {}
MPLVariable.__index = MPLVariable

function MPLVariable:Set(newValue)
	self.Value = newValue

	if self.AlwaysSave and self.CanSave then
		self.__Instance:SetSetting(self.Name..self.__Instance.variableindexer1, true)

		self.__Instance:SetSetting(self.Name..self.__Instance.variableindexer2, newValue)

		self.Changed:Fire(newValue)
	end
end

function MPLVariable:Save(forced: boolean)
	if forced or self.CanSave then
		self.__Instance:SetSetting(self.Name..self.__Instance.variableindexer1, true)

		self.__Instance:SetSetting(self.Name..self.__Instance.variableindexer2, self.Value)
	end
end

function MPLVariable:Get()
	return self.Value
end

MPLmetadata.variableindexer1 = "varloaded0MPL"
MPLmetadata.variableindexer2 = "varused0MPL"

function MPLmetadata:Variable(name, defaultValue): {
	Name: string,
	Value: any?,
	defaultValue: any,
	Changed: MadSignal,
	AlwaysSave: boolean,
	CanSave: boolean,

	Set: (self: {}, newValue: any) -> (),
	Save: (self: {}) -> (),
	Get: (self: {}) -> any?,

	}
	self:__resolveType(types.Variable(name, defaultValue)) -- Checks for a function.

	local Variable = setmetatable({
		__Instance = self,

		Name = name,
		Value = if self:GetSetting(name..self.variableindexer1) then self:GetSetting(name..self.variableindexer2) else defaultValue,
		Changed = MadSignal.new(),
		defaultValue = defaultValue,
		AlwaysSave = false,
		CanSave = true,
	}, MPLVariable)

	if not self.Variables then
		self.Variables = {}
	end

	table.insert(self.Variables, Variable)

	return Variable
end


function MPLmetadata:OnRibbonSpaceModeChanged(callback: (boolean) -> ()): RBXScriptConnection
	self:__resolveType(types.AssignUnloadingFunction(callback)) -- Checks for a function.
	return StudioService:GetPropertyChangedSignal("UseLocalSpace"):Connect(callback)
end

function MPLmetadata:SetRibbonTool(RibbonTool: Enum.RibbonTool | number | string)
	self:__initCheck()

	self:__resolveType(types.SetRibbonTool(RibbonTool))

	local RequestedRibbonTool = switch(typeof(RibbonTool), {
		["number"] = function()
			return Enum.RibbonTool:FromValue(tonumber(RibbonTool) or 0)
		end,

		["string"] = function()
			return Enum.RibbonTool:FromName(tostring(RibbonTool) or "None")
		end,
	}, function()
		return RibbonTool
	end)

	local attempts = 0
	while self.plugin:GetSelectedRibbonTool() ~= RequestedRibbonTool and attempts < 10 do
		self.plugin:SelectRibbonTool(RequestedRibbonTool, UDim2Identity)
		attempts += 1
		task.wait()
	end
	if attempts >= 10 then
		self:__error("Failed to set RibbonTool after 10 attempts.")
	end
end

function MPLmetadata:ClearDestroyedInstances()
	for _, connection in self.Unloading do
		if typeof(connection) == "Instance" and connection.Parent == nil then
			table.remove(self.Unloading, table.find(self.Unloading, connection))
		end
	end
end

function MPLmetadata:ClearDisconnectedRBXSignals()
	for _, connection in self.Unloading do
		if typeof(connection) == "RBXScriptConnection" and not connection.Connected then
			table.remove(self.Unloading, table.find(self.Unloading, connection))
		end
	end
end

function MPLmetadata:SetGridIncrement(newIncrement: number)
	StudioService.GridSize = newIncrement
end

function MPLmetadata:GetGridIncrement(): number
	return StudioService.GridSize
end

function MPLmetadata:NewSoundContainer()
	if self.SoundContainer then
		self:__error("Only one sound container is allowed at a time")
		return
	end

	local thisWindow = self:CreateWindow("SoundContainer/"..generateID(10), DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float, false, true, 250, 250, 250, 250
		)
	)

	self.SoundContainer = thisWindow
end

function MPLmetadata:InsertSoundObject(soundObject: Sound): Sound
	self:__resolveType(types.InsertSoundObject(soundObject))

	if not self.SoundContainer then
		self:__error("No sound container found, call NewSoundContainer before inserting a sound object.")
	end

	soundObject.Parent = self.SoundContainer

	return soundObject
end

MPLmetadata.WindowToggle = function(Window: DockWidgetPluginGui)
	return function()
		Window.Enabled = not Window.Enabled
	end
end

local Selection = game:GetService("Selection")

function MPLmetadata:GetSelected(): {Instances}
	return Selection:Get()	
end

function MPLmetadata:SetSelection(targets: Instance | {Instances})
	if typeof(targets) == "Instance" then
		Selection:Set({targets})
	else
		Selection:Set(targets)
	end
end

local players = game:GetService("Players")

-- Will return a boolean if networking can be enabled.
function MPLmetadata:EnableNetworkingEngine(): boolean
	if not players.LocalPlayer then
		return false
	end

	self.NetworkingEngineEnabled = true

	local folder = string.split(string.split(self.plugin.Name, "_")[2], ".")[1]

	local networkFolder = players.LocalPlayer:FindFirstChild("MPL-Networking") or (function()
		local folder = Instance.new("Folder", players.LocalPlayer)

		folder.Name = "MPL-Networking"

		self:AssignInstance(folder)

		return folder
	end)()

	self.NetworkFolder = Instance.new("Folder", networkFolder)
	self.NetworkFolder.Archivable = false

	self.NetworkFolder.Name = folder

	self:AssignInstance(self.NetworkFolder)

	return true
end

function MPLmetadata:EachRemoteBridge(bridgeName, callback, includeOwnBridge)
	self:__resolveType(types.EachRemoteBridge(bridgeName,callback,includeOwnBridge))

	local function check(v)
		if v:IsA("Player") then
			if v ~= players.LocalPlayer or includeOwnBridge then
				local RemoteFolder = v:FindFirstChild("MPL-Networking")

				if RemoteFolder then
					local function check(pluginRemoteFolder)
						self:ListenToRemoteBridge(pluginRemoteFolder:WaitForChild(bridgeName), callback)
					end

					for _,pluginRemoteFolder in RemoteFolder:GetChildren() do
						task.spawn(check,pluginRemoteFolder)
					end

					self:AssignRBXScriptConnection(RemoteFolder.ChildAdded:Connect(check))
				end
			end

			self:AssignRBXScriptConnection(v.ChildAdded:Connect(function()
				check(v)
			end))
		end
	end

	for _,v in players:GetChildren() do
		check(v)
	end

	self:AssignRBXScriptConnection(players.PlayerAdded:Connect(check))
end

local httpService = game:GetService("HttpService")
local debris = game:GetService("Debris")

function MPLmetadata:FireRemoteBridge(bridge, ...)
	local args = { ... }

	local chunkSize = 200000
	local data = httpService:JSONEncode(args)

	local stringValue = Instance.new("StringValue")

	stringValue.Name = os.time()

	if #data > chunkSize then
		local count = 0
		stringValue:SetAttribute("limited", true)
		for i = 1, #data, chunkSize do
			count += 1
			local part = string.sub(data, i, i + chunkSize - 1)
			stringValue:SetAttribute(count, part)
			task.wait()
		end
	else
		stringValue.Value = data
	end

	stringValue.Archivable = false
	stringValue.Parent = bridge

	debris:AddItem(stringValue, 5)
end

local function compute(v)
	if v:GetAttribute("limited") then
		local ordered = {}
		local output = ""
		for index, value in v:GetAttributes() do
			if tonumber(index) then
				ordered[tonumber(index)] = value
				task.wait()
			end
		end

		for _, v in ipairs(ordered) do
			output ..= v
		end

		return output
	else
		return v.Value
	end
end

function MPLmetadata:ListenToRemoteBridge(bridge, callback)
	self:AssignRBXScriptConnection(bridge.ChildAdded:Connect(function(v: StringValue)
		local success, result = pcall(httpService.JSONDecode, httpService, compute(v))
		if success then
			if not bridge:IsDescendantOf(game) then
				return
			end

			callback(bridge.Parent.Parent.Parent, bridge, table.unpack(result))
		end
	end))

	for _,v in bridge:GetChildren() do		
		local success, result = pcall(httpService.JSONDecode, httpService, compute(v))

		if success then
			if not bridge:IsDescendantOf(game) then
				continue
			end

			callback(bridge.Parent.Parent.Parent, bridge, table.unpack(result))
		end
	end
end

function MPLmetadata:NewRemoteBridge(bridgeName)
	if not self.NetworkingEngineEnabled then
		self:__error("Networking engine is not enabled, call EnableNetworkingEngine before creating a remote bridge.")
		return
	end

	self:__resolveType(types.NewRemoteBridge(bridgeName))

	local Folder = Instance.new("Folder", self.NetworkFolder)
	Folder.Name = bridgeName

	self:AssignInstance(Folder)

	return Folder
end

function MPLmetadata:__initCheck()
	if not self.plugin then
		error("MPL instance not initialized with a valid plugin", 2)
	end
end

MPL.Config = {
	WarningsDisabled = false,
	AutomaticSetSettingValidation = true,
}

function MPL.new(plugin: Plugin)
	local self = setmetatable({}, MPLmetadata)

	self.plugin = plugin

	self.Toolbars = {} :: {[string]: PluginToolbar}
	self.Windows = {}

	self.Unloading = {}

	self.SoundContainer = nil

	self.OnUnloadSignal = plugin.Unloading:Connect(function()
		for _, connection in self.Unloading do
			if typeof(connection) == "function" then
				task.spawn(connection)
			elseif typeof(connection) == "RBXScriptConnection" and connection.Connected then
				connection:Disconnect()
			elseif typeof(connection) == "Instance" then
				pcall(connection.Destroy, connection)
			end
		end

		for _, variable in self.Variables or {} do
			variable:Save(true)
		end
	end)

	return self
end

return MPL]]></ProtectedString>
					<string name="ScriptGuid">{AF6E6F0C-6C3A-4321-BEA9-741C6C5E6B6D}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">MPL</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX1012F409D6544B7BA10C15D3FBA95C42">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

--!nocheck

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false, "unexpected non-NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Content type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Content = t.typeof("Content")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is any of the given literal values

	@param literals The literals to check against

	@returns A function that will return true if the condition is passed
**--]]
function t.literalList(literals)
	-- optimization for primitive types
	local set = {}
	for _, literal in ipairs(literals) do
		set[literal] = true
	end
	return function(value)
		if set[value] then
			return true
		end
		for _, literal in ipairs(literals) do
			if literal == value then
				return true
			end
		end

		return false, "bad type for literal list"
	end
end

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.unionList(literals)
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end

	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end

		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)
		if not stringSuccess then
			return false, stringErrMsg
		end

		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])
				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param checks The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.unionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false, "bad type for union"
		end
	end

--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		return t.unionList({ ... })
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param checks The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersectionList(checks)
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		return t.intersectionList({ ... })
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)
			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])
				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

return t
]]></ProtectedString>
						<string name="ScriptGuid">{E9F473CE-AEC8-4504-BFFF-07DB555A3CC1}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">t</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXCFE9378090644E41A1E48E9844D40B2A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[--!strict 

local Cryptography = table.freeze({
	Hashing = require("@self/Hashing"),
	Checksums = require("@self/Checksums"),
	Utilities = require("@self/Utilities"),
	Encryption = require("@self/Encryption"),
	Verification = require("@self/Verification")
})

return Cryptography]]></ProtectedString>
					<string name="ScriptGuid">{D063BA02-B67A-4FA3-ABB8-1EE38DC8E6A2}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Cryptography</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX9D88856A82E541DD83CA69BDAEA3F4F4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!strict

local Algorithms = table.freeze({
	CRC32 = require("@self/CRC32"),
	Adler = require("@self/Adler")
})

return Algorithms]]></ProtectedString>
						<string name="ScriptGuid">{4F46BE2F-CB14-4E5B-80AA-12FDE8EB309E}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Checksums</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA926FB4FB8F94C9097694995D5A8B2EE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Adler

	Return type: number
	Example Usage:
		local Message = buffer.fromstring("Hello World")
		local Hash = Adler(Message)
--]=]

--!strict
--!optimize 2
--!native

local function Adler(Message: buffer): number
	local MOD_ALDER = 65522

	local Sum = bit32.band(bit32.rshift(MOD_ALDER, 16), 0xffff)
	MOD_ALDER = bit32.band(MOD_ALDER, 0xffff)

	local MessageLength = buffer.len(Message)

	if MessageLength == 1 then
		MOD_ALDER += buffer.readu8(Message, 0)
		if MOD_ALDER >= 65521 then
			MOD_ALDER -= 65521
		end

		Sum += MOD_ALDER
		if Sum >= 65521 then
			Sum -= 65521
		end

		return bit32.bor(MOD_ALDER, bit32.lshift(Sum, 16))
	end

	if MessageLength == 0 then
		return 0x1
	end

	local BufferPointer = 0

	if MessageLength < 16 then
		while MessageLength > 0 do
			local Value = buffer.readu8(Message, BufferPointer)

			MOD_ALDER += Value
			Sum += MOD_ALDER

			BufferPointer += 1
			MessageLength -= 1
		end

		if MOD_ALDER >= 65521 then
			MOD_ALDER -= 65521
		end
		Sum %= 65521

		return bit32.bor(MOD_ALDER, bit32.lshift(Sum, 16)) 
	end

	local NMAX = 5552
	while MessageLength >= NMAX do
		MessageLength -= NMAX

		local Iters = NMAX / 16
		while Iters > 0 do
			Iters -= 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1
		end
	end

	if MessageLength > 0 then
		while MessageLength >= 16 do
			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1

			MessageLength -= 16
		end

		while MessageLength > 0 do
			MOD_ALDER += buffer.readu8(Message, BufferPointer)
			Sum += MOD_ALDER
			BufferPointer += 1
			MessageLength -= 1
		end

		MOD_ALDER %= 65521
		Sum %= 65521
	end

	return bit32.bor(MOD_ALDER, bit32.lshift(Sum, 16))
end

return Adler]]></ProtectedString>
							<string name="ScriptGuid">{6EE2B736-98FD-4B44-B247-1900EF644F42}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Adler</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5663E1437EC54D2F963369CDA6B9D2B6">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: CRC32
	Function can return JAM or ISO-HDLC CRC32 checksums.
	
	Return type: number in regular mode, string in hex mode
	Example Usage:
		local Message = buffer.fromstring("Hello World")
		
		--------Usage Case 1--------
		local Hash = CRC32(Message)

		--------Usage Case 2--------
		local Hash = CRC32(Message, "Jam")
		
		--------Usage Case 3--------
		local Hash = CRC32(Message, "Jam", true)
--]=]

--!strict
--!optimize 2
--!native

local CRC32_LOOKUP = table.create(256) :: {number}
for Index = 0, 255 do
	local CRC = Index
	for _ = 1, 8 do
		if bit32.band(CRC, 1) == 1 then
			CRC = bit32.bxor(bit32.rshift(CRC, 1), 0xEDB88320)
		else
			CRC = bit32.rshift(CRC, 1)
		end
	end

	CRC32_LOOKUP[Index + 1] = CRC
end

local function CRC32(Message: buffer, Mode: "Jam" | "Iso"?, Hex: boolean?): number | string
	local Lookup = CRC32_LOOKUP
	local Hash = 0xFFFFFFFF

	local Leftover = buffer.len(Message) % 4
	
	for Index = 0, Leftover - 1 do
		local Value = buffer.readu8(Message, Index)
		local TableIndex = bit32.band(bit32.bxor(Hash, Value), 0xFF) + 1

		Hash = bit32.bxor(
			Lookup[TableIndex],
			bit32.rshift(Hash, 8)
		)
	end
	
	for Index = Leftover, buffer.len(Message) - 1, 4 do
		local TableIndex = bit32.band(bit32.bxor(Hash, buffer.readu8(Message, Index)), 0xFF) + 1
		Hash = bit32.bxor(Lookup[TableIndex], bit32.rshift(Hash, 8))
		
		TableIndex = bit32.band(bit32.bxor(Hash, buffer.readu8(Message, Index + 1)), 0xFF) + 1
		Hash = bit32.bxor(Lookup[TableIndex], bit32.rshift(Hash, 8))
		
		TableIndex = bit32.band(bit32.bxor(Hash, buffer.readu8(Message, Index + 2)), 0xFF) + 1
		Hash = bit32.bxor(Lookup[TableIndex], bit32.rshift(Hash, 8))

		TableIndex = bit32.band(bit32.bxor(Hash, buffer.readu8(Message, Index + 3)), 0xFF) + 1
		Hash = bit32.bxor(Lookup[TableIndex], bit32.rshift(Hash, 8))
	end

	if Mode == "Jam" then
		return Hex == true and string.format("%08x", Hash) or Hash
	end

	Hash = bit32.bxor(Hash, 0xFFFFFFFF)
	return Hex == true and string.format("%08x", Hash) or Hash
end

return CRC32]]></ProtectedString>
							<string name="ScriptGuid">{2736D53F-BBB3-4D22-AF42-167CF273E1D4}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CRC32</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX77D8F11EB80B4A7C92CAE4F321C4BD66">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!strict

local Algorithms = table.freeze({
	AEAD = require("@self/AEAD"),
	AES = require("@self/AES"),
	XOR = require("@self/XOR"),
	Simon = require("@self/Simon"),
	Speck = require("@self/Speck")
})

return Algorithms]]></ProtectedString>
						<string name="ScriptGuid">{FA7F755C-9B0B-4157-9131-D49298DDACBE}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Encryption</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2F1D8B0DB7E24BC59AD2F38EC7A73544">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: ChaCha20-Poly1305 AEAD
	
	Sizes:
		Key: 16/32 bytes
		Nonce: 12/24 bytes
		Tag: 16 bytes
		Rounds: even positive integer (default: 20)
	
	Return type: buffer, buffer (ciphertext, tag)
	Example usage:
		local Plaintext = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		local Nonce = buffer.fromstring(string.rep("n", 12))
		local AAD = buffer.fromstring("additional data")
		
		--------Usage Case 1--------
		local Ciphertext, Tag = AEAD.Encrypt(Plaintext, Key, Nonce, AAD, Rounds, UseXChaCha20)
		
		--------Usage Case 2--------
		local DecryptedText = AEAD.Decrypt(Ciphertext, Key, Nonce, Tag, AAD, Rounds, UseXChaCha20)
--]=]

--!strict
--!optimize 2
--!native

local ChaCha = require("@self/ChaCha")
local Poly1305 = require("@self/Poly1305")

local QWORD = 8

local CHACHA20_KEY_SIZE = 32
local CHACHA20_NONCE_SIZE = 12
local XCHACHA20_NONCE_SIZE = 24
local POLY1305_TAG_SIZE = 16

local AEAD = {
	ChaCha20 = ChaCha.ChaCha20,
	XChaCha20 = ChaCha.XChaCha20,
	Poly1305 = Poly1305
}

local function GetFn(UseXChaCha20: boolean?): typeof(ChaCha.ChaCha20) | typeof(ChaCha.XChaCha20)
	if UseXChaCha20 then
		return ChaCha.XChaCha20
	else
		return ChaCha.ChaCha20
	end
end

local function ConstantTimeCompare(Buffer1: buffer, Buffer2: buffer): boolean
	local Length1 = buffer.len(Buffer1)
	local Length2 = buffer.len(Buffer2)
	if Length1 ~= Length2 then
		return false
	end

	local Difference = 0
	for Index = 0, Length1 - 1 do
		Difference = bit32.bor(Difference, bit32.bxor(
			buffer.readu8(Buffer1, Index),
			buffer.readu8(Buffer2, Index)
			))
	end

	return Difference == 0
end

local function ConstructAuthData(AAD: buffer, Ciphertext: buffer): buffer
	local AADLength = buffer.len(AAD)
	local CiphertextLength = buffer.len(Ciphertext)

	local AADPadding = (-AADLength) % 16
	local CiphertextPadding = (-CiphertextLength) % 16

	local TotalSize = AADLength + AADPadding + CiphertextLength + CiphertextPadding + 16
	local AuthData = buffer.create(TotalSize)
	local Offset = 0

	buffer.copy(AuthData, Offset, AAD, 0, AADLength)
	Offset += AADLength + AADPadding
	buffer.copy(AuthData, Offset, Ciphertext, 0, CiphertextLength)
	Offset += CiphertextLength + CiphertextPadding
	buffer.writeu32(AuthData, Offset, AADLength)
	buffer.writeu32(AuthData, Offset + QWORD, CiphertextLength)

	return AuthData
end

local function GenerateAuthKey(Key: buffer, Nonce: buffer, Rounds: number?, UseXChaCha20: boolean?): buffer
	local BlockRounds = Rounds or 20
	local ZeroBlock = buffer.create(32)

	return GetFn(UseXChaCha20)(ZeroBlock, Key, Nonce, 0, BlockRounds)
end

function AEAD.Encrypt(Message: buffer, Key: buffer, Nonce: buffer, AdditionalAuthData: buffer?, Rounds: number?, UseXChaCha20: boolean?): (buffer, buffer)
	if Message == nil then
		error("Message cannot be nil", 2)
	end

	if typeof(Message) ~= "buffer" then
		error(`Message must be a buffer, got {typeof(Message)}`, 2)
	end

	local MessageLength = buffer.len(Message)
	if MessageLength == 0 then
		error("Message cannot be empty", 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE then
		error(`Key must be exactly {CHACHA20_KEY_SIZE} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	local RequiredNonceLength = if UseXChaCha20 then XCHACHA20_NONCE_SIZE else CHACHA20_NONCE_SIZE
	if NonceLength ~= RequiredNonceLength then
		error(`Nonce must be exactly {RequiredNonceLength} bytes long, got {NonceLength} bytes`, 2)
	end

	if AdditionalAuthData then
		if typeof(AdditionalAuthData) ~= "buffer" then
			error(`AdditionalAuthData must be a buffer, got {typeof(AdditionalAuthData)}`, 2)
		end
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockRounds = Rounds or 20
	local AAD = AdditionalAuthData or buffer.create(0)

	local AuthenticationKey = GenerateAuthKey(Key, Nonce, BlockRounds, UseXChaCha20)
	local Ciphertext = GetFn(UseXChaCha20)(Message, Key, Nonce, 1, BlockRounds)
	local AuthData = ConstructAuthData(AAD, Ciphertext)
	local Tag = Poly1305(AuthData, AuthenticationKey)

	return Ciphertext, Tag
end

function AEAD.Decrypt(Ciphertext: buffer, Key: buffer, Nonce: buffer, Tag: buffer, AdditionalAuthData: buffer?, Rounds: number?, UseXChaCha20: boolean?): buffer?
	if Ciphertext == nil then
		error("Ciphertext cannot be nil", 2)
	end

	if typeof(Ciphertext) ~= "buffer" then
		error(`Ciphertext must be a buffer, got {typeof(Ciphertext)}`, 2)
	end

	local CiphertextLength = buffer.len(Ciphertext)
	if CiphertextLength == 0 then
		error("Ciphertext cannot be empty", 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE then
		error(`Key must be exactly {CHACHA20_KEY_SIZE} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	local RequiredNonceLength = if UseXChaCha20 then XCHACHA20_NONCE_SIZE else CHACHA20_NONCE_SIZE
	if NonceLength ~= RequiredNonceLength then
		error(`Nonce must be exactly {RequiredNonceLength} bytes long, got {NonceLength} bytes`, 2)
	end

	if Tag == nil then
		error("Tag cannot be nil", 2)
	end

	if typeof(Tag) ~= "buffer" then
		error(`Tag must be a buffer, got {typeof(Tag)}`, 2)
	end

	local TagLength = buffer.len(Tag)
	if TagLength ~= POLY1305_TAG_SIZE then
		error(`Tag must be exactly {POLY1305_TAG_SIZE} bytes long, got {TagLength} bytes`, 2)
	end

	if AdditionalAuthData then
		if typeof(AdditionalAuthData) ~= "buffer" then
			error(`AdditionalAuthData must be a buffer, got {typeof(AdditionalAuthData)}`, 2)
		end
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockRounds = Rounds or 20
	local AAD = AdditionalAuthData or buffer.create(0)

	local AuthenticationKey = GenerateAuthKey(Key, Nonce, BlockRounds, UseXChaCha20)
	local AuthData = ConstructAuthData(AAD, Ciphertext)
	local ExpectedTag = Poly1305(AuthData, AuthenticationKey)

	if not ConstantTimeCompare(Tag, ExpectedTag) then
		return nil
	end

	return GetFn(UseXChaCha20)(Ciphertext, Key, Nonce, 1, BlockRounds)
end

return AEAD]]></ProtectedString>
							<string name="ScriptGuid">{C76870DC-49C3-4CA3-AC42-2821333EE5F1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">AEAD</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX77074246F56C4E519CEB9176FEFA69B3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: ChaCha20
	
	Sizes:
		Nonce: 12/24 bytes
		Key: 16/32 bytes
	
	Return type: buffer
	Example usage:
		local Data = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		local Nonce = buffer.fromstring(string.rep("n", 12))
		
		--------Usage Case 1--------
		local Encrypted = ChaCha.ChaCha20(Data, Key, Nonce)
		
		--------Usage Case 2--------
		local LongNonce = buffer.fromstring(string.rep("n", 24))
		local Encrypted = ChaCha.XChaCha20(Data, Key, LongNonce)
--]=]

--!strict
--!optimize 2
--!native

local ChaCha = {}

local DWORD = 4
local BLOCK_SIZE = 64
local STATE_SIZE = 16

local CHACHA20_NONCE_SIZE = 12
local XCHACHA20_NONCE_SIZE = 24

local CHACHA20_KEY_SIZE_16 = 16
local CHACHA20_KEY_SIZE_32 = 32

local SIGMA_CONSTANTS = buffer.create(16) do
	local SigmaBytes = { string.byte("expand 32-byte k", 1, -1) }
	for Index, ByteValue in SigmaBytes do
		buffer.writeu8(SIGMA_CONSTANTS, Index - 1, ByteValue)
	end
end

local TAU_CONSTANTS = buffer.create(16) do
	local TauBytes = { string.byte("expand 16-byte k", 1, -1) }
	for Index, ByteValue in TauBytes do
		buffer.writeu8(TAU_CONSTANTS, Index - 1, ByteValue)
	end
end

local function ProcessBlock(InitialState: buffer, Rounds: number)
	local S0: number, S1: number, S2: number, S3: number, S4: number, S5: number, S6: number, S7: number, S8: number, S9: number, S10: number, S11: number, S12: number, S13: number, S14: number, S15: number =
		buffer.readu32(InitialState, 0), buffer.readu32(InitialState, 4),
		buffer.readu32(InitialState, 8), buffer.readu32(InitialState, 12),
		buffer.readu32(InitialState, 16), buffer.readu32(InitialState, 20),
		buffer.readu32(InitialState, 24), buffer.readu32(InitialState, 28),
		buffer.readu32(InitialState, 32), buffer.readu32(InitialState, 36),
		buffer.readu32(InitialState, 40), buffer.readu32(InitialState, 44),
		buffer.readu32(InitialState, 48), buffer.readu32(InitialState, 52),
		buffer.readu32(InitialState, 56), buffer.readu32(InitialState, 60)

	for Round = 1, Rounds do
		local IsOddRound = Round % 2 == 1

		if IsOddRound then
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 16)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 12)
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 8)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 7)

			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 16)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 12)
			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 8)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 7)

			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 16)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 12)
			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 8)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 7)

			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 16)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 12)
			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 8)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 7)
		else
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 16)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 12)
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 8)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 7)

			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 16)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 12)
			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 8)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 7)

			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 16)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 12)
			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 8)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 7)

			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 16)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 12)
			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 8)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 7)
		end
	end

	buffer.writeu32(InitialState, 0, buffer.readu32(InitialState, 0) + S0)
	buffer.writeu32(InitialState, 4, buffer.readu32(InitialState, 4) + S1)
	buffer.writeu32(InitialState, 8, buffer.readu32(InitialState, 8) + S2)
	buffer.writeu32(InitialState, 12, buffer.readu32(InitialState, 12) + S3)
	buffer.writeu32(InitialState, 16, buffer.readu32(InitialState, 16) + S4)
	buffer.writeu32(InitialState, 20, buffer.readu32(InitialState, 20) + S5)
	buffer.writeu32(InitialState, 24, buffer.readu32(InitialState, 24) + S6)
	buffer.writeu32(InitialState, 28, buffer.readu32(InitialState, 28) + S7)
	buffer.writeu32(InitialState, 32, buffer.readu32(InitialState, 32) + S8)
	buffer.writeu32(InitialState, 36, buffer.readu32(InitialState, 36) + S9)
	buffer.writeu32(InitialState, 40, buffer.readu32(InitialState, 40) + S10)
	buffer.writeu32(InitialState, 44, buffer.readu32(InitialState, 44) + S11)
	buffer.writeu32(InitialState, 48, buffer.readu32(InitialState, 48) + S12)
	buffer.writeu32(InitialState, 52, buffer.readu32(InitialState, 52) + S13)
	buffer.writeu32(InitialState, 56, buffer.readu32(InitialState, 56) + S14)
	buffer.writeu32(InitialState, 60, buffer.readu32(InitialState, 60) + S15)
end

local function InitializeState(Key: buffer, Nonce: buffer, Counter: number): buffer
	local KeyLength = buffer.len(Key)
	local State = buffer.create(STATE_SIZE * DWORD)

	local Constants = KeyLength == 32 and SIGMA_CONSTANTS or TAU_CONSTANTS

	buffer.copy(State, 0, Constants, 0, 16)

	buffer.copy(State, 16, Key, 0, math.min(KeyLength, 16))
	if KeyLength == 32 then
		buffer.copy(State, 32, Key, 16, 16)
	else
		buffer.copy(State, 32, Key, 0, 16)
	end

	buffer.writeu32(State, 48, Counter)
	buffer.copy(State, 52, Nonce, 0, 12)

	return State
end

function ChaCha.ChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?): buffer
	if Data == nil then
		error("Data cannot be nil", 2)
	end

	if typeof(Data) ~= "buffer" then
		error(`Data must be a buffer, got {typeof(Data)}`, 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE_16 and KeyLength ~= CHACHA20_KEY_SIZE_32 then
		error(`Key must be {CHACHA20_KEY_SIZE_16} or {CHACHA20_KEY_SIZE_32} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	if NonceLength ~= CHACHA20_NONCE_SIZE then
		error(`Nonce must be exactly {CHACHA20_NONCE_SIZE} bytes long, got {NonceLength} bytes`, 2)
	end

	if Counter then
		if typeof(Counter) ~= "number" then
			error(`Counter must be a number, got {typeof(Counter)}`, 2)
		end

		if Counter < 0 then
			error(`Counter cannot be negative, got {Counter}`, 2)
		end

		if Counter ~= math.floor(Counter) then
			error(`Counter must be an integer, got {Counter}`, 2)
		end

		if Counter >= 2^32 then
			error(`Counter must be less than 2^32, got {Counter}`, 2)
		end
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds ~= math.floor(Rounds) then
			error(`Rounds must be an integer, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockCounter = Counter or 1
	local BlockRounds = Rounds or 20

	local DataLength = buffer.len(Data)
	if DataLength == 0 then
		return buffer.create(0)
	end

	local Output = buffer.create(DataLength)

	local DataOffset = 0

	local State = InitializeState(Key, Nonce, BlockCounter)
	local StateBackup = buffer.create(64)
	buffer.copy(StateBackup, 0, State, 0)

	while DataOffset < DataLength do
		ProcessBlock(State, BlockRounds)

		local BytesToProcess = math.min(BLOCK_SIZE, DataLength - DataOffset)

		for Index = 0, BytesToProcess - 1 do
			local DataByte = buffer.readu8(Data, DataOffset + Index)
			local KeystreamByte = buffer.readu8(State, Index)
			buffer.writeu8(Output, DataOffset + Index, bit32.bxor(DataByte, KeystreamByte))
		end

		DataOffset += BytesToProcess
		BlockCounter += 1
		buffer.copy(State, 0, StateBackup, 0)
		buffer.writeu32(State, 48, BlockCounter)
	end

	return Output
end

function ChaCha.HChaCha20(Key: buffer, Nonce: buffer, Rounds: number?) : buffer
	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE_16 and KeyLength ~= CHACHA20_KEY_SIZE_32 then
		error(`Key must be {CHACHA20_KEY_SIZE_16} or {CHACHA20_KEY_SIZE_32} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	if NonceLength ~= 16 then
		error(`HChaCha20 requires a 16-byte nonce, got {NonceLength} bytes`, 2)
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds ~= math.floor(Rounds) then
			error(`Rounds must be an integer, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockRounds = Rounds or 20

	local Key32: buffer
	if KeyLength == CHACHA20_KEY_SIZE_32 then
		Key32 = Key
	else
		Key32 = buffer.create(32)
		buffer.copy(Key32, 0, Key, 0, 16)
		buffer.copy(Key32, 16, Key, 0, 16)
	end

	local Constants = (buffer.len(Key32) == 32) and SIGMA_CONSTANTS or TAU_CONSTANTS

	local State = buffer.create(STATE_SIZE * DWORD)
	buffer.copy(State, 0, Constants, 0, 16)
	buffer.copy(State, 16, Key32, 0, 16)
	buffer.copy(State, 32, Key32, 16, 16)
	buffer.copy(State, 48, Nonce, 0, 16)

	local S0: number, S1: number, S2: number, S3: number, S4: number, S5: number, S6: number, S7: number, S8: number, S9: number, S10: number, S11: number, S12: number, S13: number, S14: number, S15: number =
		buffer.readu32(State, 0), buffer.readu32(State, 4),
		buffer.readu32(State, 8), buffer.readu32(State, 12),
		buffer.readu32(State, 16), buffer.readu32(State, 20),
		buffer.readu32(State, 24), buffer.readu32(State, 28),
		buffer.readu32(State, 32), buffer.readu32(State, 36),
		buffer.readu32(State, 40), buffer.readu32(State, 44),
		buffer.readu32(State, 48), buffer.readu32(State, 52),
		buffer.readu32(State, 56), buffer.readu32(State, 60)

	for Round = 1, BlockRounds do
		local IsOddRound = Round % 2 == 1

		if IsOddRound then
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 16)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 12)
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 8)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 7)

			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 16)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 12)
			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 8)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 7)

			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 16)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 12)
			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 8)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 7)

			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 16)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 12)
			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 8)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 7)
		else
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 16)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 12)
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 8)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 7)

			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 16)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 12)
			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 8)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 7)

			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 16)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 12)
			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 8)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 7)

			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 16)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 12)
			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 8)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 7)
		end
	end

	local Subkey = buffer.create(32)
	buffer.writeu32(Subkey, 0, S0)
	buffer.writeu32(Subkey, 4, S1)
	buffer.writeu32(Subkey, 8, S2)
	buffer.writeu32(Subkey, 12, S3)
	buffer.writeu32(Subkey, 16, S12)
	buffer.writeu32(Subkey, 20, S13)
	buffer.writeu32(Subkey, 24, S14)
	buffer.writeu32(Subkey, 28, S15)

	return Subkey
end

function ChaCha.XChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?) : buffer
	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	if NonceLength ~= XCHACHA20_NONCE_SIZE then
		error(`XChaCha20 requires a 24-byte nonce, got {NonceLength} bytes`, 2)
	end

	local Subkey = ChaCha.HChaCha20(Key, (function()
		local N = buffer.create(16)
		buffer.copy(N, 0, Nonce, 0, 16)
		return N
	end)(), Rounds)

	local ChaNonce = buffer.create(12)
	buffer.copy(ChaNonce, 4, Nonce, 16, 8)

	return ChaCha.ChaCha20(Data, Subkey, ChaNonce, Counter, Rounds)
end

return ChaCha]]></ProtectedString>
								<string name="ScriptGuid">{69998D72-733F-4BDD-9007-74F14DB00CF1}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ChaCha</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF3FD7F7F03EB4389A52747F7326CA2B7">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Poly1305
	
	Sizes:
		Key: 32 bytes
		Tag: 16 bytes
	
	Return type: buffer
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		
		local Tag = Poly1305(Message, Key)
--]=]

--!strict
--!optimize 2
--!native

local TAG_SIZE = 16
local BLOCK_SIZE = 16
local POLY1305_KEY_SIZE = 32

local function ProcessMessage(Message: buffer, Key: buffer): buffer
	local MessageLength = buffer.len(Message)

	local PaddedMessage = Message
	local ProcessLength = MessageLength

	if MessageLength % BLOCK_SIZE ~= 0 or MessageLength == 0 then
		local PaddingSize = BLOCK_SIZE - (MessageLength % BLOCK_SIZE)
		ProcessLength = MessageLength + PaddingSize
		PaddedMessage = buffer.create(ProcessLength)
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
		buffer.writeu8(PaddedMessage, MessageLength, 1)
	end

	local PartialBlockLength = MessageLength - 15

	local R0 = buffer.readu32(Key, 0) % (2 ^ 28)
	local R1 = bit32.band(buffer.readu32(Key, 4), 0x0FFFFFFC) % (2 ^ 28) * (2 ^ 32)
	local R2 = bit32.band(buffer.readu32(Key, 8), 0x0FFFFFFC) % (2 ^ 28) * (2 ^ 64)
	local R3 = bit32.band(buffer.readu32(Key, 12), 0x0FFFFFFC) % (2 ^ 28) * (2 ^ 96)

	local R0Low = R0 % (2 ^ 18)
	local R0High = R0 - R0Low
	local R1Low = R1 % (2 ^ 50)
	local R1High = R1 - R1Low
	local R2Low = R2 % (2 ^ 82)
	local R2High = R2 - R2Low
	local R3Low = R3 % (2 ^ 112)
	local R3High = R3 - R3Low

	local S1 = 5 / (2 ^ 130) * R1
	local S2 = 5 / (2 ^ 130) * R2
	local S3 = 5 / (2 ^ 130) * R3

	local S1Low = S1 % (2 ^ -80)
	local S1High = S1 - S1Low
	local S2Low = S2 % (2 ^ -48)
	local S2High = S2 - S2Low
	local S3Low = S3 % (2 ^ -16)
	local S3High = S3 - S3Low

	local Accumulator0, Accumulator1, Accumulator2, Accumulator3 = 0, 0, 0, 0
	local Accumulator4, Accumulator5, Accumulator6, Accumulator7 = 0, 0, 0, 0

	for BlockOffset = 0, ProcessLength - 1, BLOCK_SIZE do
		local MessageBlock0 = buffer.readu32(PaddedMessage, BlockOffset)
		local MessageBlock1 = buffer.readu32(PaddedMessage, BlockOffset + 4)
		local MessageBlock2 = buffer.readu32(PaddedMessage, BlockOffset + 8)
		local MessageBlock3 = buffer.readu32(PaddedMessage, BlockOffset + 12)

		local X0 = Accumulator0 + Accumulator1 + MessageBlock0
		local X2 = Accumulator2 + Accumulator3 + MessageBlock1 * (2 ^ 32)
		local X4 = Accumulator4 + Accumulator5 + MessageBlock2 * (2 ^ 64)
		local X6 = Accumulator6 + Accumulator7 + MessageBlock3 * (2 ^ 96)

		if BlockOffset < PartialBlockLength then
			X6 = X6 + (2 ^ 128)
		end

		Accumulator0 = X0 * R0Low + X2 * S3Low + X4 * S2Low + X6 * S1Low
		Accumulator1 = X0 * R0High + X2 * S3High + X4 * S2High + X6 * S1High
		Accumulator2 = X0 * R1Low + X2 * R0Low + X4 * S3Low + X6 * S2Low
		Accumulator3 = X0 * R1High + X2 * R0High + X4 * S3High + X6 * S2High
		Accumulator4 = X0 * R2Low + X2 * R1Low + X4 * R0Low + X6 * S3Low
		Accumulator5 = X0 * R2High + X2 * R1High + X4 * R0High + X6 * S3High
		Accumulator6 = X0 * R3Low + X2 * R2Low + X4 * R1Low + X6 * R0Low
		Accumulator7 = X0 * R3High + X2 * R2High + X4 * R1High + X6 * R0High

		local Y0 = Accumulator0 + 3 * (2 ^ 69) - 3 * (2 ^ 69)
		Accumulator0 -= Y0
		Accumulator1 += Y0

		local Y1 = Accumulator1 + 3 * (2 ^ 83) - 3 * (2 ^ 83)
		Accumulator1 -= Y1
		Accumulator2 += Y1

		local Y2 = Accumulator2 + 3 * (2 ^ 101) - 3 * (2 ^ 101)
		Accumulator2 -= Y2
		Accumulator3 += Y2

		local Y3 = Accumulator3 + 3 * (2 ^ 115) - 3 * (2 ^ 115)
		Accumulator3 -= Y3
		Accumulator4 += Y3

		local Y4 = Accumulator4 + 3 * (2 ^ 133) - 3 * (2 ^ 133)
		Accumulator4 -= Y4
		Accumulator5 += Y4

		local Y5 = Accumulator5 + 3 * (2 ^ 147) - 3 * (2 ^ 147)
		Accumulator5 -= Y5
		Accumulator6 += Y5

		local Y6 = Accumulator6 + 3 * (2 ^ 163) - 3 * (2 ^ 163)
		Accumulator6 -= Y6
		Accumulator7 += Y6

		local Y7 = Accumulator7 + 3 * (2 ^ 181) - 3 * (2 ^ 181)
		Accumulator7 -= Y7

		Accumulator0 += 5 / (2 ^ 130) * Y7
	end

	local Carry0 = Accumulator0 % (2 ^ 16)
	Accumulator1 = Accumulator0 - Carry0 + Accumulator1

	local Carry1 = Accumulator1 % (2 ^ 32)
	Accumulator2 = Accumulator1 - Carry1 + Accumulator2

	local Carry2 = Accumulator2 % (2 ^ 48)
	Accumulator3 = Accumulator2 - Carry2 + Accumulator3

	local Carry3 = Accumulator3 % (2 ^ 64)
	Accumulator4 = Accumulator3 - Carry3 + Accumulator4

	local Carry4 = Accumulator4 % (2 ^ 80)
	Accumulator5 = Accumulator4 - Carry4 + Accumulator5

	local Carry5 = Accumulator5 % (2 ^ 96)
	Accumulator6 = Accumulator5 - Carry5 + Accumulator6

	local Carry6 = Accumulator6 % (2 ^ 112)
	Accumulator7 = Accumulator6 - Carry6 + Accumulator7

	local Carry7 = Accumulator7 % (2 ^ 130)

	Accumulator0 = Carry0 + 5 / (2 ^ 130) * (Accumulator7 - Carry7)
	Carry0 = Accumulator0 % (2 ^ 16)
	Carry1 = Accumulator0 - Carry0 + Carry1

	if Carry7 == 0x3ffff * (2 ^ 112)
		and Carry6 == 0xffff * (2 ^ 96)
		and Carry5 == 0xffff * (2 ^ 80)
		and Carry4 == 0xffff * (2 ^ 64)
		and Carry3 == 0xffff * (2 ^ 48)
		and Carry2 == 0xffff * (2 ^ 32)
		and Carry1 == 0xffff * (2 ^ 16)
		and Carry0 >= 0xfffb
	then
		Carry7, Carry6, Carry5, Carry4 = 0, 0, 0, 0
		Carry3, Carry2, Carry1 = 0, 0, 0
		Carry0 -= 0xfffb
	end

	local S0 = buffer.readu32(Key, 16)
	local S1Val = buffer.readu32(Key, 20)
	local S2Val = buffer.readu32(Key, 24)
	local S3Val = buffer.readu32(Key, 28)

	local Unpacked0 = S0 + Carry0 + Carry1
	local Unpacked1 = Unpacked0 % (2 ^ 32)

	local Unpacked2 = Unpacked0 - Unpacked1 + S1Val * (2 ^ 32) + Carry2 + Carry3
	local Unpacked3 = Unpacked2 % (2 ^ 64)

	local Unpacked4 = Unpacked2 - Unpacked3 + S2Val * (2 ^ 64) + Carry4 + Carry5
	local Unpacked5 = Unpacked4 % (2 ^ 96)

	local Unpacked6 = Unpacked4 - Unpacked5 + S3Val * (2 ^ 96) + Carry6 + Carry7
	local Unpacked7 = Unpacked6 % (2 ^ 128)

	local Output = buffer.create(TAG_SIZE)
	buffer.writeu32(Output, 0, Unpacked1)
	buffer.writeu32(Output, 4, Unpacked3 / (2 ^ 32))
	buffer.writeu32(Output, 8, Unpacked5 / (2 ^ 64))
	buffer.writeu32(Output, 12, Unpacked7 / (2 ^ 96))

	return Output
end

local function Poly1305(Message: buffer, Key: buffer): buffer
	if Message == nil then
		error("Message cannot be nil", 2)
	end

	if typeof(Message) ~= "buffer" then
		error(`Message must be a buffer, got {typeof(Message)}`, 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= POLY1305_KEY_SIZE then
		error(`Key must be exactly {POLY1305_KEY_SIZE} bytes long, got {KeyLength} bytes`, 2)
	end

	return ProcessMessage(Message, Key)
end

return Poly1305]]></ProtectedString>
								<string name="ScriptGuid">{B7D95A19-33E5-49A6-BCDD-84648E7EFB2A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Poly1305</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX77A1EDBACEF64F31983CE6BB451C1BF5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: AES
	
	Sizes:
		Init Vector: 16 bytes
		Key Size: 16 / 24 / 32 bytes
	
	Example usage:
	local Key = CSPRNG.RandomBytes(32)
	local IV = CSPRNG.RandomBytes(12)

	local Message = "This is a secret message"
	local Plaintext = buffer.fromstring(Message)

	local AAD = buffer.fromstring("user:john,timestamp:456745683")
	local Ciphertext, Tag = AES.Encrypt(Plaintext, Key, IV, AAD)
--]=]

--!strict
--!optimize 2
--!native

type Processor = (PlaintextBlock: buffer, PlaintextOffset: number, OutputBuffer: buffer, OutputOffset: number) -> ()

local AES = {}

local SBOX_16BIT = buffer.create(131072) 
local SMIX_TABLE0 = buffer.create(65536)
local SMIX_TABLE1 = buffer.create(65536)

local ALL_TABLES = buffer.create(32 * 16 * 16)
local DOUBLES = buffer.create(128 * 16)

local INVS_XOR_TABLE = buffer.create(65536)
local INVMIX_TABLE0 = buffer.create(65536)
local INVMIX_TABLE1 = buffer.create(65536)

local KEY_CONFIGS = {
	[16] = {ExpandedLength = 176, MaterialLength = 128},
	[24] = {ExpandedLength = 208, MaterialLength = 160},
	[32] = {ExpandedLength = 240, MaterialLength = 192}
}

local SUBSTITUTION_BOX, INVERSE_SUBSTITUTION_BOX = buffer.create(256), buffer.create(256) do
	local GaloisMultiply3, GaloisMultiply9, GaloisMultiply11 = buffer.create(256), buffer.create(256), buffer.create(256)
	local function GaloisFieldMultiply(FirstValue: number, SecondValue: number): number
		local Product = 0
		for _ = 0, 7 do
			if SecondValue % 2 == 1 then
				Product = bit32.bxor(Product, FirstValue)
			end
			FirstValue = FirstValue >= 128 and bit32.bxor(FirstValue * 2 % 256, 27) or FirstValue * 2 % 256
			SecondValue = math.floor(SecondValue / 2)
		end

		return Product
	end

	local PolynomialP = 1
	local PolynomialQ = 1
	buffer.writeu8(SUBSTITUTION_BOX, 0, 99)

	for _ = 1, 255 do
		PolynomialP = bit32.bxor(PolynomialP, PolynomialP * 2, PolynomialP < 128 and 0 or 27) % 256
		PolynomialQ = bit32.bxor(PolynomialQ, PolynomialQ * 2)
		PolynomialQ = bit32.bxor(PolynomialQ, PolynomialQ * 4)
		PolynomialQ = bit32.bxor(PolynomialQ, PolynomialQ * 16) % 256
		if PolynomialQ >= 128 then
			PolynomialQ = bit32.bxor(PolynomialQ, 9)
		end

		local TempValue = bit32.bxor(
			PolynomialQ,
			PolynomialQ % 128 * 2 + PolynomialQ / 128,
			PolynomialQ % 64 * 4 + PolynomialQ / 64,
			PolynomialQ % 32 * 8 + PolynomialQ / 32,
			PolynomialQ % 16 * 16 + PolynomialQ / 16,
			99
		)
		buffer.writeu8(SUBSTITUTION_BOX, PolynomialP, TempValue)
		buffer.writeu8(INVERSE_SUBSTITUTION_BOX, TempValue, PolynomialP)
		buffer.writeu8(GaloisMultiply3, PolynomialP, GaloisFieldMultiply(3, PolynomialP))
		buffer.writeu8(GaloisMultiply9, PolynomialP, GaloisFieldMultiply(9, PolynomialP))
		buffer.writeu8(GaloisMultiply11, PolynomialP, GaloisFieldMultiply(11, PolynomialP))
	end

	local TableIndex = 0
	for OuterIndex = 0, 255 do
		local PolynomialPOuter = buffer.readu8(SUBSTITUTION_BOX, OuterIndex)
		local PolynomialPBytes = PolynomialPOuter * 256
		local Galois2 = GaloisFieldMultiply(2, PolynomialPOuter)
		local Galois13 = GaloisFieldMultiply(13, OuterIndex)
		local Galois14 = GaloisFieldMultiply(14, OuterIndex)

		for InnerIndex = 0, 255 do
			local PolynomialQInner = buffer.readu8(SUBSTITUTION_BOX, InnerIndex)

			buffer.writeu16(SBOX_16BIT, TableIndex * 2, PolynomialPBytes + PolynomialQInner)
			buffer.writeu8(INVS_XOR_TABLE, TableIndex, buffer.readu8(INVERSE_SUBSTITUTION_BOX, bit32.bxor(OuterIndex, InnerIndex)))
			buffer.writeu8(SMIX_TABLE0, TableIndex, bit32.bxor(Galois2, buffer.readu8(GaloisMultiply3, PolynomialQInner)))
			buffer.writeu8(SMIX_TABLE1, TableIndex, bit32.bxor(PolynomialPOuter, PolynomialQInner))
			buffer.writeu8(INVMIX_TABLE0, TableIndex, bit32.bxor(Galois14, buffer.readu8(GaloisMultiply11, InnerIndex)))
			buffer.writeu8(INVMIX_TABLE1, TableIndex, bit32.bxor(Galois13, buffer.readu8(GaloisMultiply9, InnerIndex)))
			TableIndex += 1
		end
	end
end

local function ExpandKeySchedule(Key: buffer, KeyLength: number, OutputBuffer: buffer): buffer
	buffer.copy(OutputBuffer, 0, Key, 0, KeyLength)

	local Word = bit32.rrotate(buffer.readu32(OutputBuffer, KeyLength - 4), 8)
	local RoundConstant = 0.5
	local SBox_16 = SBOX_16BIT

	if KeyLength == 32 then
		for KeyOffset = 32, 192, 32 do
			RoundConstant = RoundConstant * 2 % 229
			local SBoxLookup = buffer.readu16(SBox_16, Word // 65536 * 2) * 65536 + buffer.readu16(SBox_16, Word % 65536 * 2)
			Word = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 32), SBoxLookup, RoundConstant)
			buffer.writeu32(OutputBuffer, KeyOffset, Word)

			local W1 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 28), Word)
			buffer.writeu32(OutputBuffer, KeyOffset + 4, W1)
			local W2 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 24), W1)
			buffer.writeu32(OutputBuffer, KeyOffset + 8, W2)
			local W3 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 20), W2)
			buffer.writeu32(OutputBuffer, KeyOffset + 12, W3)

			SBoxLookup = buffer.readu16(SBox_16, W3 // 65536 * 2) * 65536 + buffer.readu16(SBox_16, W3 % 65536 * 2)
			Word = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 16), SBoxLookup)
			buffer.writeu32(OutputBuffer, KeyOffset + 16, Word)

			W1 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 12), Word)
			buffer.writeu32(OutputBuffer, KeyOffset + 20, W1)
			W2 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 8), W1)
			buffer.writeu32(OutputBuffer, KeyOffset + 24, W2)
			Word = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 4), W2)
			buffer.writeu32(OutputBuffer, KeyOffset + 28, Word)
			Word = bit32.rrotate(Word, 8)
		end

		local SBoxLookup = buffer.readu16(SBox_16, Word // 65536 * 2) * 65536 + buffer.readu16(SBox_16, Word % 65536 * 2)
		Word = bit32.bxor(buffer.readu32(OutputBuffer, 192), SBoxLookup, 64)
		buffer.writeu32(OutputBuffer, 224, Word)

		local W1 = bit32.bxor(buffer.readu32(OutputBuffer, 196), Word)
		buffer.writeu32(OutputBuffer, 228, W1)
		local W2 = bit32.bxor(buffer.readu32(OutputBuffer, 200), W1)
		buffer.writeu32(OutputBuffer, 232, W2)
		buffer.writeu32(OutputBuffer, 236, bit32.bxor(buffer.readu32(OutputBuffer, 204), W2))

	elseif KeyLength == 24 then
		for KeyOffset = 24, 168, 24 do
			RoundConstant = RoundConstant * 2 % 229
			local SBoxLookup = buffer.readu16(SBox_16, Word // 65536 * 2) * 65536 + buffer.readu16(SBox_16, Word % 65536 * 2)
			Word = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 24), SBoxLookup, RoundConstant)
			buffer.writeu32(OutputBuffer, KeyOffset, Word)

			local W1 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 20), Word)
			buffer.writeu32(OutputBuffer, KeyOffset + 4, W1)
			local W2 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 16), W1)
			buffer.writeu32(OutputBuffer, KeyOffset + 8, W2)
			local W3 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 12), W2)
			buffer.writeu32(OutputBuffer, KeyOffset + 12, W3)
			local W4 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 8), W3)
			buffer.writeu32(OutputBuffer, KeyOffset + 16, W4)
			Word = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 4), W4)
			buffer.writeu32(OutputBuffer, KeyOffset + 20, Word)
			Word = bit32.rrotate(Word, 8)
		end

		local SBoxLookup = buffer.readu16(SBox_16, Word // 65536 * 2) * 65536 + buffer.readu16(SBox_16, Word % 65536 * 2)
		Word = bit32.bxor(buffer.readu32(OutputBuffer, 168), SBoxLookup, 128)
		buffer.writeu32(OutputBuffer, 192, Word)

		local W1 = bit32.bxor(buffer.readu32(OutputBuffer, 172), Word)
		buffer.writeu32(OutputBuffer, 196, W1)
		local W2 = bit32.bxor(buffer.readu32(OutputBuffer, 176), W1)
		buffer.writeu32(OutputBuffer, 200, W2)
		buffer.writeu32(OutputBuffer, 204, bit32.bxor(buffer.readu32(OutputBuffer, 180), W2))
	else
		for KeyOffset = 16, 144, 16 do
			RoundConstant = RoundConstant * 2 % 229
			local SBoxLookup = buffer.readu16(SBox_16, Word // 65536 * 2) * 65536 + buffer.readu16(SBox_16, Word % 65536 * 2)
			Word = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 16), SBoxLookup, RoundConstant)
			buffer.writeu32(OutputBuffer, KeyOffset, Word)

			local W1 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 12), Word)
			buffer.writeu32(OutputBuffer, KeyOffset + 4, W1)
			local W2 = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 8), W1)
			buffer.writeu32(OutputBuffer, KeyOffset + 8, W2)
			Word = bit32.bxor(buffer.readu32(OutputBuffer, KeyOffset - 4), W2)
			buffer.writeu32(OutputBuffer, KeyOffset + 12, Word)
			Word = bit32.rrotate(Word, 8)
		end

		local SBoxLookup = buffer.readu16(SBox_16, Word // 65536 * 2) * 65536 + buffer.readu16(SBox_16, Word % 65536 * 2)
		Word = bit32.bxor(buffer.readu32(OutputBuffer, 144), SBoxLookup, 54)
		buffer.writeu32(OutputBuffer, 160, Word)

		local W1 = bit32.bxor(buffer.readu32(OutputBuffer, 148), Word)
		buffer.writeu32(OutputBuffer, 164, W1)
		local W2 = bit32.bxor(buffer.readu32(OutputBuffer, 152), W1)
		buffer.writeu32(OutputBuffer, 168, W2)
		buffer.writeu32(OutputBuffer, 172, bit32.bxor(buffer.readu32(OutputBuffer, 156), W2))
	end

	return OutputBuffer
end

local A0: number, A1: number, A2: number, A3: number, A4: number, A5: number, A6: number, A7: number, A8: number, A9: number, A10: number, A11: number, A12: number, A13: number, A14: number, A15: number
local function EncryptBlock(RoundKeys: buffer, MaterialLength: number, Plaintext: buffer, PlaintextOffset: number, Output: buffer, OutputOffset: number)
	A0 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset), buffer.readu8(RoundKeys, 0))
	A1 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 1), buffer.readu8(RoundKeys, 1))
	A2 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 2), buffer.readu8(RoundKeys, 2))
	A3 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 3), buffer.readu8(RoundKeys, 3))
	A4 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 4), buffer.readu8(RoundKeys, 4))
	A5 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 5), buffer.readu8(RoundKeys, 5))
	A6 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 6), buffer.readu8(RoundKeys, 6))
	A7 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 7), buffer.readu8(RoundKeys, 7))
	A8 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 8), buffer.readu8(RoundKeys, 8))
	A9 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 9), buffer.readu8(RoundKeys, 9))
	A10 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 10), buffer.readu8(RoundKeys, 10))
	A11 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 11), buffer.readu8(RoundKeys, 11))
	A12 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 12), buffer.readu8(RoundKeys, 12))
	A13 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 13), buffer.readu8(RoundKeys, 13))
	A14 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 14), buffer.readu8(RoundKeys, 14))
	A15 = bit32.bxor(buffer.readu8(Plaintext, PlaintextOffset + 15), buffer.readu8(RoundKeys, 15))

	local B0: number, B1: number, B2: number, B3: number, B4: number, B5: number, B6: number, B7: number, B8: number, B9: number, B10: number, B11: number, B12: number, B13: number, B14: number, B15: number
		= A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15

	local I0: number = B0 * 256 + B5; local I1: number = B5 * 256 + B10; local I2: number = B10 * 256 + B15; local I3: number = B15 * 256 + B0
	local I4: number = B4 * 256 + B9; local I5: number = B9 * 256 + B14; local I6: number = B14 * 256 + B3; local I7: number = B3 * 256 + B4
	local I8: number = B8 * 256 + B13; local I9: number = B13 * 256 + B2; local I10: number = B2 * 256 + B7; local I11: number = B7 * 256 + B8
	local I12: number = B12 * 256 + B1; local I13: number = B1 * 256 + B6; local I14: number = B6 * 256 + B11; local I15: number = B11 * 256 + B12

	local Tbl0, Tbl1 = SMIX_TABLE0, SMIX_TABLE1
	for RoundOffset = 16, MaterialLength, 16 do
		B0 = bit32.bxor(buffer.readu8(Tbl0, I0), buffer.readu8(Tbl1, I2), buffer.readu8(RoundKeys, RoundOffset))
		B1 = bit32.bxor(buffer.readu8(Tbl0, I1), buffer.readu8(Tbl1, I3), buffer.readu8(RoundKeys, RoundOffset + 1))
		B2 = bit32.bxor(buffer.readu8(Tbl0, I2), buffer.readu8(Tbl1, I0), buffer.readu8(RoundKeys, RoundOffset + 2))
		B3 = bit32.bxor(buffer.readu8(Tbl0, I3), buffer.readu8(Tbl1, I1), buffer.readu8(RoundKeys, RoundOffset + 3))
		B4 = bit32.bxor(buffer.readu8(Tbl0, I4), buffer.readu8(Tbl1, I6), buffer.readu8(RoundKeys, RoundOffset + 4))
		B5 = bit32.bxor(buffer.readu8(Tbl0, I5), buffer.readu8(Tbl1, I7), buffer.readu8(RoundKeys, RoundOffset + 5))
		B6 = bit32.bxor(buffer.readu8(Tbl0, I6), buffer.readu8(Tbl1, I4), buffer.readu8(RoundKeys, RoundOffset + 6))
		B7 = bit32.bxor(buffer.readu8(Tbl0, I7), buffer.readu8(Tbl1, I5), buffer.readu8(RoundKeys, RoundOffset + 7))
		B8 = bit32.bxor(buffer.readu8(Tbl0, I8), buffer.readu8(Tbl1, I10), buffer.readu8(RoundKeys, RoundOffset + 8))
		B9 = bit32.bxor(buffer.readu8(Tbl0, I9), buffer.readu8(Tbl1, I11), buffer.readu8(RoundKeys, RoundOffset + 9))
		B10 = bit32.bxor(buffer.readu8(Tbl0, I10), buffer.readu8(Tbl1, I8), buffer.readu8(RoundKeys, RoundOffset + 10))
		B11 = bit32.bxor(buffer.readu8(Tbl0, I11), buffer.readu8(Tbl1, I9), buffer.readu8(RoundKeys, RoundOffset + 11))
		B12 = bit32.bxor(buffer.readu8(Tbl0, I12), buffer.readu8(Tbl1, I14), buffer.readu8(RoundKeys, RoundOffset + 12))
		B13 = bit32.bxor(buffer.readu8(Tbl0, I13), buffer.readu8(Tbl1, I15), buffer.readu8(RoundKeys, RoundOffset + 13))
		B14 = bit32.bxor(buffer.readu8(Tbl0, I14), buffer.readu8(Tbl1, I12), buffer.readu8(RoundKeys, RoundOffset + 14))
		B15 = bit32.bxor(buffer.readu8(Tbl0, I15), buffer.readu8(Tbl1, I13), buffer.readu8(RoundKeys, RoundOffset + 15))

		I0, I1, I2, I3 = B0 * 256 + B5, B5 * 256 + B10, B10 * 256 + B15, B15 * 256 + B0
		I4, I5, I6, I7 = B4 * 256 + B9, B9 * 256 + B14, B14 * 256 + B3, B3 * 256 + B4
		I8, I9, I10, I11 = B8 * 256 + B13, B13 * 256 + B2, B2 * 256 + B7, B7 * 256 + B8
		I12, I13, I14, I15 = B12 * 256 + B1, B1 * 256 + B6, B6 * 256 + B11, B11 * 256 + B12
	end

	buffer.writeu32(Output, OutputOffset, bit32.bxor(
		buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I15), buffer.readu8(SMIX_TABLE1, I13), buffer.readu8(RoundKeys, MaterialLength + 31)) * 512 + 
			bit32.bxor(buffer.readu8(Tbl0, I10), buffer.readu8(SMIX_TABLE1, I8), buffer.readu8(RoundKeys, MaterialLength + 26)) * 2) * 65536 + 
			buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I5), buffer.readu8(SMIX_TABLE1, I7), buffer.readu8(RoundKeys, MaterialLength + 21)) * 512 + 
				bit32.bxor(buffer.readu8(Tbl0, I0), buffer.readu8(SMIX_TABLE1, I2), buffer.readu8(RoundKeys, MaterialLength + 16)) * 2),
		buffer.readu32(RoundKeys, MaterialLength + 32)
		))

	buffer.writeu32(Output, OutputOffset + 4, bit32.bxor(
		buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I3), buffer.readu8(SMIX_TABLE1, I1), buffer.readu8(RoundKeys, MaterialLength + 19)) * 512 + 
			bit32.bxor(buffer.readu8(Tbl0, I14), buffer.readu8(SMIX_TABLE1, I12), buffer.readu8(RoundKeys, MaterialLength + 30)) * 2) * 65536 + 
			buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I9), buffer.readu8(SMIX_TABLE1, I11), buffer.readu8(RoundKeys, MaterialLength + 25)) * 512 + 
				bit32.bxor(buffer.readu8(Tbl0, I4), buffer.readu8(SMIX_TABLE1, I6), buffer.readu8(RoundKeys, MaterialLength + 20)) * 2),
		buffer.readu32(RoundKeys, MaterialLength + 36)
		))

	buffer.writeu32(Output, OutputOffset + 8, bit32.bxor(
		buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I7), buffer.readu8(SMIX_TABLE1, I5), buffer.readu8(RoundKeys, MaterialLength + 23)) * 512 + 
			bit32.bxor(buffer.readu8(Tbl0, I2), buffer.readu8(SMIX_TABLE1, I0), buffer.readu8(RoundKeys, MaterialLength + 18)) * 2) * 65536 + 
			buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I13), buffer.readu8(SMIX_TABLE1, I15), buffer.readu8(RoundKeys, MaterialLength + 29)) * 512 + 
				bit32.bxor(buffer.readu8(Tbl0, I8), buffer.readu8(SMIX_TABLE1, I10), buffer.readu8(RoundKeys, MaterialLength + 24)) * 2),
		buffer.readu32(RoundKeys, MaterialLength + 40)
		))

	buffer.writeu32(Output, OutputOffset + 12, bit32.bxor(
		buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I11), buffer.readu8(SMIX_TABLE1, I9), buffer.readu8(RoundKeys, MaterialLength + 27)) * 512 + 
			bit32.bxor(buffer.readu8(Tbl0, I6), buffer.readu8(SMIX_TABLE1, I4), buffer.readu8(RoundKeys, MaterialLength + 22)) * 2) * 65536 + 
			buffer.readu16(SBOX_16BIT, bit32.bxor(buffer.readu8(Tbl0, I1), buffer.readu8(SMIX_TABLE1, I3), buffer.readu8(RoundKeys, MaterialLength + 17)) * 512 + 
				bit32.bxor(buffer.readu8(Tbl0, I12), buffer.readu8(SMIX_TABLE1, I14), buffer.readu8(RoundKeys, MaterialLength + 28)) * 2),
		buffer.readu32(RoundKeys, MaterialLength + 44)
		))
end

local function ConstantTimeCompare(Buffer1: buffer, Buffer2: buffer): boolean
	local Length1 = buffer.len(Buffer1)
	local Length2 = buffer.len(Buffer2)
	if Length1 ~= Length2 then
		return false
	end

	local Difference = 0
	for Index = 0, Length1 - 1 do
		Difference = bit32.bor(Difference, bit32.bxor(
			buffer.readu8(Buffer1, Index),
			buffer.readu8(Buffer2, Index)
			))
	end

	return Difference == 0
end

local function BuildShoupTables(H: buffer): buffer
	local Doubles = DOUBLES
	local AllTables = ALL_TABLES

	buffer.copy(Doubles, 0, H, 0, 16)

	for I = 1, 127 do
		local PrevOffset = (I - 1) * 16
		local CurrOffset = I * 16

		local LSB = bit32.band(buffer.readu8(Doubles, PrevOffset + 15), 1)

		local Carry = 0
		for BytePos = 0, 15 do
			local B = buffer.readu8(Doubles, PrevOffset + BytePos)
			local NewCarry = bit32.lshift(bit32.band(B, 1), 7)
			buffer.writeu8(Doubles, CurrOffset + BytePos, bit32.bor(bit32.rshift(B, 1), Carry))
			Carry = NewCarry
		end

		if LSB == 1 then
			buffer.writeu8(Doubles, CurrOffset, bit32.bxor(buffer.readu8(Doubles, CurrOffset), 0xE1))
		end
	end

	for NibbleIdx = 0, 31 do
		local TableOffset = NibbleIdx * 256

		buffer.writeu32(AllTables, TableOffset, 0)
		buffer.writeu32(AllTables, TableOffset + 4, 0)
		buffer.writeu32(AllTables, TableOffset + 8, 0)
		buffer.writeu32(AllTables, TableOffset + 12, 0)

		for Entry = 1, 15 do
			local EntryOffset = TableOffset + Entry * 16
			local Z0, Z1, Z2, Z3 = 0, 0, 0, 0

			for Bit = 0, 3 do
				if bit32.band(Entry, bit32.lshift(1, 3 - Bit)) ~= 0 then
					local DoubleOffset = (NibbleIdx * 4 + Bit) * 16

					Z0 = bit32.bxor(Z0, buffer.readu32(Doubles, DoubleOffset))
					Z1 = bit32.bxor(Z1, buffer.readu32(Doubles, DoubleOffset + 4))
					Z2 = bit32.bxor(Z2, buffer.readu32(Doubles, DoubleOffset + 8))
					Z3 = bit32.bxor(Z3, buffer.readu32(Doubles, DoubleOffset + 12))
				end
			end

			buffer.writeu32(AllTables, EntryOffset, Z0)
			buffer.writeu32(AllTables, EntryOffset + 4, Z1)
			buffer.writeu32(AllTables, EntryOffset + 8, Z2)
			buffer.writeu32(AllTables, EntryOffset + 12, Z3)
		end
	end

	return AllTables
end

local function GfMult(Y: buffer, Tables: buffer, Z: buffer)
	local Z0, Z1, Z2, Z3 = 0, 0, 0, 0

	for ByteIdx = 0, 15 do
		local ByteVal = buffer.readu8(Y, ByteIdx)
		local BaseOffset = ByteIdx * 512

		local HighOffset = BaseOffset + bit32.rshift(ByteVal, 4) * 16
		Z0 = bit32.bxor(Z0, buffer.readu32(Tables, HighOffset))
		Z1 = bit32.bxor(Z1, buffer.readu32(Tables, HighOffset + 4))
		Z2 = bit32.bxor(Z2, buffer.readu32(Tables, HighOffset + 8))
		Z3 = bit32.bxor(Z3, buffer.readu32(Tables, HighOffset + 12))

		local LowOffset = BaseOffset + 256 + bit32.band(ByteVal, 0x0F) * 16
		Z0 = bit32.bxor(Z0, buffer.readu32(Tables, LowOffset))
		Z1 = bit32.bxor(Z1, buffer.readu32(Tables, LowOffset + 4))
		Z2 = bit32.bxor(Z2, buffer.readu32(Tables, LowOffset + 8))
		Z3 = bit32.bxor(Z3, buffer.readu32(Tables, LowOffset + 12))
	end

	buffer.writeu32(Z, 0, Z0)
	buffer.writeu32(Z, 4, Z1)
	buffer.writeu32(Z, 8, Z2)
	buffer.writeu32(Z, 12, Z3)
end

local function Ghash(Tables: buffer, X: buffer, XLen: number, Y: buffer)
	local M = math.floor(XLen / 16)
	local XPos = 0
	local Tmp = buffer.create(16)
	local GfMult = GfMult

	for _ = 1, M do
		buffer.writeu32(Y, 0, bit32.bxor(buffer.readu32(Y, 0), buffer.readu32(X, XPos)))
		buffer.writeu32(Y, 4, bit32.bxor(buffer.readu32(Y, 4), buffer.readu32(X, XPos + 4)))
		buffer.writeu32(Y, 8, bit32.bxor(buffer.readu32(Y, 8), buffer.readu32(X, XPos + 8)))
		buffer.writeu32(Y, 12, bit32.bxor(buffer.readu32(Y, 12), buffer.readu32(X, XPos + 12)))
		XPos += 16

		GfMult(Y, Tables, Tmp)

		buffer.writeu32(Y, 0, buffer.readu32(Tmp, 0))
		buffer.writeu32(Y, 4, buffer.readu32(Tmp, 4))
		buffer.writeu32(Y, 8, buffer.readu32(Tmp, 8))
		buffer.writeu32(Y, 12, buffer.readu32(Tmp, 12))
	end

	if XPos < XLen then
		local Last = XLen - XPos
		buffer.writeu32(Tmp, 0, 0)
		buffer.writeu32(Tmp, 4, 0)
		buffer.writeu32(Tmp, 8, 0)
		buffer.writeu32(Tmp, 12, 0)
		buffer.copy(Tmp, 0, X, XPos, Last)

		buffer.writeu32(Y, 0, bit32.bxor(buffer.readu32(Y, 0), buffer.readu32(Tmp, 0)))
		buffer.writeu32(Y, 4, bit32.bxor(buffer.readu32(Y, 4), buffer.readu32(Tmp, 4)))
		buffer.writeu32(Y, 8, bit32.bxor(buffer.readu32(Y, 8), buffer.readu32(Tmp, 8)))
		buffer.writeu32(Y, 12, bit32.bxor(buffer.readu32(Y, 12), buffer.readu32(Tmp, 12)))

		GfMult(Y, Tables, Tmp)

		buffer.writeu32(Y, 0, buffer.readu32(Tmp, 0))
		buffer.writeu32(Y, 4, buffer.readu32(Tmp, 4))
		buffer.writeu32(Y, 8, buffer.readu32(Tmp, 8))
		buffer.writeu32(Y, 12, buffer.readu32(Tmp, 12))
	end
end

local function Gctr(RoundKeys: buffer, KeyMaterialLength: number, ICB: buffer, X: buffer, XLen: number, Y: buffer)
	if XLen == 0 then
		return
	end

	local N = math.floor(XLen / 16)
	local CB = buffer.create(16)
	local Tmp = buffer.create(16)
	local XPos = 0
	local YPos = 0

	buffer.writeu32(CB, 0, buffer.readu32(ICB, 0))
	buffer.writeu32(CB, 4, buffer.readu32(ICB, 4))
	buffer.writeu32(CB, 8, buffer.readu32(ICB, 8))
	buffer.writeu32(CB, 12, buffer.readu32(ICB, 12))

	local Encrypt = EncryptBlock

	for I = 0, N - 1 do
		Encrypt(RoundKeys, KeyMaterialLength, CB, 0, Tmp, 0)

		buffer.writeu32(Y, YPos + 0, bit32.bxor(buffer.readu32(X, XPos + 0), buffer.readu32(Tmp, 0)))
		buffer.writeu32(Y, YPos + 4, bit32.bxor(buffer.readu32(X, XPos + 4), buffer.readu32(Tmp, 4)))
		buffer.writeu32(Y, YPos + 8, bit32.bxor(buffer.readu32(X, XPos + 8), buffer.readu32(Tmp, 8)))
		buffer.writeu32(Y, YPos + 12, bit32.bxor(buffer.readu32(X, XPos + 12), buffer.readu32(Tmp, 12)))

		XPos += 16
		YPos += 16

		local Val = bit32.byteswap(buffer.readu32(CB, 12))
		Val = (Val + 1) % 0x100000000
		buffer.writeu32(CB, 12, bit32.byteswap(Val))
	end

	local Last = XLen - XPos
	if Last > 0 then
		EncryptBlock(RoundKeys, KeyMaterialLength, CB, 0, Tmp, 0)
		for I = 0, Last - 1 do
			local XByte = buffer.readu8(X, XPos + I)
			local TmpByte = buffer.readu8(Tmp, I)
			buffer.writeu8(Y, YPos + I, bit32.bxor(XByte, TmpByte))
		end
	end
end

local function PrepareJ0(H: buffer, IV: buffer, IVLen: number, J0: buffer): buffer
	local Tables = BuildShoupTables(H)

	if IVLen == 12 then
		buffer.writeu32(J0, 0, buffer.readu32(IV, 0))
		buffer.writeu32(J0, 4, buffer.readu32(IV, 4))
		buffer.writeu32(J0, 8, buffer.readu32(IV, 8))
		buffer.writeu32(J0, 12, 0x01000000)
	else
		buffer.writeu32(J0, 0, 0)
		buffer.writeu32(J0, 4, 0)
		buffer.writeu32(J0, 8, 0)
		buffer.writeu32(J0, 12, 0)

		Ghash(Tables, IV, IVLen, J0)

		local LenBuf = buffer.create(16)
		local IVLenBits = IVLen * 8

		buffer.writeu32(LenBuf, 0, 0)
		buffer.writeu32(LenBuf, 4, 0)
		buffer.writeu32(LenBuf, 8, 0)
		buffer.writeu32(LenBuf, 12, bit32.byteswap(IVLenBits))

		Ghash(Tables, LenBuf, 16, J0)
	end

	return Tables
end

local function GcmGctr(RoundKeys: buffer, KeyMaterialLength: number, J0: buffer, Input: buffer, Len: number, Output: buffer)
	if Len == 0 then
		return
	end

	local J0Inc = buffer.create(16)

	buffer.writeu32(J0Inc, 0, buffer.readu32(J0, 0))
	buffer.writeu32(J0Inc, 4, buffer.readu32(J0, 4))
	buffer.writeu32(J0Inc, 8, buffer.readu32(J0, 8))
	buffer.writeu32(J0Inc, 12, buffer.readu32(J0, 12))

	local Val = bit32.byteswap(buffer.readu32(J0Inc, 12))
	Val = (Val + 1) % 0x100000000
	buffer.writeu32(J0Inc, 12, bit32.byteswap(Val))

	Gctr(RoundKeys, KeyMaterialLength, J0Inc, Input, Len, Output)
end

local function GcmHash(Tables: buffer, AAD: buffer, AADLen: number, Crypt: buffer, CryptLen: number, S: buffer)
	local Tmp = buffer.create(16)
	local GfMult = GfMult

	buffer.writeu32(S, 0, 0)
	buffer.writeu32(S, 4, 0)
	buffer.writeu32(S, 8, 0)
	buffer.writeu32(S, 12, 0)

	local M = math.floor(AADLen / 16)
	local XPos = 0

	for _ = 1, M do
		buffer.writeu32(S, 0, bit32.bxor(buffer.readu32(S, 0), buffer.readu32(AAD, XPos)))
		buffer.writeu32(S, 4, bit32.bxor(buffer.readu32(S, 4), buffer.readu32(AAD, XPos + 4)))
		buffer.writeu32(S, 8, bit32.bxor(buffer.readu32(S, 8), buffer.readu32(AAD, XPos + 8)))
		buffer.writeu32(S, 12, bit32.bxor(buffer.readu32(S, 12), buffer.readu32(AAD, XPos + 12)))
		XPos += 16

		GfMult(S, Tables, Tmp)

		buffer.writeu32(S, 0, buffer.readu32(Tmp, 0))
		buffer.writeu32(S, 4, buffer.readu32(Tmp, 4))
		buffer.writeu32(S, 8, buffer.readu32(Tmp, 8))
		buffer.writeu32(S, 12, buffer.readu32(Tmp, 12))
	end

	if XPos < AADLen then
		local Last = AADLen - XPos
		buffer.writeu32(Tmp, 0, 0)
		buffer.writeu32(Tmp, 4, 0)
		buffer.writeu32(Tmp, 8, 0)
		buffer.writeu32(Tmp, 12, 0)
		buffer.copy(Tmp, 0, AAD, XPos, Last)

		buffer.writeu32(S, 0, bit32.bxor(buffer.readu32(S, 0), buffer.readu32(Tmp, 0)))
		buffer.writeu32(S, 4, bit32.bxor(buffer.readu32(S, 4), buffer.readu32(Tmp, 4)))
		buffer.writeu32(S, 8, bit32.bxor(buffer.readu32(S, 8), buffer.readu32(Tmp, 8)))
		buffer.writeu32(S, 12, bit32.bxor(buffer.readu32(S, 12), buffer.readu32(Tmp, 12)))

		GfMult(S, Tables, Tmp)

		buffer.writeu32(S, 0, buffer.readu32(Tmp, 0))
		buffer.writeu32(S, 4, buffer.readu32(Tmp, 4))
		buffer.writeu32(S, 8, buffer.readu32(Tmp, 8))
		buffer.writeu32(S, 12, buffer.readu32(Tmp, 12))
	end

	M = math.floor(CryptLen / 16)
	XPos = 0

	for _ = 1, M do
		buffer.writeu32(S, 0, bit32.bxor(buffer.readu32(S, 0), buffer.readu32(Crypt, XPos)))
		buffer.writeu32(S, 4, bit32.bxor(buffer.readu32(S, 4), buffer.readu32(Crypt, XPos + 4)))
		buffer.writeu32(S, 8, bit32.bxor(buffer.readu32(S, 8), buffer.readu32(Crypt, XPos + 8)))
		buffer.writeu32(S, 12, bit32.bxor(buffer.readu32(S, 12), buffer.readu32(Crypt, XPos + 12)))
		XPos += 16

		GfMult(S, Tables, Tmp)

		buffer.writeu32(S, 0, buffer.readu32(Tmp, 0))
		buffer.writeu32(S, 4, buffer.readu32(Tmp, 4))
		buffer.writeu32(S, 8, buffer.readu32(Tmp, 8))
		buffer.writeu32(S, 12, buffer.readu32(Tmp, 12))
	end

	if XPos < CryptLen then
		local Last = CryptLen - XPos
		buffer.writeu32(Tmp, 0, 0)
		buffer.writeu32(Tmp, 4, 0)
		buffer.writeu32(Tmp, 8, 0)
		buffer.writeu32(Tmp, 12, 0)
		buffer.copy(Tmp, 0, Crypt, XPos, Last)

		buffer.writeu32(S, 0, bit32.bxor(buffer.readu32(S, 0), buffer.readu32(Tmp, 0)))
		buffer.writeu32(S, 4, bit32.bxor(buffer.readu32(S, 4), buffer.readu32(Tmp, 4)))
		buffer.writeu32(S, 8, bit32.bxor(buffer.readu32(S, 8), buffer.readu32(Tmp, 8)))
		buffer.writeu32(S, 12, bit32.bxor(buffer.readu32(S, 12), buffer.readu32(Tmp, 12)))

		GfMult(S, Tables, Tmp)

		buffer.writeu32(S, 0, buffer.readu32(Tmp, 0))
		buffer.writeu32(S, 4, buffer.readu32(Tmp, 4))
		buffer.writeu32(S, 8, buffer.readu32(Tmp, 8))
		buffer.writeu32(S, 12, buffer.readu32(Tmp, 12))
	end

	local AADLenBits = AADLen * 8
	local CryptLenBits = CryptLen * 8

	buffer.writeu32(S, 4, bit32.bxor(buffer.readu32(S, 4), bit32.byteswap(AADLenBits)))
	buffer.writeu32(S, 12, bit32.bxor(buffer.readu32(S, 12), bit32.byteswap(CryptLenBits)))

	GfMult(S, Tables, Tmp)

	buffer.writeu32(S, 0, buffer.readu32(Tmp, 0))
	buffer.writeu32(S, 4, buffer.readu32(Tmp, 4))
	buffer.writeu32(S, 8, buffer.readu32(Tmp, 8))
	buffer.writeu32(S, 12, buffer.readu32(Tmp, 12))
end

function AES.Encrypt(Plaintext: buffer, Key: buffer, IV: buffer, AAD: buffer?): (buffer, buffer)
	if not Key or typeof(Key) ~= "buffer" then
		error("Key must be a buffer", 2)
	end

	if not IV or typeof(IV) ~= "buffer" then
		error("IV must be a buffer", 2)
	end

	if not Plaintext or typeof(Plaintext) ~= "buffer" then
		error("Plaintext must be a buffer", 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= 16 and KeyLength ~= 24 and KeyLength ~= 32 then
		error("Key must be 16, 24, or 32 bytes", 2)
	end

	local KeyConfig = KEY_CONFIGS[KeyLength]
	local RoundKeys = ExpandKeySchedule(Key, KeyLength, buffer.create(KeyConfig.ExpandedLength))
	local KeyMaterialLength = KeyConfig.MaterialLength

	local IVLen = buffer.len(IV)
	local AADLen = buffer.len(AAD or buffer.create(0))
	local PlainLen = buffer.len(Plaintext)
	local AuthData = AAD or buffer.create(0)

	local OutputBuffer = buffer.create(PlainLen)
	local OutputTag = buffer.create(16)

	local H = buffer.create(16)
	local J0 = buffer.create(16)
	local S = buffer.create(16)

	EncryptBlock(RoundKeys, KeyMaterialLength, H, 0, H, 0)
	local Tables = PrepareJ0(H, IV, IVLen, J0)
	GcmGctr(RoundKeys, KeyMaterialLength, J0, Plaintext, PlainLen, OutputBuffer)
	GcmHash(Tables, AuthData, AADLen, OutputBuffer, PlainLen, S)
	Gctr(RoundKeys, KeyMaterialLength, J0, S, 16, OutputTag)

	return OutputBuffer, OutputTag
end

function AES.Decrypt(Ciphertext: buffer, Key: buffer, IV: buffer, Tag: buffer, AAD: buffer?): (boolean, buffer?)
	if not Key or typeof(Key) ~= "buffer" then
		error("Key must be a buffer", 2)
	end

	if not IV or typeof(IV) ~= "buffer" then
		error("IV must be a buffer", 2)
	end

	if not Ciphertext or typeof(Ciphertext) ~= "buffer" then
		error("Ciphertext must be a buffer", 2)
	end

	if not Tag or typeof(Tag) ~= "buffer" then
		error("Tag must be a buffer", 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= 16 and KeyLength ~= 24 and KeyLength ~= 32 then
		error("Key must be 16, 24, or 32 bytes", 2)
	end

	local KeyConfig = KEY_CONFIGS[KeyLength]
	local RoundKeys = ExpandKeySchedule(Key, KeyLength, buffer.create(KeyConfig.ExpandedLength))
	local KeyMaterialLength = KeyConfig.MaterialLength

	local IVLen = buffer.len(IV)
	local AADLen = buffer.len(AAD or buffer.create(0))
	local CryptLen = buffer.len(Ciphertext)
	local AuthData = AAD or buffer.create(0)

	local OutputBuffer = buffer.create(CryptLen)

	local H = buffer.create(16)
	local J0 = buffer.create(16)
	local S = buffer.create(16)
	local ComputedTag = buffer.create(16)

	EncryptBlock(RoundKeys, KeyMaterialLength, H, 0, H, 0)
	local Tables = PrepareJ0(H, IV, IVLen, J0)
	GcmGctr(RoundKeys, KeyMaterialLength, J0, Ciphertext, CryptLen, OutputBuffer)
	GcmHash(Tables, AuthData, AADLen, Ciphertext, CryptLen, S)
	Gctr(RoundKeys, KeyMaterialLength, J0, S, 16, ComputedTag)

	if not ConstantTimeCompare(Tag, ComputedTag) then
		return false, nil
	end

	return true, OutputBuffer
end

return AES]]></ProtectedString>
							<string name="ScriptGuid">{1142FDC0-A4C4-4E48-91A1-14629F65DB27}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">AES</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9BC8ED51724346548E52BFA7963D4A6A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Simon Cipher 64-bit

	 WARNING: Simon is not very secure!
	For security, use AES or CHACHA20. 

	Sizes:
		Key: 16 bytes

	Return type: buffer
	Example Usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring("MySecretKey12345")
		
		local Encrypted = Encrypt(Message, Key)
		local Decrypted = Decrypt(Encrypted, Key)
--]=]

--!strict
--!optimize 2
--!native

local ROUNDS: number = 44
local KEY_WORDS: number = 4
local BLOCK_SIZE: number = 8

local Z_SEQUENCE: {number} = {
	1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0,
	1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,
	0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
	1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1
}

local Simon = {}

local function GenerateKeySchedule(KeyBuffer: buffer): buffer
	local Key = buffer.create(176)

	buffer.writeu32(Key, 0, buffer.readu32(KeyBuffer, 0))
	buffer.writeu32(Key, 4, buffer.readu32(KeyBuffer, 4))
	buffer.writeu32(Key, 8, buffer.readu32(KeyBuffer, 8))
	buffer.writeu32(Key, 12, buffer.readu32(KeyBuffer, 12))

	for Index = KEY_WORDS, ROUNDS - 1 do
		local PrevKey = buffer.readu32(Key, (Index - 1) * 4)
		local Temp = bit32.bxor(bit32.rrotate(PrevKey, 3), buffer.readu32(Key, (Index - 3) * 4))
		local TempRotated = bit32.rrotate(Temp, 1)

		local C = Z_SEQUENCE[((Index - KEY_WORDS) % 62) + 1]
		buffer.writeu32(Key, Index * 4, bit32.bxor(bit32.bxor(buffer.readu32(Key, (Index - KEY_WORDS) * 4), bit32.bxor(Temp, TempRotated)), bit32.bxor(3, C)))
	end

	return Key
end

local function EncryptBlocks(CipherBuffer: buffer, PlaintextBuffer: buffer, RoundKeys: buffer, Length: number): ()
	for Offset = 0, Length - 1, BLOCK_SIZE do
		local X = buffer.readu32(PlaintextBuffer, Offset)
		local Y = buffer.readu32(PlaintextBuffer, Offset + 4)

		for Round = 0, (ROUNDS - 1) * 4, 16 do
			X, Y = bit32.bxor(Y, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(X, 1), bit32.lrotate(X, 8)), bit32.lrotate(X, 2)), buffer.readu32(RoundKeys, Round))), X
			X, Y = bit32.bxor(Y, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(X, 1), bit32.lrotate(X, 8)), bit32.lrotate(X, 2)), buffer.readu32(RoundKeys, Round + 4))), X
			X, Y = bit32.bxor(Y, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(X, 1), bit32.lrotate(X, 8)), bit32.lrotate(X, 2)), buffer.readu32(RoundKeys, Round + 8))), X
			X, Y = bit32.bxor(Y, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(X, 1), bit32.lrotate(X, 8)), bit32.lrotate(X, 2)), buffer.readu32(RoundKeys, Round + 12))), X
		end

		buffer.writeu32(CipherBuffer, Offset, X)
		buffer.writeu32(CipherBuffer, Offset + 4, Y)
	end
end

local function DecryptBlocks(PlaintextBuffer: buffer, CipherBuffer: buffer, RoundKeys: buffer, Length: number): ()
	for Offset = 0, Length - 1, BLOCK_SIZE do
		local X = buffer.readu32(CipherBuffer, Offset)
		local Y = buffer.readu32(CipherBuffer, Offset + 4)

		for Round = (ROUNDS - 1) * 4, 0, -16 do
			Y, X = bit32.bxor(X, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(Y, 1), bit32.lrotate(Y, 8)), bit32.lrotate(Y, 2)), buffer.readu32(RoundKeys, Round))), Y
			Y, X = bit32.bxor(X, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(Y, 1), bit32.lrotate(Y, 8)), bit32.lrotate(Y, 2)), buffer.readu32(RoundKeys, Round - 4))), Y
			Y, X = bit32.bxor(X, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(Y, 1), bit32.lrotate(Y, 8)), bit32.lrotate(Y, 2)), buffer.readu32(RoundKeys, Round - 8))), Y
			Y, X = bit32.bxor(X, bit32.bxor(bit32.bxor(bit32.band(bit32.lrotate(Y, 1), bit32.lrotate(Y, 8)), bit32.lrotate(Y, 2)), buffer.readu32(RoundKeys, Round - 12))), Y
		end

		buffer.writeu32(PlaintextBuffer, Offset, X)
		buffer.writeu32(PlaintextBuffer, Offset + 4, Y)
	end
end

local function PadBuffer(InputBuffer: buffer): buffer
	local Length = buffer.len(InputBuffer)
	local Amount = BLOCK_SIZE - (Length % BLOCK_SIZE)
	local PaddedBuffer = buffer.create(Length + Amount)

	buffer.copy(PaddedBuffer, 0, InputBuffer, 0, Length)

	if Amount == 1 then
		buffer.writeu8(PaddedBuffer, Length, Amount)
	elseif Amount == 2 then
		buffer.writeu16(PaddedBuffer, Length, Amount * 0x0101)
	elseif Amount == 4 then
		buffer.writeu32(PaddedBuffer, Length, Amount * 0x01010101)
	else
		for Index = Length, Length + Amount - 1 do
			buffer.writeu8(PaddedBuffer, Index, Amount)
		end
	end

	return PaddedBuffer
end

local function UnpadBuffer(InputBuffer: buffer): buffer
	local Length = buffer.len(InputBuffer)
	if Length == 0 then
		return InputBuffer
	end

	local Amount = buffer.readu8(InputBuffer, Length - 1)
	local UnpaddedBuffer = buffer.create(Length - Amount)

	buffer.copy(UnpaddedBuffer, 0, InputBuffer, 0, Length - Amount)

	return UnpaddedBuffer
end

local function PrepareKey(KeyBuffer: buffer): buffer
	local KeyLength = buffer.len(KeyBuffer)
	local PreparedKey = buffer.create(16)

	if KeyLength >= 16 then
		buffer.writeu32(PreparedKey, 0, buffer.readu32(KeyBuffer, 0))
		buffer.writeu32(PreparedKey, 4, buffer.readu32(KeyBuffer, 4))
		buffer.writeu32(PreparedKey, 8, buffer.readu32(KeyBuffer, 8))
		buffer.writeu32(PreparedKey, 12, buffer.readu32(KeyBuffer, 12))
	else
		buffer.copy(PreparedKey, 0, KeyBuffer, 0, KeyLength)

		for ZeroStart = KeyLength, 15, 4 do
			if ZeroStart + 3 < 16 then
				buffer.writeu32(PreparedKey, ZeroStart, 0)
			else
				for ByteIndex = ZeroStart, 15 do
					buffer.writeu8(PreparedKey, ByteIndex, 0)
				end
				break
			end
		end
	end

	return PreparedKey
end

function Simon.Encrypt(PlaintextBuffer: buffer, KeyBuffer: buffer): buffer
	local PaddedPlaintext = PadBuffer(PlaintextBuffer)
	local PreparedKey = PrepareKey(KeyBuffer)
	local RoundKeys = GenerateKeySchedule(PreparedKey)

	local Length = buffer.len(PaddedPlaintext)
	local CipherBuffer = buffer.create(Length)

	EncryptBlocks(CipherBuffer, PaddedPlaintext, RoundKeys, Length)
	return CipherBuffer
end

function Simon.Decrypt(CipherBuffer: buffer, KeyBuffer: buffer): buffer
	local PreparedKey = PrepareKey(KeyBuffer)
	local RoundKeys = GenerateKeySchedule(PreparedKey)

	local Length = buffer.len(CipherBuffer)
	local PlaintextBuffer = buffer.create(Length)

	DecryptBlocks(PlaintextBuffer, CipherBuffer, RoundKeys, Length)
	return UnpadBuffer(PlaintextBuffer)
end

return Simon]]></ProtectedString>
							<string name="ScriptGuid">{7DBC4DB7-F3F3-4360-88A5-DC29D978D490}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Simon</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCC00B90D29024D31BE30ED28017A1746">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Speck

	 WARNING: Speck is not very secure!
	For security, use AES or CHACHA20. 

	Sizes:
		Key: 8 bytes

	Return type: buffer
	Example Usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring("Key") 

		local Encrypted = Encrypt(Message, Key)
		local Decrypted = Decrypt(Encrypted, Key)
--]=]

--!strict
--!optimize 2
--!native

local Speck = {}

local function EncryptBlocks(CipherBuffer: buffer, PlaintextBuffer: buffer, KeyBuffer: buffer, Length: number): ()
	for Offset = 0, Length - 1, 8 do
		local Y = buffer.readu32(PlaintextBuffer, Offset)
		local X = buffer.readu32(PlaintextBuffer, Offset + 4)

		local B = buffer.readu32(KeyBuffer, 0)
		local A = buffer.readu32(KeyBuffer, 4)

		X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
		Y = bit32.bxor(bit32.lrotate(Y, 3), X)

		for RoundIndex = 0, 27, 4 do
			A = bit32.bxor(bit32.rrotate(A, 8) + B, RoundIndex)
			B = bit32.bxor(bit32.lrotate(B, 3), A)
			X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
			Y = bit32.bxor(bit32.lrotate(Y, 3), X)

			A = bit32.bxor(bit32.rrotate(A, 8) + B, RoundIndex + 1)
			B = bit32.bxor(bit32.lrotate(B, 3), A)
			X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
			Y = bit32.bxor(bit32.lrotate(Y, 3), X)

			A = bit32.bxor(bit32.rrotate(A, 8) + B, RoundIndex + 2)
			B = bit32.bxor(bit32.lrotate(B, 3), A)
			X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
			Y = bit32.bxor(bit32.lrotate(Y, 3), X)

			A = bit32.bxor(bit32.rrotate(A, 8) + B, RoundIndex + 3)
			B = bit32.bxor(bit32.lrotate(B, 3), A)
			X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
			Y = bit32.bxor(bit32.lrotate(Y, 3), X)
		end

		A = bit32.bxor(bit32.rrotate(A, 8) + B, 28)
		B = bit32.bxor(bit32.lrotate(B, 3), A)
		X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
		Y = bit32.bxor(bit32.lrotate(Y, 3), X)

		A = bit32.bxor(bit32.rrotate(A, 8) + B, 29)
		B = bit32.bxor(bit32.lrotate(B, 3), A)
		X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
		Y = bit32.bxor(bit32.lrotate(Y, 3), X)

		A = bit32.bxor(bit32.rrotate(A, 8) + B, 30)
		B = bit32.bxor(bit32.lrotate(B, 3), A)
		X = bit32.bxor(bit32.rrotate(X, 8) + Y, B)
		Y = bit32.bxor(bit32.lrotate(Y, 3), X)

		buffer.writeu32(CipherBuffer, Offset, Y)
		buffer.writeu32(CipherBuffer, Offset + 4, X)
	end
end

local function DecryptBlocks(PlaintextBuffer: buffer, CipherBuffer: buffer, RoundKeys: buffer, Length: number): ()
	for Offset = 0, Length - 1, 8 do
		local Y = buffer.readu32(CipherBuffer, Offset)
		local X = buffer.readu32(CipherBuffer, Offset + 4)

		for RoundIndex = 27, 0, -4 do
			Y = bit32.rrotate(bit32.bxor(Y, X), 3)
			X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, (RoundIndex + 4) * 4)) - Y, 8)

			Y = bit32.rrotate(bit32.bxor(Y, X), 3)
			X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, (RoundIndex + 3) * 4)) - Y, 8)

			Y = bit32.rrotate(bit32.bxor(Y, X), 3)
			X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, (RoundIndex + 2) * 4)) - Y, 8)

			Y = bit32.rrotate(bit32.bxor(Y, X), 3)
			X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, (RoundIndex + 1) * 4)) - Y, 8)
		end

		Y = bit32.rrotate(bit32.bxor(Y, X), 3)
		X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, 12)) - Y, 8)

		Y = bit32.rrotate(bit32.bxor(Y, X), 3)
		X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, 8)) - Y, 8)

		Y = bit32.rrotate(bit32.bxor(Y, X), 3)
		X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, 4)) - Y, 8)

		Y = bit32.rrotate(bit32.bxor(Y, X), 3)
		X = bit32.lrotate(bit32.bxor(X, buffer.readu32(RoundKeys, 0)) - Y, 8)

		buffer.writeu32(PlaintextBuffer, Offset, Y)
		buffer.writeu32(PlaintextBuffer, Offset + 4, X)
	end
end

local function PadBuffer(InputBuffer: buffer): buffer
	local Length = buffer.len(InputBuffer)
	local Amount = 8 - (Length % 8)
	local PaddedBuffer = buffer.create(Length + Amount)

	buffer.copy(PaddedBuffer, 0, InputBuffer, 0, Length)

	if Amount == 8 then
		buffer.writeu32(PaddedBuffer, Length, 0x08080808)
		buffer.writeu32(PaddedBuffer, Length + 4, 0x08080808)
	elseif Amount == 4 then
		buffer.writeu32(PaddedBuffer, Length, Amount * 0x01010101)
	else
		for Index = Length, Length + Amount - 1 do
			buffer.writeu8(PaddedBuffer, Index, Amount)
		end
	end

	return PaddedBuffer
end

local function UnpadBuffer(InputBuffer: buffer): buffer
	local Length = buffer.len(InputBuffer)
	if Length == 0 then
		return InputBuffer
	end

	local Amount = buffer.readu8(InputBuffer, Length - 1)
	local UnpaddedBuffer = buffer.create(Length - Amount)
	buffer.copy(UnpaddedBuffer, 0, InputBuffer, 0, Length - Amount)

	return UnpaddedBuffer
end

local function PadKey(KeyBuffer: buffer): buffer
	local KeyLength = buffer.len(KeyBuffer)
	local PreparedKey = buffer.create(8)

	if KeyLength >= 8 then
		buffer.writeu32(PreparedKey, 0, buffer.readu32(KeyBuffer, 0))
		buffer.writeu32(PreparedKey, 4, buffer.readu32(KeyBuffer, 4))
	else
		buffer.copy(PreparedKey, 0, KeyBuffer, 0, KeyLength)
		for Index = KeyLength, 7 do
			buffer.writeu8(PreparedKey, Index, 0)
		end
	end

	return PreparedKey
end

local function ExpandKey(KeyBuffer: buffer): buffer
	local B = buffer.readu32(KeyBuffer, 0)
	local A = buffer.readu32(KeyBuffer, 4)

	local RoundKeys = buffer.create(128)
	buffer.writeu32(RoundKeys, 0, B)

	for RoundIndex = 0, 29, 2 do
		A = bit32.bxor(bit32.rrotate(A, 8) + B, RoundIndex)
		B = bit32.bxor(bit32.lrotate(B, 3), A)
		buffer.writeu32(RoundKeys, (RoundIndex + 1) * 4, B)

		A = bit32.bxor(bit32.rrotate(A, 8) + B, RoundIndex + 1)
		B = bit32.bxor(bit32.lrotate(B, 3), A)
		buffer.writeu32(RoundKeys, (RoundIndex + 2) * 4, B)
	end

	A = bit32.bxor(bit32.rrotate(A, 8) + B, 30)
	B = bit32.bxor(bit32.lrotate(B, 3), A)
	buffer.writeu32(RoundKeys, 124, B)

	return RoundKeys
end

function Speck.Encrypt(PlaintextBuffer: buffer, KeyBuffer: buffer): buffer
	local PaddedPlainText = PadBuffer(PlaintextBuffer)
	local PreparedKey = PadKey(KeyBuffer)

	local Length = buffer.len(PaddedPlainText)
	local CipherBuffer = buffer.create(Length)

	EncryptBlocks(CipherBuffer, PaddedPlainText, PreparedKey, Length)
	return CipherBuffer
end

function Speck.Decrypt(CipherBuffer: buffer, KeyBuffer: buffer): buffer
	local PreparedKey = PadKey(KeyBuffer)
	local Length = buffer.len(CipherBuffer)
	local PlainTextBuffer = buffer.create(Length)

	local RoundKeys = ExpandKey(PreparedKey)
	DecryptBlocks(PlainTextBuffer, CipherBuffer, RoundKeys, Length)
	return UnpadBuffer(PlainTextBuffer)
end

return Speck]]></ProtectedString>
							<string name="ScriptGuid">{8AA20675-380E-4A2E-993A-79DAB743A3FB}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Speck</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX94C11BFAE6DD42149D4DB2B0892487C2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: XOR Symmetric Cipher

	 WARNING: XOR is not cryptographically secure!
	Do not use the same key twice!
	For security, use AES or CHACHA20. 

	Return type: buffer 
	Example Usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring("MySecretKey12345") -- Fastest when its a multiple of 4 or is longer than the message
		
		local Encrypted = XOR(Message, Key)
		local Decrypted = XOR(Encrypted, Key) 
--]=]

--!strict
--!optimize 2
--!native

local function XOR(StringBuffer: buffer, KeyBuffer: buffer): buffer
	local StringLength = buffer.len(StringBuffer)
	local KeyLength = buffer.len(KeyBuffer)

	local OutputBuffer = buffer.create(StringLength)
	buffer.copy(OutputBuffer, 0, StringBuffer, 0, StringLength)

	if KeyLength == 1 then
		local KeyByte = buffer.readu8(KeyBuffer, 0)
		local KeyWord = bit32.bor(
			KeyByte,
			bit32.lshift(KeyByte, 8),
			bit32.lshift(KeyByte, 16),
			bit32.lshift(KeyByte, 24)
		)
		
		local Offset = 0
		while Offset + 3 < StringLength do
			buffer.writeu32(OutputBuffer, Offset, bit32.bxor(buffer.readu32(OutputBuffer, Offset), KeyWord))
			Offset += 4
		end
		
		while Offset < StringLength do
			buffer.writeu8(OutputBuffer, Offset, bit32.bxor(buffer.readu8(OutputBuffer, Offset), KeyByte))
			Offset += 1
		end
		
		return OutputBuffer
	end

	if KeyLength == 4 then
		local KeyWord = buffer.readu32(KeyBuffer, 0)
		local Offset = 0
		while Offset + 3 < StringLength do
			buffer.writeu32(OutputBuffer, Offset, bit32.bxor(buffer.readu32(OutputBuffer, Offset), KeyWord))
			Offset += 4
		end
		
		for Index = 0, StringLength - Offset - 1 do
			local ByteOffset = Offset + Index
			buffer.writeu8(OutputBuffer, ByteOffset, bit32.bxor(
				buffer.readu8(OutputBuffer, ByteOffset),
				buffer.readu8(KeyBuffer, Index)
				))
		end
		
		return OutputBuffer
	end

	local ExtendedKeyLength = math.min(StringLength, KeyLength * 256)
	local ExtendedKeyBuffer = buffer.create(ExtendedKeyLength)

	local Pos = 0 
	while Pos < ExtendedKeyLength do
		local CopyLen = math.min(KeyLength, ExtendedKeyLength - Pos)
		buffer.copy(ExtendedKeyBuffer, Pos, KeyBuffer, 0, CopyLen)
		Pos += CopyLen
	end

	local StringOffset = 0
	while StringOffset < StringLength do
		local ChunkSize = math.min(ExtendedKeyLength, StringLength - StringOffset)
		local KeyOffset = 0

		while KeyOffset + 3 < ChunkSize and StringOffset + KeyOffset + 3 < StringLength do
			local Offset = StringOffset + KeyOffset
			buffer.writeu32(OutputBuffer, Offset, bit32.bxor(
				buffer.readu32(OutputBuffer, Offset),
				buffer.readu32(ExtendedKeyBuffer, KeyOffset)
				))
			KeyOffset += 4
		end

		while KeyOffset < ChunkSize and StringOffset + KeyOffset < StringLength do
			local Offset = StringOffset + KeyOffset
			buffer.writeu8(OutputBuffer, Offset, bit32.bxor(
				buffer.readu8(OutputBuffer, Offset),
				buffer.readu8(ExtendedKeyBuffer, KeyOffset)
				))
			KeyOffset += 1
		end

		StringOffset += ChunkSize
	end

	return OutputBuffer
end

return XOR]]></ProtectedString>
							<string name="ScriptGuid">{BC56D148-B40A-4CFC-8C3A-E66D6898DEB5}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">XOR</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX5815020E7ED344A59000ACD088C14D25">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!strict

local Algorithms = table.freeze({
	HMAC = require("@self/HMAC"),
	KMAC = require("@self/KMAC"),
	MD5 = require("@self/MD5"),
	SHA1 = require("@self/SHA1"),
	SHA2 = require("@self/SHA2"),
	SHA3 = require("@self/SHA3"),
	XXH32 = require("@self/XXH32"),
	Blake2b = require("@self/Blake2b"),
	Blake3 = require("@self/Blake3"),
	MurMur = require("@self/Murmur")
})

return Algorithms]]></ProtectedString>
						<string name="ScriptGuid">{440345B8-5626-4EA5-BF9D-275BA2C97DFC}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Hashing</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9C1AD7ADD5024C8184F397552D1405EF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: BLAKE2b
	
	Return type: string
	Example usage:
		local Message = buffer.fromstring("Hello World")
		
		-- BLAKE2b-128 (128-bit output)
		local Result128 = BLAKE2b(Message, 16)
		
		-- BLAKE2b-256 (256-bit output)
		local Result256 = BLAKE2b(Message, 32)
		
		-- BLAKE2b-384 (384-bit output)
		local Result384 = BLAKE2b(Message, 48)
		
		-- BLAKE2b-512 (512-bit output, default)
		local Result512 = BLAKE2b(Message, 64)
		-- or simply: local Result512 = BLAKE2b(Message)
		
		-- With optional key
		local OptionalKey = buffer.fromstring("MyKey")
		local Result = BLAKE2b(Message, 64, OptionalKey)
--]=]

--!strict
--!optimize 2
--!native

local BLOCK_SIZE_BYTES = 128
local DEFAULT_OUTPUT_BYTES = 64

local BLAKE2B_MIN_OUTPUT_BYTES = 1
local BLAKE2B_MAX_OUTPUT_BYTES = 64
local BLAKE2B_MAX_KEY_BYTES = 64

local InitVectors = {
	0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
	0xf3bcc908, 0x84caa73b, 0xfe94f82b, 0x5f1d36f1, 0xade682d1, 0x2b3e6c1f, 0xfb41bd6b, 0x137e2179
}

local PERMUTATION_TABLE = {
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
	15, 11, 5, 9, 10, 16, 14, 7, 2, 13, 1, 3, 12, 8, 6, 4,
	12, 9, 13, 1, 6, 3, 16, 14, 11, 15, 4, 7, 8, 2, 10, 5,
	8, 10, 4, 2, 14, 13, 12, 15, 3, 7, 6, 11, 5, 1, 16, 9,
	10, 1, 6, 8, 3, 5, 11, 16, 15, 2, 12, 13, 7, 9, 4, 14,
	3, 13, 7, 11, 1, 12, 9, 4, 5, 14, 8, 6, 16, 15, 2, 10,
	13, 6, 2, 16, 15, 14, 5, 11, 1, 8, 7, 4, 10, 3, 9, 12,
	14, 12, 8, 15, 13, 2, 4, 10, 6, 1, 16, 5, 9, 7, 3, 11,
	7, 16, 15, 10, 12, 4, 1, 9, 13, 3, 14, 8, 2, 5, 11, 6,
	11, 3, 9, 5, 8, 7, 2, 6, 16, 12, 10, 15, 4, 13, 14, 1,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
	15, 11, 5, 9, 10, 16, 14, 7, 2, 13, 1, 3, 12, 8, 6, 4
}

local WH9, WH10, WH11, WH12, WH13, WH14, WH15, WH16 = InitVectors[1], InitVectors[2], InitVectors[3], InitVectors[4], InitVectors[5], InitVectors[6], InitVectors[7], InitVectors[8]
local WL9, WL10, WL11, WL12, WL13, WL14, WL15, WL16 = InitVectors[9], InitVectors[10], InitVectors[11], InitVectors[12], InitVectors[13], InitVectors[14], InitVectors[15], InitVectors[16]

local function ExtractWordsFromBlock(InputBuffer: buffer, StartOffset: number, HighWords: {number}, LowWords: {number})
	for WordIdx = 1, 16 do
		local BytePos = StartOffset + (WordIdx - 1) * 8
		LowWords[WordIdx] = buffer.readu32(InputBuffer, BytePos)
		HighWords[WordIdx] = buffer.readu32(InputBuffer, BytePos + 4)
	end
end

local function ProcessCompressionRound(HighWords: {number}, LowWords: {number}, ByteCounter: number, FinalBlock: boolean, StateHigh: {number}, StateLow: {number})
	local WH1, WH2, WH3, WH4, WH5, WH6, WH7, WH8 = StateHigh[1], StateHigh[2], StateHigh[3], StateHigh[4], StateHigh[5], StateHigh[6], StateHigh[7], StateHigh[8]
	local WL1, WL2, WL3, WL4, WL5, WL6, WL7, WL8 = StateLow[1], StateLow[2], StateLow[3], StateLow[4], StateLow[5], StateLow[6], StateLow[7], StateLow[8]

	local WorkH9, WorkH10, WorkH11, WorkH12, WorkH13, WorkH14, WorkH15, WorkH16 = WH9, WH10, WH11, WH12, WH13, WH14, WH15, WH16
	local WorkL9, WorkL10, WorkL11, WorkL12, WorkL13, WorkL14, WorkL15, WorkL16 = WL9, WL10, WL11, WL12, WL13, WL14, WL15, WL16

	WorkH13 = bit32.bxor(WorkH13, ByteCounter // 0x100000000)
	WorkL13 = bit32.bxor(WorkL13, bit32.bor(ByteCounter, 0))
	if FinalBlock then
		WorkH15 = bit32.bnot(WorkH15)
		WorkL15 = bit32.bnot(WorkL15)
	end

	local CarryBits, MsgHighX, MsgLowX, MsgHighY, MsgLowY = 0, 0, 0, 0, 0
	local Permutation = PERMUTATION_TABLE

	for RoundNum = 1, 12 do
		local ScheduleBase = (RoundNum - 1) * 16

		local S1, S2 = Permutation[ScheduleBase + 1], Permutation[ScheduleBase + 2]
		MsgHighX, MsgLowX = HighWords[S1], LowWords[S1]
		MsgHighY, MsgLowY = HighWords[S2], LowWords[S2]

		CarryBits = WL1 + WL5 + MsgLowX
		WH1 += WH5 + MsgHighX + CarryBits // 0x100000000
		WL1 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH13
		WorkH13 = bit32.bxor(WorkL13, WL1)
		WorkL13 = bit32.bxor(CarryBits, WH1)

		CarryBits = WorkL9 + WorkL13
		WorkH9 += WorkH13 + CarryBits // 0x100000000
		WorkL9 = bit32.bor(CarryBits, 0)

		CarryBits = WH5
		WH5 = bit32.bxor(bit32.rshift(WH5, 24), bit32.lshift(WL5, 8), bit32.rshift(WorkH9, 24), bit32.lshift(WorkL9, 8))
		WL5 = bit32.bxor(bit32.rshift(WL5, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL9, 24), bit32.lshift(WorkH9, 8))

		CarryBits = WL1 + WL5 + MsgLowY
		WH1 += WH5 + MsgHighY + CarryBits // 0x100000000
		WL1 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH13
		WorkH13 = bit32.bxor(bit32.rshift(WorkH13, 16), bit32.lshift(WorkL13, 16), bit32.rshift(WH1, 16), bit32.lshift(WL1, 16))
		WorkL13 = bit32.bxor(bit32.rshift(WorkL13, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL1, 16), bit32.lshift(WH1, 16))

		CarryBits = WorkL9 + WorkL13
		WorkH9 += WorkH13 + CarryBits // 0x100000000
		WorkL9 = bit32.bor(CarryBits, 0)

		CarryBits = WH5
		WH5 = bit32.bxor(bit32.lshift(WH5, 1), bit32.rshift(WL5, 31), bit32.lshift(WorkH9, 1), bit32.rshift(WorkL9, 31))
		WL5 = bit32.bxor(bit32.lshift(WL5, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL9, 1), bit32.rshift(WorkH9, 31))

		local S3, S4 = Permutation[ScheduleBase + 3], Permutation[ScheduleBase + 4]
		MsgHighX, MsgLowX = HighWords[S3], LowWords[S3]
		MsgHighY, MsgLowY = HighWords[S4], LowWords[S4]

		CarryBits = WL2 + WL6 + MsgLowX
		WH2 += WH6 + MsgHighX + CarryBits // 0x100000000
		WL2 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH14
		WorkH14 = bit32.bxor(WorkL14, WL2)
		WorkL14 = bit32.bxor(CarryBits, WH2)

		CarryBits = WorkL10 + WorkL14
		WorkH10 += WorkH14 + CarryBits // 0x100000000
		WorkL10 = bit32.bor(CarryBits, 0)

		CarryBits = WH6
		WH6 = bit32.bxor(bit32.rshift(WH6, 24), bit32.lshift(WL6, 8), bit32.rshift(WorkH10, 24), bit32.lshift(WorkL10, 8))
		WL6 = bit32.bxor(bit32.rshift(WL6, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL10, 24), bit32.lshift(WorkH10, 8))

		CarryBits = WL2 + WL6 + MsgLowY
		WH2 += WH6 + MsgHighY + CarryBits // 0x100000000
		WL2 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH14
		WorkH14 = bit32.bxor(bit32.rshift(WorkH14, 16), bit32.lshift(WorkL14, 16), bit32.rshift(WH2, 16), bit32.lshift(WL2, 16))
		WorkL14 = bit32.bxor(bit32.rshift(WorkL14, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL2, 16), bit32.lshift(WH2, 16))

		CarryBits = WorkL10 + WorkL14
		WorkH10 += WorkH14 + CarryBits // 0x100000000
		WorkL10 = bit32.bor(CarryBits, 0)

		CarryBits = WH6
		WH6 = bit32.bxor(bit32.lshift(WH6, 1), bit32.rshift(WL6, 31), bit32.lshift(WorkH10, 1), bit32.rshift(WorkL10, 31))
		WL6 = bit32.bxor(bit32.lshift(WL6, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL10, 1), bit32.rshift(WorkH10, 31))

		local S5, S6 = Permutation[ScheduleBase + 5], Permutation[ScheduleBase + 6]
		MsgHighX, MsgLowX = HighWords[S5], LowWords[S5]
		MsgHighY, MsgLowY = HighWords[S6], LowWords[S6]

		CarryBits = WL3 + WL7 + MsgLowX
		WH3 += WH7 + MsgHighX + CarryBits // 0x100000000
		WL3 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH15
		WorkH15 = bit32.bxor(WorkL15, WL3)
		WorkL15 = bit32.bxor(CarryBits, WH3)

		CarryBits = WorkL11 + WorkL15
		WorkH11 += WorkH15 + CarryBits // 0x100000000
		WorkL11 = bit32.bor(CarryBits, 0)

		CarryBits = WH7
		WH7 = bit32.bxor(bit32.rshift(WH7, 24), bit32.lshift(WL7, 8), bit32.rshift(WorkH11, 24), bit32.lshift(WorkL11, 8))
		WL7 = bit32.bxor(bit32.rshift(WL7, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL11, 24), bit32.lshift(WorkH11, 8))

		CarryBits = WL3 + WL7 + MsgLowY
		WH3 += WH7 + MsgHighY + CarryBits // 0x100000000
		WL3 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH15
		WorkH15 = bit32.bxor(bit32.rshift(WorkH15, 16), bit32.lshift(WorkL15, 16), bit32.rshift(WH3, 16), bit32.lshift(WL3, 16))
		WorkL15 = bit32.bxor(bit32.rshift(WorkL15, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL3, 16), bit32.lshift(WH3, 16))

		CarryBits = WorkL11 + WorkL15
		WorkH11 += WorkH15 + CarryBits // 0x100000000
		WorkL11 = bit32.bor(CarryBits, 0)

		CarryBits = WH7
		WH7 = bit32.bxor(bit32.lshift(WH7, 1), bit32.rshift(WL7, 31), bit32.lshift(WorkH11, 1), bit32.rshift(WorkL11, 31))
		WL7 = bit32.bxor(bit32.lshift(WL7, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL11, 1), bit32.rshift(WorkH11, 31))

		local S7, S8 = Permutation[ScheduleBase + 7], Permutation[ScheduleBase + 8]
		MsgHighX, MsgLowX = HighWords[S7], LowWords[S7]
		MsgHighY, MsgLowY = HighWords[S8], LowWords[S8]

		CarryBits = WL4 + WL8 + MsgLowX
		WH4 += WH8 + MsgHighX + CarryBits // 0x100000000
		WL4 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH16
		WorkH16 = bit32.bxor(WorkL16, WL4)
		WorkL16 = bit32.bxor(CarryBits, WH4)

		CarryBits = WorkL12 + WorkL16
		WorkH12 += WorkH16 + CarryBits // 0x100000000
		WorkL12 = bit32.bor(CarryBits, 0)

		CarryBits = WH8
		WH8 = bit32.bxor(bit32.rshift(WH8, 24), bit32.lshift(WL8, 8), bit32.rshift(WorkH12, 24), bit32.lshift(WorkL12, 8))
		WL8 = bit32.bxor(bit32.rshift(WL8, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL12, 24), bit32.lshift(WorkH12, 8))

		CarryBits = WL4 + WL8 + MsgLowY
		WH4 += WH8 + MsgHighY + CarryBits // 0x100000000
		WL4 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH16
		WorkH16 = bit32.bxor(bit32.rshift(WorkH16, 16), bit32.lshift(WorkL16, 16), bit32.rshift(WH4, 16), bit32.lshift(WL4, 16))
		WorkL16 = bit32.bxor(bit32.rshift(WorkL16, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL4, 16), bit32.lshift(WH4, 16))

		CarryBits = WorkL12 + WorkL16
		WorkH12 += WorkH16 + CarryBits // 0x100000000
		WorkL12 = bit32.bor(CarryBits, 0)

		CarryBits = WH8
		WH8 = bit32.bxor(bit32.lshift(WH8, 1), bit32.rshift(WL8, 31), bit32.lshift(WorkH12, 1), bit32.rshift(WorkL12, 31))
		WL8 = bit32.bxor(bit32.lshift(WL8, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL12, 1), bit32.rshift(WorkH12, 31))

		local S9, S10 = Permutation[ScheduleBase + 9], Permutation[ScheduleBase + 10]
		MsgHighX, MsgLowX = HighWords[S9], LowWords[S9]
		MsgHighY, MsgLowY = HighWords[S10], LowWords[S10]

		CarryBits = WL1 + WL6 + MsgLowX
		WH1 += WH6 + MsgHighX + CarryBits // 0x100000000
		WL1 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH16
		WorkH16 = bit32.bxor(WorkL16, WL1)
		WorkL16 = bit32.bxor(CarryBits, WH1)

		CarryBits = WorkL11 + WorkL16
		WorkH11 += WorkH16 + CarryBits // 0x100000000
		WorkL11 = bit32.bor(CarryBits, 0)

		CarryBits = WH6
		WH6 = bit32.bxor(bit32.rshift(WH6, 24), bit32.lshift(WL6, 8), bit32.rshift(WorkH11, 24), bit32.lshift(WorkL11, 8))
		WL6 = bit32.bxor(bit32.rshift(WL6, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL11, 24), bit32.lshift(WorkH11, 8))

		CarryBits = WL1 + WL6 + MsgLowY
		WH1 += WH6 + MsgHighY + CarryBits // 0x100000000
		WL1 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH16
		WorkH16 = bit32.bxor(bit32.rshift(WorkH16, 16), bit32.lshift(WorkL16, 16), bit32.rshift(WH1, 16), bit32.lshift(WL1, 16))
		WorkL16 = bit32.bxor(bit32.rshift(WorkL16, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL1, 16), bit32.lshift(WH1, 16))

		CarryBits = WorkL11 + WorkL16
		WorkH11 += WorkH16 + CarryBits // 0x100000000
		WorkL11 = bit32.bor(CarryBits, 0)

		CarryBits = WH6
		WH6 = bit32.bxor(bit32.lshift(WH6, 1), bit32.rshift(WL6, 31), bit32.lshift(WorkH11, 1), bit32.rshift(WorkL11, 31))
		WL6 = bit32.bxor(bit32.lshift(WL6, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL11, 1), bit32.rshift(WorkH11, 31))

		local S11, S12 = Permutation[ScheduleBase + 11], Permutation[ScheduleBase + 12]
		MsgHighX, MsgLowX = HighWords[S11], LowWords[S11]
		MsgHighY, MsgLowY = HighWords[S12], LowWords[S12]

		CarryBits = WL2 + WL7 + MsgLowX
		WH2 += WH7 + MsgHighX + CarryBits // 0x100000000
		WL2 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH13
		WorkH13 = bit32.bxor(WorkL13, WL2)
		WorkL13 = bit32.bxor(CarryBits, WH2)

		CarryBits = WorkL12 + WorkL13
		WorkH12 += WorkH13 + CarryBits // 0x100000000
		WorkL12 = bit32.bor(CarryBits, 0)

		CarryBits = WH7
		WH7 = bit32.bxor(bit32.rshift(WH7, 24), bit32.lshift(WL7, 8), bit32.rshift(WorkH12, 24), bit32.lshift(WorkL12, 8))
		WL7 = bit32.bxor(bit32.rshift(WL7, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL12, 24), bit32.lshift(WorkH12, 8))

		CarryBits = WL2 + WL7 + MsgLowY
		WH2 += WH7 + MsgHighY + CarryBits // 0x100000000
		WL2 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH13
		WorkH13 = bit32.bxor(bit32.rshift(WorkH13, 16), bit32.lshift(WorkL13, 16), bit32.rshift(WH2, 16), bit32.lshift(WL2, 16))
		WorkL13 = bit32.bxor(bit32.rshift(WorkL13, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL2, 16), bit32.lshift(WH2, 16))

		CarryBits = WorkL12 + WorkL13
		WorkH12 += WorkH13 + CarryBits // 0x100000000
		WorkL12 = bit32.bor(CarryBits, 0)

		CarryBits = WH7
		WH7 = bit32.bxor(bit32.lshift(WH7, 1), bit32.rshift(WL7, 31), bit32.lshift(WorkH12, 1), bit32.rshift(WorkL12, 31))
		WL7 = bit32.bxor(bit32.lshift(WL7, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL12, 1), bit32.rshift(WorkH12, 31))

		local S13, S14 = Permutation[ScheduleBase + 13], Permutation[ScheduleBase + 14]
		MsgHighX, MsgLowX = HighWords[S13], LowWords[S13]
		MsgHighY, MsgLowY = HighWords[S14], LowWords[S14]

		CarryBits = WL3 + WL8 + MsgLowX
		WH3 += WH8 + MsgHighX + CarryBits // 0x100000000
		WL3 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH14
		WorkH14 = bit32.bxor(WorkL14, WL3)
		WorkL14 = bit32.bxor(CarryBits, WH3)

		CarryBits = WorkL9 + WorkL14
		WorkH9 += WorkH14 + CarryBits // 0x100000000
		WorkL9 = bit32.bor(CarryBits, 0)

		CarryBits = WH8
		WH8 = bit32.bxor(bit32.rshift(WH8, 24), bit32.lshift(WL8, 8), bit32.rshift(WorkH9, 24), bit32.lshift(WorkL9, 8))
		WL8 = bit32.bxor(bit32.rshift(WL8, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL9, 24), bit32.lshift(WorkH9, 8))

		CarryBits = WL3 + WL8 + MsgLowY
		WH3 += WH8 + MsgHighY + CarryBits // 0x100000000
		WL3 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH14
		WorkH14 = bit32.bxor(bit32.rshift(WorkH14, 16), bit32.lshift(WorkL14, 16), bit32.rshift(WH3, 16), bit32.lshift(WL3, 16))
		WorkL14 = bit32.bxor(bit32.rshift(WorkL14, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL3, 16), bit32.lshift(WH3, 16))

		CarryBits = WorkL9 + WorkL14
		WorkH9 += WorkH14 + CarryBits // 0x100000000
		WorkL9 = bit32.bor(CarryBits, 0)

		CarryBits = WH8
		WH8 = bit32.bxor(bit32.lshift(WH8, 1), bit32.rshift(WL8, 31), bit32.lshift(WorkH9, 1), bit32.rshift(WorkL9, 31))
		WL8 = bit32.bxor(bit32.lshift(WL8, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL9, 1), bit32.rshift(WorkH9, 31))

		local S15, S16 = Permutation[ScheduleBase + 15], Permutation[ScheduleBase + 16]
		MsgHighX, MsgLowX = HighWords[S15], LowWords[S15]
		MsgHighY, MsgLowY = HighWords[S16], LowWords[S16]

		CarryBits = WL4 + WL5 + MsgLowX
		WH4 += WH5 + MsgHighX + CarryBits // 0x100000000
		WL4 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH15
		WorkH15 = bit32.bxor(WorkL15, WL4)
		WorkL15 = bit32.bxor(CarryBits, WH4)

		CarryBits = WorkL10 + WorkL15
		WorkH10 += WorkH15 + CarryBits // 0x100000000
		WorkL10 = bit32.bor(CarryBits, 0)

		CarryBits = WH5
		WH5 = bit32.bxor(bit32.rshift(WH5, 24), bit32.lshift(WL5, 8), bit32.rshift(WorkH10, 24), bit32.lshift(WorkL10, 8))
		WL5 = bit32.bxor(bit32.rshift(WL5, 24), bit32.lshift(CarryBits, 8), bit32.rshift(WorkL10, 24), bit32.lshift(WorkH10, 8))

		CarryBits = WL4 + WL5 + MsgLowY
		WH4 += WH5 + MsgHighY + CarryBits // 0x100000000
		WL4 = bit32.bor(CarryBits, 0)

		CarryBits = WorkH15
		WorkH15 = bit32.bxor(bit32.rshift(WorkH15, 16), bit32.lshift(WorkL15, 16), bit32.rshift(WH4, 16), bit32.lshift(WL4, 16))
		WorkL15 = bit32.bxor(bit32.rshift(WorkL15, 16), bit32.lshift(CarryBits, 16), bit32.rshift(WL4, 16), bit32.lshift(WH4, 16))

		CarryBits = WorkL10 + WorkL15
		WorkH10 += WorkH15 + CarryBits // 0x100000000
		WorkL10 = bit32.bor(CarryBits, 0)

		CarryBits = WH5
		WH5 = bit32.bxor(bit32.lshift(WH5, 1), bit32.rshift(WL5, 31), bit32.lshift(WorkH10, 1), bit32.rshift(WorkL10, 31))
		WL5 = bit32.bxor(bit32.lshift(WL5, 1), bit32.rshift(CarryBits, 31), bit32.lshift(WorkL10, 1), bit32.rshift(WorkH10, 31))
	end

	StateHigh[1] = bit32.bxor(StateHigh[1], WH1, WorkH9)
	StateLow[1] = bit32.bxor(StateLow[1], WL1, WorkL9)
	StateHigh[2] = bit32.bxor(StateHigh[2], WH2, WorkH10)
	StateLow[2] = bit32.bxor(StateLow[2], WL2, WorkL10)
	StateHigh[3] = bit32.bxor(StateHigh[3], WH3, WorkH11)
	StateLow[3] = bit32.bxor(StateLow[3], WL3, WorkL11)
	StateHigh[4] = bit32.bxor(StateHigh[4], WH4, WorkH12)
	StateLow[4] = bit32.bxor(StateLow[4], WL4, WorkL12)
	StateHigh[5] = bit32.bxor(StateHigh[5], WH5, WorkH13)
	StateLow[5] = bit32.bxor(StateLow[5], WL5, WorkL13)
	StateHigh[6] = bit32.bxor(StateHigh[6], WH6, WorkH14)
	StateLow[6] = bit32.bxor(StateLow[6], WL6, WorkL14)
	StateHigh[7] = bit32.bxor(StateHigh[7], WH7, WorkH15)
	StateLow[7] = bit32.bxor(StateLow[7], WL7, WorkL15)
	StateHigh[8] = bit32.bxor(StateHigh[8], WH8, WorkH16)
	StateLow[8] = bit32.bxor(StateLow[8], WL8, WorkL16)
end

local function HashDigest(InputData: buffer, OutputLength: number, KeyData: buffer?): (string, buffer)
	local KeyLength = KeyData and buffer.len(KeyData) or 0
	local DataLength = buffer.len(InputData)

	local StateHigh = { WH9, WH10, WH11, WH12, WH13, WH14, WH15, WH16 }
	local StateLow = { WL9, WL10, WL11, WL12, WL13, WL14, WL15, WL16 }

	StateLow[1] = bit32.bxor(StateLow[1], 0x01010000, bit32.lshift(KeyLength, 8), OutputLength)

	local BlockHigh = table.create(16) :: {number}
	local BlockLow = table.create(16) :: {number}
	local ProcessedBytes = KeyLength > 0 and 128 or 0

	if KeyLength > 0 and KeyData then
		local KeyPadding = buffer.create(BLOCK_SIZE_BYTES)
		buffer.copy(KeyPadding, 0, KeyData)
		ExtractWordsFromBlock(KeyPadding, 0, BlockHigh, BlockLow)
		ProcessCompressionRound(BlockHigh, BlockLow, ProcessedBytes, DataLength == 0, StateHigh, StateLow)
	end

	local RemainingBytes = DataLength % BLOCK_SIZE_BYTES
	local FinalBlockSize = RemainingBytes == 0 and BLOCK_SIZE_BYTES or RemainingBytes

	for BlockStart = 0, DataLength - FinalBlockSize - 1, BLOCK_SIZE_BYTES do
		ExtractWordsFromBlock(InputData, BlockStart, BlockHigh, BlockLow)
		ProcessedBytes += BLOCK_SIZE_BYTES
		ProcessCompressionRound(BlockHigh, BlockLow, ProcessedBytes, false, StateHigh, StateLow)
	end

	if KeyLength == 0 or DataLength > 0 then
		local PaddedBlock = buffer.create(BLOCK_SIZE_BYTES)
		local CopyBytes = math.min(FinalBlockSize, DataLength)
		local CopyStart = math.max(0, DataLength - FinalBlockSize)
		if CopyBytes > 0 then
			buffer.copy(PaddedBlock, 0, InputData, CopyStart, CopyBytes)
		end

		ExtractWordsFromBlock(PaddedBlock, 0, BlockHigh, BlockLow)
		ProcessCompressionRound(BlockHigh, BlockLow, ProcessedBytes + CopyBytes, true, StateHigh, StateLow)
	end

	local Digest = buffer.create(OutputLength)
	local Offset = 0

	for Index = 1, 8 do
		if Offset + 4 <= OutputLength then
			buffer.writeu32(Digest, Offset, StateLow[Index])
			Offset += 4
		end

		if Offset + 4 <= OutputLength then
			buffer.writeu32(Digest, Offset, StateHigh[Index])
			Offset += 4
		end

		if Offset >= OutputLength then
			break
		end
	end

	local FinalDigest = string.format(
		"%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x",
		bit32.byteswap(StateLow[1]), bit32.byteswap(StateHigh[1]),
		bit32.byteswap(StateLow[2]), bit32.byteswap(StateHigh[2]),
		bit32.byteswap(StateLow[3]), bit32.byteswap(StateHigh[3]),
		bit32.byteswap(StateLow[4]), bit32.byteswap(StateHigh[4]),
		bit32.byteswap(StateLow[5]), bit32.byteswap(StateHigh[5]),
		bit32.byteswap(StateLow[6]), bit32.byteswap(StateHigh[6]),
		bit32.byteswap(StateLow[7]), bit32.byteswap(StateHigh[7]),
		bit32.byteswap(StateLow[8]), bit32.byteswap(StateHigh[8])
	)

	return string.sub(FinalDigest, 1, OutputLength * 2), Digest
end

local function BLAKE2b(InputData: buffer, OutputLength: number?, KeyData: buffer?): (string, buffer)
	if InputData == nil then
		error("InputData cannot be nil", 2)
	end

	if typeof(InputData) ~= "buffer" then
		error(`InputData must be a buffer, got {typeof(InputData)}`, 2)
	end

	if OutputLength then
		if typeof(OutputLength) ~= "number" then
			error(`OutputLength must be a number, got {typeof(OutputLength)}`, 2)
		end

		if OutputLength ~= math.floor(OutputLength) then
			error(`OutputLength must be an integer, got {OutputLength}`, 2)
		end

		if OutputLength < BLAKE2B_MIN_OUTPUT_BYTES or OutputLength > BLAKE2B_MAX_OUTPUT_BYTES then
			error(`OutputLength must be between {BLAKE2B_MIN_OUTPUT_BYTES} and {BLAKE2B_MAX_OUTPUT_BYTES} bytes, got {OutputLength} bytes`, 2)
		end
	end

	if KeyData then
		if typeof(KeyData) ~= "buffer" then
			error(`KeyData must be a buffer, got {typeof(KeyData)}`, 2)
		end

		local KeyLength = buffer.len(KeyData)
		if KeyLength == 0 then
			error("KeyData cannot be empty", 2)
		end

		if KeyLength > BLAKE2B_MAX_KEY_BYTES then
			error(`KeyData must be at most {BLAKE2B_MAX_KEY_BYTES} bytes long, got {KeyLength} bytes`, 2)
		end
	end

	return HashDigest(InputData, OutputLength or DEFAULT_OUTPUT_BYTES, KeyData)
end

return BLAKE2b]]></ProtectedString>
							<string name="ScriptGuid">{2F261918-5237-41CA-B814-3E960365EEA3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Blake2b</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX34F3B9413D7D40959CA0A2FA01552809">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Blake3
	
	Sizes:
		Key: 32 bytes
		Output: variable
	
	Return type: string (hex)
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		
		--------Standard Hash--------
		local Hash = Blake3.Digest(Message, 32)
		
		--------Keyed Hash--------
		local KeyedHash = Blake3.DigestKeyed(Message, Key, 32)
		
		--------Key Derivation--------
		local Context = buffer.fromstring("my context")
		local KeyDeriver = Blake3.DeriveKey(Context)
		local DerivedKey = KeyDeriver(Message, 32)
--]=]

--!strict
--!optimize 2
--!native

local Blake3 = {}

local BLOCK_SIZE = 64
local CV_SIZE = 32
local EXTENDED_CV_SIZE = 64
local MAX_STACK_DEPTH = 64
local STACK_BUFFER_SIZE = MAX_STACK_DEPTH * CV_SIZE

local BLAKE3_KEY_SIZE = 32
local BLAKE3_MIN_OUTPUT_BYTES = 1
local BLAKE3_MAX_OUTPUT_BYTES = 2^32 - 1

local CHUNK_START = 0x01
local CHUNK_END = 0x02
local PARENT_FLAG = 0x04
local ROOT_FLAG = 0x08
local HASH_FLAG = 0x10
local DERIVE_CONTEXT_FLAG = 0x20
local DERIVE_MATERIAL_FLAG = 0x40

local INITIAL_VECTORS = buffer.create(CV_SIZE) do
	local IV = {
		0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
		0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
	}
	for Index, Value in ipairs(IV) do
		buffer.writeu32(INITIAL_VECTORS, (Index - 1) * 4, Value)
	end
end

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local function Compress(Hash: buffer, MessageBlock: buffer, Counter: number, V14: number, V15: number, IsFull: boolean?): buffer
	local Hash00 = buffer.readu32(Hash, 0)
	local Hash01 = buffer.readu32(Hash, 4)
	local Hash02 = buffer.readu32(Hash, 8)
	local Hash03 = buffer.readu32(Hash, 12)
	local Hash04 = buffer.readu32(Hash, 16)
	local Hash05 = buffer.readu32(Hash, 20)
	local Hash06 = buffer.readu32(Hash, 24)
	local Hash07 = buffer.readu32(Hash, 28)

	local V00, V01, V02, V03 = Hash00, Hash01, Hash02, Hash03
	local V04, V05, V06, V07 = Hash04, Hash05, Hash06, Hash07
	local V08, V09, V10, V11 = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a

	local V12 = Counter % (2 ^ 32)
	local V13 = (Counter - V12) * (2 ^ -32)

	local M00 = buffer.readu32(MessageBlock, 0)
	local M01 = buffer.readu32(MessageBlock, 4)
	local M02 = buffer.readu32(MessageBlock, 8)
	local M03 = buffer.readu32(MessageBlock, 12)
	local M04 = buffer.readu32(MessageBlock, 16)
	local M05 = buffer.readu32(MessageBlock, 20)
	local M06 = buffer.readu32(MessageBlock, 24)
	local M07 = buffer.readu32(MessageBlock, 28)
	local M08 = buffer.readu32(MessageBlock, 32)
	local M09 = buffer.readu32(MessageBlock, 36)
	local M10 = buffer.readu32(MessageBlock, 40)
	local M11 = buffer.readu32(MessageBlock, 44)
	local M12 = buffer.readu32(MessageBlock, 48)
	local M13 = buffer.readu32(MessageBlock, 52)
	local M14 = buffer.readu32(MessageBlock, 56)
	local M15 = buffer.readu32(MessageBlock, 60)

	local Temp
	for Index = 1, 7 do
		V00 += V04 + M00; V12 = bit32.lrotate(bit32.bxor(V12, V00), 16)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 20)
		V00 += V04 + M01; V12 = bit32.lrotate(bit32.bxor(V12, V00), 24)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 25)

		V01 += V05 + M02; V13 = bit32.lrotate(bit32.bxor(V13, V01), 16)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 20)
		V01 += V05 + M03; V13 = bit32.lrotate(bit32.bxor(V13, V01), 24)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 25)

		V02 += V06 + M04; V14 = bit32.lrotate(bit32.bxor(V14, V02), 16)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 20)
		V02 += V06 + M05; V14 = bit32.lrotate(bit32.bxor(V14, V02), 24)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 25)

		V03 += V07 + M06; V15 = bit32.lrotate(bit32.bxor(V15, V03), 16)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 20)
		V03 += V07 + M07; V15 = bit32.lrotate(bit32.bxor(V15, V03), 24)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 25)

		V00 += V05 + M08; V15 = bit32.lrotate(bit32.bxor(V15, V00), 16)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 20)
		V00 += V05 + M09; V15 = bit32.lrotate(bit32.bxor(V15, V00), 24)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 25)

		V01 += V06 + M10; V12 = bit32.lrotate(bit32.bxor(V12, V01), 16)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 20)
		V01 += V06 + M11; V12 = bit32.lrotate(bit32.bxor(V12, V01), 24)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 25)

		V02 += V07 + M12; V13 = bit32.lrotate(bit32.bxor(V13, V02), 16)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 20)
		V02 += V07 + M13; V13 = bit32.lrotate(bit32.bxor(V13, V02), 24)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 25)

		V03 += V04 + M14; V14 = bit32.lrotate(bit32.bxor(V14, V03), 16)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 20)
		V03 += V04 + M15; V14 = bit32.lrotate(bit32.bxor(V14, V03), 24)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 25)

		if Index ~= 7 then
			Temp = M02
			M02 = M03
			M03 = M10
			M10 = M12
			M12 = M09
			M09 = M11
			M11 = M05
			M05 = M00
			M00 = Temp

			Temp = M06
			M06 = M04
			M04 = M07
			M07 = M13
			M13 = M14
			M14 = M15
			M15 = M08
			M08 = M01
			M01 = Temp
		end
	end

	if IsFull then
		local Result = buffer.create(EXTENDED_CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		buffer.writeu32(Result, 32, bit32.bxor(V08, Hash00))
		buffer.writeu32(Result, 36, bit32.bxor(V09, Hash01))
		buffer.writeu32(Result, 40, bit32.bxor(V10, Hash02))
		buffer.writeu32(Result, 44, bit32.bxor(V11, Hash03))
		buffer.writeu32(Result, 48, bit32.bxor(V12, Hash04))
		buffer.writeu32(Result, 52, bit32.bxor(V13, Hash05))
		buffer.writeu32(Result, 56, bit32.bxor(V14, Hash06))
		buffer.writeu32(Result, 60, bit32.bxor(V15, Hash07))

		return Result
	else
		local Result = buffer.create(CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		return Result
	end
end

local function ProcessMessage(InitialHashVector: buffer, Flags: number, Message: buffer, Length: number): buffer
	local MessageLength = buffer.len(Message)
	local StateCvs = buffer.create(STACK_BUFFER_SIZE)
	local StateCv = buffer.create(CV_SIZE)

	local StackSize = 0
	local StateCounter = 0

	local StateChunkNumber = 0
	local StateEndFlag = 0

	local BlockSize = BLOCK_SIZE
	local CvSize = CV_SIZE
	local ExtendedCvSize = EXTENDED_CV_SIZE

	local StateStartFlag = CHUNK_START
	local ChunkStart = CHUNK_START
	local ChunkEnd = CHUNK_END

	local ParentFlag = PARENT_FLAG
	local RootFlag = ROOT_FLAG
	local FlagsParent = Flags + ParentFlag

	local BlockBuffer = buffer.create(BlockSize)
	local PopCv = buffer.create(CvSize)
	local MergeBlock = buffer.create(ExtendedCvSize)
	local StackCv = buffer.create(CvSize)
	local Block = buffer.create(ExtendedCvSize)

	buffer.copy(StateCv, 0, InitialHashVector, 0, CvSize)

	for BlockOffset = 0, MessageLength - BlockSize - 1, BlockSize do
		buffer.copy(BlockBuffer, 0, Message, BlockOffset, BlockSize)
		local StateFlags = Flags + StateStartFlag + StateEndFlag
		StateCv = Compress(StateCv, BlockBuffer, StateCounter, BlockSize, StateFlags)
		StateStartFlag = 0
		StateChunkNumber += 1

		if StateChunkNumber == 15 then
			StateEndFlag = ChunkEnd
		elseif StateChunkNumber == 16 then
			local MergeCv = StateCv
			local MergeAmount = StateCounter + 1

			while MergeAmount % 2 == 0 do
				StackSize -= 1
				buffer.copy(PopCv, 0, StateCvs, StackSize * CvSize, CvSize)
				buffer.copy(MergeBlock, 0, PopCv, 0, CvSize)
				buffer.copy(MergeBlock, CvSize, MergeCv, 0, CvSize)
				MergeCv = Compress(InitialHashVector, MergeBlock, 0, BlockSize, FlagsParent)
				MergeAmount /= 2
			end

			buffer.copy(StateCvs, StackSize * CvSize, MergeCv, 0, CvSize)
			StackSize += 1

			buffer.copy(StateCv, 0, InitialHashVector, 0, CvSize)
			StateStartFlag = ChunkStart
			StateCounter += 1
			StateChunkNumber = 0
			StateEndFlag = 0
		end
	end

	local LastLength = MessageLength == 0 and 0 or ((MessageLength - 1) % BlockSize + 1)
	local PaddedMessage = buffer.create(BlockSize)
	if LastLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, MessageLength - LastLength, LastLength)
	end

	local OutputCv: buffer
	local OutputBlock: buffer
	local OutputLength: number
	local OutputFlags: number

	if StateCounter > 0 then
		local StateFlags = Flags + StateStartFlag + ChunkEnd
		local MergeCv = Compress(StateCv, PaddedMessage, StateCounter, LastLength, StateFlags)
		for Index = StackSize, 2, -1 do
			buffer.copy(StackCv, 0, StateCvs, (Index - 1) * CvSize, CvSize)
			buffer.copy(Block, 0, StackCv, 0, CvSize)
			buffer.copy(Block, CvSize, MergeCv, 0, CvSize)
			MergeCv = Compress(InitialHashVector, Block, 0, BlockSize, FlagsParent)
		end

		OutputCv = InitialHashVector
		local FirstStackCv = buffer.create(CvSize)
		buffer.copy(FirstStackCv, 0, StateCvs, 0, CvSize)
		OutputBlock = buffer.create(ExtendedCvSize)

		buffer.copy(OutputBlock, 0, FirstStackCv, 0, CvSize)
		buffer.copy(OutputBlock, CvSize, MergeCv, 0, CvSize)

		OutputLength = BlockSize
		OutputFlags = Flags + RootFlag + ParentFlag
	else
		OutputCv = StateCv
		OutputBlock = PaddedMessage
		OutputLength = LastLength
		OutputFlags = Flags + StateStartFlag + ChunkEnd + RootFlag
	end

	local Output = buffer.create(Length)
	local OutputOffset = 0
	for Index = 0, Length // BlockSize do
		local MessageDigest = Compress(OutputCv, OutputBlock, Index, OutputLength, OutputFlags, true)
		local BytesToCopy = math.min(BlockSize, Length - OutputOffset)
		buffer.copy(Output, OutputOffset, MessageDigest, 0, BytesToCopy)
		OutputOffset += BytesToCopy
		if OutputOffset >= Length then
			break
		end
	end

	return Output
end

local function ToHex(Buffer: buffer): string
	local Length = buffer.len(Buffer)
	local Hex = buffer.create(Length * 2)

	local Lookup = ENCODE_LOOKUP

	local Leftover = Length % 8
	local HexCursor = 0

	for Index = 0, Length - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = Length - Leftover, Length - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex)
end

function Blake3.Digest(Message: buffer, Length: number?): (string, buffer)
	if Message == nil then
		error("Message cannot be nil", 2)
	end

	if typeof(Message) ~= "buffer" then
		error(`Message must be a buffer, got {typeof(Message)}`, 2)
	end

	if Length then
		if typeof(Length) ~= "number" then
			error(`Length must be a number, got {typeof(Length)}`, 2)
		end

		if Length ~= math.floor(Length) then
			error(`Length must be an integer, got {Length}`, 2)
		end

		if Length < BLAKE3_MIN_OUTPUT_BYTES then
			error(`Length must be at least {BLAKE3_MIN_OUTPUT_BYTES} byte, got {Length} bytes`, 2)
		end

		if Length > BLAKE3_MAX_OUTPUT_BYTES then
			error(`Length must be at most {BLAKE3_MAX_OUTPUT_BYTES} bytes, got {Length} bytes`, 2)
		end
	end

	local Result = ProcessMessage(INITIAL_VECTORS, 0, Message, Length or 32)

	return ToHex(Result), Result
end

function Blake3.DigestKeyed(Message: buffer, Key: buffer, Length: number?): (string, buffer)
	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= BLAKE3_KEY_SIZE then
		error(`Key must be exactly {BLAKE3_KEY_SIZE} bytes long, got {KeyLength} bytes`, 2)
	end

	if Message == nil then
		error("Message cannot be nil", 2)
	end
	if typeof(Message) ~= "buffer" then
		error(`Message must be a buffer, got {typeof(Message)}`, 2)
	end

	if Length then
		if typeof(Length) ~= "number" then
			error(`Length must be a number, got {typeof(Length)}`, 2)
		end
		if Length ~= math.floor(Length) then
			error(`Length must be an integer, got {Length}`, 2)
		end
		if Length < BLAKE3_MIN_OUTPUT_BYTES then
			error(`Length must be at least {BLAKE3_MIN_OUTPUT_BYTES} byte, got {Length} bytes`, 2)
		end
		if Length > BLAKE3_MAX_OUTPUT_BYTES then
			error(`Length must be at most {BLAKE3_MAX_OUTPUT_BYTES} bytes, got {Length} bytes`, 2)
		end
	end

	local Result = ProcessMessage(Key, HASH_FLAG, Message, Length or 32)

	return ToHex(Result), Result
end

function Blake3.DeriveKey(Context: buffer): (buffer, number?) -> (string, buffer)
	if Context == nil then
		error("Context cannot be nil", 2)
	end

	if typeof(Context) ~= "buffer" then
		error(`Context must be a buffer, got {typeof(Context)}`, 2)
	end

	local ContextHash = ProcessMessage(INITIAL_VECTORS, DERIVE_CONTEXT_FLAG, Context, 32)

	return function(Material: buffer, Length: number?): (string, buffer)
		if Material == nil then
			error("Material cannot be nil", 2)
		end

		if typeof(Material) ~= "buffer" then
			error(`Material must be a buffer, got {typeof(Material)}`, 2)
		end

		if Length then
			if typeof(Length) ~= "number" then
				error(`Length must be a number, got {typeof(Length)}`, 2)
			end

			if Length ~= math.floor(Length) then
				error(`Length must be an integer, got {Length}`, 2)
			end

			if Length < BLAKE3_MIN_OUTPUT_BYTES then
				error(`Length must be at least {BLAKE3_MIN_OUTPUT_BYTES} byte, got {Length} bytes`, 2)
			end

			if Length > BLAKE3_MAX_OUTPUT_BYTES then
				error(`Length must be at most {BLAKE3_MAX_OUTPUT_BYTES} bytes, got {Length} bytes`, 2)
			end
		end

		local Result = ProcessMessage(ContextHash, DERIVE_MATERIAL_FLAG, Material, Length or 32)

		return ToHex(Result), Result
	end
end

return Blake3]]></ProtectedString>
							<string name="ScriptGuid">{26D3FAE5-87B4-4267-8A12-A549823FA4DB}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Blake3</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX33544C3F872C44219F9B310612F986D9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: HMAC
	
	Return type: string or function
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring("Key")
		local BlockSize = 64 -- SHA256 block length (= string.len(SHA256(...)))
		
		local Result = HMAC(Message, Key, SHA2.SHA256, BlockSize) -- SHA3/Blake family should have BigEndian = false
--]=]

--!strict
--!optimize 2
--!native

export type HashFunction = (...any) -> (string, buffer)

local function FromByteAndSize(Byte: number, Size: number)
	local Buffer = buffer.create(Size)
	buffer.fill(Buffer, 0, Byte)
	return Buffer
end

local function ToBigEndian(Buffer: buffer)
	for Index = 0, buffer.len(Buffer) - 1, 4 do
		buffer.writeu32(Buffer, Index, bit32.byteswap(buffer.readu32(Buffer, Index)))
	end
end

local function ConcatenateBuffers(LeftBuffer: buffer, RightBuffer: buffer)
	local LeftBufLen = buffer.len(LeftBuffer)
	local Buffer = buffer.create(LeftBufLen + buffer.len(RightBuffer))

	buffer.copy(Buffer, 0, LeftBuffer)
	buffer.copy(Buffer, LeftBufLen, RightBuffer)

	return Buffer
end

local function XORBuffer(LeftBuffer: buffer, RightBuffer: buffer)
	local Size = math.min(buffer.len(LeftBuffer), buffer.len(RightBuffer))
	local NewBuffer = buffer.create(Size)

	for Index = 0, Size - 1 do
		local LeftValue = buffer.readu8(LeftBuffer, Index)
		local RightValue = buffer.readu8(RightBuffer, Index)
		buffer.writeu8(NewBuffer, Index, bit32.bxor(LeftValue, RightValue))
	end

	return NewBuffer
end

local function ComputeBlockSizedKey(Key: buffer, HashFunction: HashFunction, BlockSizeBytes: number, BigEndian: boolean?): buffer
	local KeyLength = buffer.len(Key)
	if KeyLength > BlockSizeBytes then
		local _, Digest = HashFunction(Key)
		if BigEndian ~= false then
			ToBigEndian(Digest)
		end

		local PaddedKey = buffer.create(BlockSizeBytes)
		buffer.copy(PaddedKey, 0, Digest)
		return PaddedKey
	elseif KeyLength < BlockSizeBytes then
		local PaddedKey = buffer.create(BlockSizeBytes)
		buffer.copy(PaddedKey, 0, Key)
		return PaddedKey
	end

	return Key
end

local function HMAC(Message: buffer, Key: buffer, HashFunction: HashFunction, BlockSizeBytes: number, BigEndian: boolean?): (string, buffer)
	local BlockSizedKey = ComputeBlockSizedKey(Key, HashFunction, BlockSizeBytes, BigEndian)
	local OuterPaddedKey = XORBuffer(BlockSizedKey, FromByteAndSize(0x5C, BlockSizeBytes))
	local InnerPaddedKey = XORBuffer(BlockSizedKey, FromByteAndSize(0x36, BlockSizeBytes))
	local _, HashedMessageWithInnerKey = HashFunction(ConcatenateBuffers(InnerPaddedKey, Message))

	if BigEndian ~= false then
		ToBigEndian(HashedMessageWithInnerKey)
	end

	local FinalMessage = ConcatenateBuffers(OuterPaddedKey, HashedMessageWithInnerKey)
	return HashFunction(FinalMessage)
end

return HMAC]]></ProtectedString>
							<string name="ScriptGuid">{F4A1A424-8E4A-4443-ADF6-84DE9876AD0D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HMAC</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX632EB2589FB54D9893AEC9A44B768C7A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: MD5
	
	 WARNING: MD5 is cryptographically broken!
	Only use for legacy compatibility, checksums, or non-security purposes.
	For security, use SHA256 or higher. 
	
	Return type: string
	Usage:
		local Message = buffer.fromstring("Hello World")
		local Result = MD5(Message)
--]=]

--!strict
--!optimize 2
--!native
local OFFSETS = table.create(64) :: {number}
local CONSTANTS = {
	0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
	0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
	0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
	0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
	0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
	0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
	0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
	0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
}

local SHIFTS = {
	7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
	5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
	4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
	6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
}

local function PreProcess(Contents: buffer): (buffer, number)
	local ContentLength = buffer.len(Contents)
	local BitLength = ContentLength * 8

	local Padding = (56 - ((ContentLength + 1) % 64)) % 64

	local NewContentLength = ContentLength + 1 + Padding + 8
	local NewContent = buffer.create(NewContentLength)

	buffer.copy(NewContent, 0, Contents)

	buffer.writeu8(NewContent, ContentLength, 0x80)

	local LengthOffset = ContentLength + 1 + Padding
	for Index = 0, 7 do
		local Byte = BitLength % 256
		buffer.writeu8(NewContent, LengthOffset + Index, Byte)
		BitLength = bit32.rshift(BitLength, 8)	
	end

	return NewContent, NewContentLength
end

local function DigestBlocks(Blocks: buffer, Length: number): (number, number, number, number)
	local A, B, C, D = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

	local Offsets = OFFSETS
	local Constants = CONSTANTS
	local Shifts = SHIFTS

	for Offset = 0, Length - 1, 64 do
		for WordIndex = 0, 15 do
			local BlockOffset = Offset + WordIndex * 4
			local Word = buffer.readu32(Blocks, BlockOffset)
			Offsets[WordIndex + 1] = Word
		end

		local OldA, OldB, OldC, OldD = A, B, C, D
		local Temp, Func = 0, 0
		for Round = 0, 15 do
			local Chunk = Offsets[Round + 1]
			Func = bit32.bxor(OldD, bit32.band(OldB, bit32.bxor(OldC, OldD)))
			Temp = OldD
			OldD = OldC
			OldC = OldB

			OldB = OldB + bit32.lrotate(OldA + Func + Constants[Round + 1] + Chunk, Shifts[Round + 1])
			OldA = Temp
		end

		for Round = 16, 31 do
			local Chunk = Offsets[(5 * Round + 1) % 16 + 1]
			Func = bit32.bxor(OldC, bit32.band(OldD, bit32.bxor(OldB, OldC)))
			Temp = OldD
			OldD = OldC
			OldC = OldB
			OldB = OldB + bit32.lrotate(OldA + Func + Constants[Round + 1] + Chunk, Shifts[Round + 1])
			OldA = Temp
		end

		for Round = 32, 47 do
			local Chunk = Offsets[(3 * Round + 5) % 16 + 1]
			Func = bit32.bxor(OldB, OldC, OldD)
			Temp = OldD
			OldD = OldC
			OldC = OldB
			OldB = OldB + bit32.lrotate(OldA + Func + Constants[Round + 1] + Chunk, Shifts[Round + 1])
			OldA = Temp
		end

		for Round = 48, 63 do
			local Chunk = Offsets[(7 * Round) % 16 + 1]
			Func = bit32.bxor(OldC, bit32.bor(OldB, bit32.bnot(OldD)))
			Temp = OldD
			OldD = OldC
			OldC = OldB
			OldB = OldB + bit32.lrotate(OldA + Func + Constants[Round + 1] + Chunk, Shifts[Round + 1])
			OldA = Temp
		end

		A = bit32.bor(OldA + A, 0)
		B = bit32.bor(OldB + B, 0)
		C = bit32.bor(OldC + C, 0)
		D = bit32.bor(OldD + D, 0)
	end

	return bit32.byteswap(A), bit32.byteswap(B), bit32.byteswap(C), bit32.byteswap(D)
end

local function MD5(Message: buffer, Salt: buffer?): (string, buffer)
	if Salt and buffer.len(Salt) > 0 then
		local MessageWithSalt = buffer.create(buffer.len(Message) + buffer.len(Salt))
		buffer.copy(MessageWithSalt, 0, Message)
		buffer.copy(MessageWithSalt, buffer.len(Message), Salt)
		Message = MessageWithSalt
	end

	local ProcessedMessage, Length = PreProcess(Message)

	local A, B, C, D = DigestBlocks(ProcessedMessage, Length)
	local Digest = buffer.create(16)
	
	buffer.writeu32(Digest, 0, A)
	buffer.writeu32(Digest, 4, B)
	buffer.writeu32(Digest, 8, C)
	buffer.writeu32(Digest, 12, D)

	return string.format("%08x%08x%08x%08x", A, B, C, D), Digest
end

return MD5]]></ProtectedString>
							<string name="ScriptGuid">{ACABEC7C-5525-44BA-AE13-81A935363BD6}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MD5</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF0518D95B46D4B8FAF2DF5C477B1BA49">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: MurmurHash3-32
	
	 WARNING: MurmurHash3 wasn't designed with cryptographic security in mind!
	Only use for non-security purposes like hash tables or hyperloglog. For security, use SHA256 or higher. 
	
	MurmurHash3 is a fast non-cryptographic hash that is well-distributed.
	
	Return type: number
	Example usage:
		local Message = buffer.fromstring("Hello World")

		--------Usage Case 1--------
		local Result = MurmurHash3(Message)
		
		--------Usage Case 2--------
		local Seed = 0xDEADBEEF
		local Result = MurmurHash3(Message, Seed)
--]=]

--!strict
--!optimize 2
--!native

local function Mul32(A: number, B: number): number
	local AHigh = bit32.rshift(A, 16)
	local ALow = bit32.band(A, 0xFFFF)
	local BHigh = bit32.rshift(B, 16)
	local BLow = bit32.band(B, 0xFFFF)

	local LoLo = ALow * BLow
	local HiLo = bit32.lshift(AHigh * BLow, 16)
	local LoHi = bit32.lshift(ALow * BHigh, 16)

	local Result = bit32.bor(LoLo + HiLo, 0)
	return bit32.bor(Result + LoHi, 0)
end

local function FMix32(Hash: number): number
	Hash = Mul32(bit32.bxor(Hash, bit32.rshift(Hash, 16)), 0x85ebca6b)
	Hash = Mul32(bit32.bxor(Hash, bit32.rshift(Hash, 13)), 0xc2b2ae35)
	Hash = bit32.bxor(Hash, bit32.rshift(Hash, 16))
	return Hash
end

local function MurmurHash3(Message: buffer, Seed: number?): number
	local C1 = 0xcc9e2d51
	local C2 = 0x1b873593

	local Hash = bit32.bor(Seed or 0, 0)
	local MessageLength = buffer.len(Message)
	local BlockCount = MessageLength // 4
	local UnrolledBlocks = BlockCount // 4
	local CurrentOffset = 0

	for _ = 1, UnrolledBlocks do
		local K1 = buffer.readu32(Message, CurrentOffset)
		K1 = Mul32(bit32.lrotate(Mul32(K1, 0xcc9e2d51), 15), 0x1b873593)
		Hash = bit32.bor(bit32.lrotate(bit32.bxor(Hash, K1), 13) * 5 + 0xe6546b64, 0)

		local K2 = buffer.readu32(Message, CurrentOffset + 4)
		K2 = Mul32(bit32.lrotate(Mul32(K2, 0xcc9e2d51), 15), 0x1b873593)
		Hash = bit32.bor(bit32.lrotate(bit32.bxor(Hash, K2), 13) * 5 + 0xe6546b64, 0)

		local K3 = buffer.readu32(Message, CurrentOffset + 8)
		K3 = Mul32(bit32.lrotate(Mul32(K3, 0xcc9e2d51), 15), 0x1b873593)
		Hash = bit32.bor(bit32.lrotate(bit32.bxor(Hash, K3), 13) * 5 + 0xe6546b64, 0)

		local K4 = buffer.readu32(Message, CurrentOffset + 12)
		K4 = Mul32(bit32.lrotate(Mul32(K4, 0xcc9e2d51), 15), 0x1b873593)
		Hash = bit32.bor(bit32.lrotate(bit32.bxor(Hash, K4), 13) * 5 + 0xe6546b64, 0)

		CurrentOffset += 16
	end

	local RemainingBlocks = BlockCount % 4
	for _ = 1, RemainingBlocks do
		local K = buffer.readu32(Message, CurrentOffset)
		K = Mul32(K, 0xcc9e2d51)
		K = bit32.lrotate(K, 15)
		K = Mul32(K, 0x1b873593)
		Hash = bit32.bxor(Hash, K)
		Hash = bit32.lrotate(Hash, 13)
		Hash = bit32.bor(Hash * 5 + 0xe6546b64, 0)

		CurrentOffset += 4
	end

	local Remainder = MessageLength % 4
	if Remainder > 0 then
		local K1 = 0

		if Remainder >= 3 then
			K1 = bit32.bxor(K1, bit32.lshift(buffer.readu8(Message, CurrentOffset + 2), 16))
		end

		if Remainder >= 2 then
			K1 = bit32.bxor(K1, bit32.lshift(buffer.readu8(Message, CurrentOffset + 1), 8))
		end

		K1 = bit32.bxor(K1, buffer.readu8(Message, CurrentOffset))

		K1 = Mul32(K1, C1)
		K1 = bit32.lrotate(K1, 15)
		K1 = Mul32(K1, C2)
		Hash = bit32.bxor(Hash, K1)
	end

	Hash = bit32.bxor(Hash, MessageLength)
	Hash = FMix32(Hash)

	return Hash
end

return MurmurHash3]]></ProtectedString>
							<string name="ScriptGuid">{61B10BAB-9F58-4DD1-B390-19B1E5987D29}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Murmur</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA60EF3500E7345F88E6485B95015A664">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: SHA1
	
	 WARNING: SHA1 is cryptographically broken!
	Only use for legacy compatibility, checksums, or non-security purposes.
	For security, use SHA256 or higher. 

	Sizes:
		Digest: 20 bytes
	
	Return type: string
	Example usage:
		local Message = buffer.fromstring("Hello World")
		
		--------Usage Case 1--------
		local Result = SHA1(Message)
		
		--------Usage Case 2--------
		local OptionalSalt = buffer.fromstring("Salty")
		local Result = SHA1(Message, OptionalSalt)
--]=]

--!strict
--!optimize 2
--!native

local OFFSETS = buffer.create(320)

local function PreProcess(Contents: buffer): (buffer, number)
	local ContentLength = buffer.len(Contents)
	local Padding = (64 - ((ContentLength + 9) % 64)) % 64

	local NewContentLength = ContentLength + 1 + Padding + 8
	local NewContent = buffer.create(NewContentLength)
	buffer.copy(NewContent, 0, Contents)
	buffer.writeu8(NewContent, ContentLength, 128)

	local Length8 = ContentLength * 8
	for Index = 7, 0, -1 do
		local Remainder = Length8 % 256
		buffer.writeu8(NewContent, Index + ContentLength + 1 + Padding, Remainder)
		Length8 = (Length8 - Remainder) / 256
	end

	return NewContent, NewContentLength
end

local function DigestBlocks(Blocks: buffer, Length: number): (number, number, number, number, number)
	local A, B, C, D, E = 0x67452301, 0xefcdaB89, 0x98badcfe, 0x10325476, 0xc3d2e1f0
	local Offsets = OFFSETS

	for Offset = 0, Length - 1, 64 do
		for BlockIndex = 0, 60, 4 do
			buffer.writeu32(Offsets, BlockIndex, bit32.byteswap(buffer.readu32(Blocks, Offset + BlockIndex)))
		end

		for Index = 64, 316, 4 do
			buffer.writeu32(Offsets, Index, bit32.lrotate(bit32.bxor(
				buffer.readu32(Offsets, Index - 12),
				buffer.readu32(Offsets, Index - 32),
				buffer.readu32(Offsets, Index - 56),
				buffer.readu32(Offsets, Index - 64)
			), 1))
		end

		local H1, H2, H3, H4, H5 = A, B, C, D, E
		
		local Temp
		for Round = 0, 19 do
			Temp = bit32.lrotate(H1, 5) +
				bit32.band(H2, H3) + bit32.band(-1 - H2, H4) +
				H5 + 0x5a827999 +
				buffer.readu32(Offsets, Round * 4)
			
			H5, H4, H3, H2, H1 = H4, H3, bit32.lrotate(H2, 30), H1, Temp
		end
		
		for Round = 20, 39 do
			Temp = bit32.lrotate(H1, 5) +
				bit32.bxor(H2, H3, H4) +
				H5 + 0x6ed9eba1 +
				buffer.readu32(Offsets, Round * 4)
			
			H5, H4, H3, H2, H1 = H4, H3, bit32.lrotate(H2, 30), H1, Temp
		end
		
		for Round = 40, 59 do
			Temp = bit32.lrotate(H1, 5) +
				bit32.band(H4, H3) + bit32.band(H2, bit32.bxor(H4, H3)) +
				H5 + 0x8f1bbcdc +
				buffer.readu32(Offsets, Round * 4)
			
			H5, H4, H3, H2, H1 = H4, H3, bit32.lrotate(H2, 30), H1, Temp
		end
		
		for Round = 60, 79 do
			Temp = bit32.lrotate(H1, 5) +
				bit32.bxor(H2, H3, H4) +
				H5 + 0xca62c1d6 +
				buffer.readu32(Offsets, Round * 4)
			
			H5, H4, H3, H2, H1 = H4, H3, bit32.lrotate(H2, 30), H1, Temp
		end

		A = bit32.bor(A + H1, 0)
		B = bit32.bor(B + H2, 0)
		C = bit32.bor(C + H3, 0)
		D = bit32.bor(D + H4, 0)
		E = bit32.bor(E + H5, 0)
	end

	return A, B, C, D, E
end

local function SHA1(Message: buffer, Salt: buffer?): string
	if Salt and buffer.len(Salt) > 0 then
		local MessageWithSalt = buffer.create(buffer.len(Message) + buffer.len(Salt))

		buffer.copy(MessageWithSalt, 0, Message)
		buffer.copy(MessageWithSalt, buffer.len(Message), Salt)

		Message = MessageWithSalt
	end

	local ProcessedMessage, Length = PreProcess(Message)
	return string.format("%08x%08x%08x%08x%08x", DigestBlocks(ProcessedMessage, Length))
end

return SHA1]]></ProtectedString>
							<string name="ScriptGuid">{7D02A632-C624-4FB0-B12C-46BCF870A59D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA1</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX73FD5640B16F479D891E80CA8148A72A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[
	Cryptography library: SHA2 Family
--]]

return {
	SHA224 = require("@self/SHA224"),
	SHA256 = require("@self/SHA256"),
	SHA384 = require("@self/SHA384"),
	SHA512 = require("@self/SHA512"),
}]]></ProtectedString>
							<string name="ScriptGuid">{FF3C1E8A-90A8-4A36-93A6-C29ADF3E02AC}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA2</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXCC3756BB51E44C86B05740DCE680286E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: SHA224
	
	Sizes:
		Digest: 28 bytes

	Return type: string
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Result = SHA224(Message)
--]=]

--!strict
--!optimize 2
--!native

local CONSTANTS = buffer.create(256) do -- CONSTANTS = k
	local RoundConstants = {
		0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
		0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
		0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
		0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
		0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	}

	for Index, Constant in ipairs(RoundConstants) do
		local BufferOffset = (Index - 1) * 4
		buffer.writeu32(CONSTANTS, BufferOffset, Constant)
	end
end

local function PreProcess(Contents: buffer): (buffer, number)
	local ContentLength = buffer.len(Contents)
	local Padding = -(ContentLength + 9) % 64

	local NewContentLength = ContentLength + 1 + Padding + 8
	local NewContent = buffer.create(NewContentLength)
	buffer.copy(NewContent, 0, Contents)
	buffer.writeu8(NewContent, ContentLength, 128)
	local Length8 = ContentLength * 8
	for Index = 7, 0, -1 do
		local Remainder = Length8 % 256
		buffer.writeu8(NewContent, Index + ContentLength + 1 + Padding, Remainder)
		Length8 = (Length8 - Remainder) / 256
	end

	return NewContent, NewContentLength
end

local OFFSETS = buffer.create(256)
local function DigestBlocks(Blocks: buffer, Length: number): (number, number, number, number, number, number, number)
	local A, B, C, D = 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939
	local E, F, G, H = 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4

	local Offsets = OFFSETS
	local Constants = CONSTANTS

	for Offset = 0, Length - 1, 64 do
		for BlockIndex = 0, 60, 4 do
			buffer.writeu32(Offsets, BlockIndex, bit32.byteswap(buffer.readu32(Blocks, Offset + BlockIndex)))
		end

		for Index = 64, 252, 4 do
			local Sub15 = buffer.readu32(Offsets, Index - 60)
			local S0 = bit32.bxor(bit32.rrotate(Sub15, 7), bit32.rrotate(Sub15, 18), bit32.rshift(Sub15, 3))

			local Sub2 = buffer.readu32(Offsets, Index - 8)
			local S1 = bit32.bxor(bit32.rrotate(Sub2, 17), bit32.rrotate(Sub2, 19), bit32.rshift(Sub2, 10))

			local Sub7, Sub16 = buffer.readu32(Offsets, Index - 28), buffer.readu32(Offsets, Index - 64)
			buffer.writeu32(Offsets, Index, (Sub16 + S0 + Sub7 + S1))
		end

		local OldA, OldB, OldC, OldD, OldE, OldF, OldG, OldH = A, B, C, D, E, F, G, H

		for BufferIndex = 0, 252, 4 do
			local S1 = bit32.bxor(bit32.rrotate(E, 6), bit32.rrotate(E, 11), bit32.rrotate(E, 25))
			local Ch = bit32.bxor(bit32.band(E, F), bit32.band(bit32.bnot(E), G))
			local Temp1 = H + S1 + Ch + buffer.readu32(Constants, BufferIndex) + buffer.readu32(Offsets, BufferIndex)
			H, G, F, E, D = G, F, E, D + Temp1, C

			local S0 = bit32.bxor(bit32.rrotate(A, 2), bit32.rrotate(A, 13), bit32.rrotate(A, 22))
			local Maj = bit32.bxor(bit32.band(A, B), bit32.band(A, C), bit32.band(B, C))
			C, B, A = B, A, Temp1 + S0 + Maj
		end

		A, B, C, D, E, F, G, H =
			bit32.bor(A + OldA, 0),
			bit32.bor(B + OldB, 0),
			bit32.bor(C + OldC, 0),
			bit32.bor(D + OldD, 0),
			bit32.bor(E + OldE, 0),
			bit32.bor(F + OldF, 0),
			bit32.bor(G + OldG, 0),
			bit32.bor(H + OldH, 0)
	end

	return A, B, C, D, E, F, G
end

local function SHA224(Message: buffer): (string, buffer)
	local ProcessedMessage, Length = PreProcess(Message)
	local A, B, C, D, E, F, G = DigestBlocks(ProcessedMessage, Length)

	local Digest = buffer.create(28)

	buffer.writeu32(Digest, 0, A)
	buffer.writeu32(Digest, 4, B)
	buffer.writeu32(Digest, 8, C)
	buffer.writeu32(Digest, 12, D)
	buffer.writeu32(Digest, 16, E)
	buffer.writeu32(Digest, 20, F)
	buffer.writeu32(Digest, 24, G)

	return string.format("%08x%08x%08x%08x%08x%08x%08x", A, B, C, D, E, F, G), Digest
end

return SHA224]]></ProtectedString>
								<string name="ScriptGuid">{D09250F3-BF49-406B-B847-D1583620F706}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SHA224</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF399906711CA4DF4997D7C6E07D9BAB4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: SHA256

	Sizes:
		Digest: 32 bytes
	
	Return type: string
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Result = SHA256(Message)
--]=]

--!strict
--!optimize 2
--!native
local CONSTANTS = buffer.create(256) do -- CONSTANTS = k
	local RoundConstants = {
		0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
		0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
		0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
		0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
		0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	}

	for Index, Constant in ipairs(RoundConstants) do
		local BufferOffset = (Index - 1) * 4
		buffer.writeu32(CONSTANTS, BufferOffset, Constant)
	end
end

local function PreProcess(Contents: buffer): (buffer, number)
	local ContentLength = buffer.len(Contents)
	local Padding = -(ContentLength + 9) % 64

	local NewContentLength = ContentLength + 1 + Padding + 8
	local NewContent = buffer.create(NewContentLength)
	buffer.copy(NewContent, 0, Contents)
	buffer.writeu8(NewContent, ContentLength, 128)
	local Length8 = ContentLength * 8
	for Index = 7, 0, -1 do
		local Remainder = Length8 % 256
		buffer.writeu8(NewContent, Index + ContentLength + 1 + Padding, Remainder)
		Length8 = (Length8 - Remainder) / 256
	end

	return NewContent, NewContentLength
end

local OFFSETS = buffer.create(256)
local function DigestBlocks(Blocks: buffer, Length: number): (number, number, number, number, number, number, number, number)
	local A, B, C, D = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a
	local E, F, G, H = 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19

	local Offsets = OFFSETS
	local Constants = CONSTANTS

	for Offset = 0, Length - 1, 64 do
		for BlockIndex = 0, 60, 4 do
			buffer.writeu32(Offsets, BlockIndex, bit32.byteswap(buffer.readu32(Blocks, Offset + BlockIndex)))
		end

		for Index = 64, 252, 4 do
			local Sub15 = buffer.readu32(Offsets, Index - 60)
			local S0 = bit32.bxor(bit32.rrotate(Sub15, 7), bit32.rrotate(Sub15, 18), bit32.rshift(Sub15, 3))

			local Sub2 = buffer.readu32(Offsets, Index - 8)
			local S1 = bit32.bxor(bit32.rrotate(Sub2, 17), bit32.rrotate(Sub2, 19), bit32.rshift(Sub2, 10))

			local Sub7, Sub16 = buffer.readu32(Offsets, Index - 28), buffer.readu32(Offsets, Index - 64)
			buffer.writeu32(Offsets, Index, (Sub16 + S0 + Sub7 + S1))
		end

		local OldA, OldB, OldC, OldD, OldE, OldF, OldG, OldH = A, B, C, D, E, F, G, H

		for BufferIndex = 0, 252, 4 do
			local S1 = bit32.bxor(bit32.rrotate(E, 6), bit32.rrotate(E, 11), bit32.rrotate(E, 25))
			local Ch = bit32.bxor(bit32.band(E, F), bit32.band(bit32.bnot(E), G))
			local Temp1 = H + S1 + Ch + buffer.readu32(Constants, BufferIndex) + buffer.readu32(Offsets, BufferIndex)
			H, G, F, E, D = G, F, E, D + Temp1, C

			local S0 = bit32.bxor(bit32.rrotate(A, 2), bit32.rrotate(A, 13), bit32.rrotate(A, 22))
			local Maj = bit32.bxor(bit32.band(A, B), bit32.band(A, C), bit32.band(B, C))
			C, B, A = B, A, Temp1 + S0 + Maj
		end

		A, B, C, D, E, F, G, H =
			bit32.bor(A + OldA, 0),
			bit32.bor(B + OldB, 0),
			bit32.bor(C + OldC, 0),
			bit32.bor(D + OldD, 0),
			bit32.bor(E + OldE, 0),
			bit32.bor(F + OldF, 0),
			bit32.bor(G + OldG, 0),
			bit32.bor(H + OldH, 0) :: number
	end

	return A, B, C, D, E, F, G, H
end

local function SHA256(Message: buffer): (string, buffer)
	local ProcessedMessage, Length = PreProcess(Message)
	local A, B, C, D, E, F, G, H = DigestBlocks(ProcessedMessage, Length)

	local Digest = buffer.create(32)

	buffer.writeu32(Digest, 0, A)
	buffer.writeu32(Digest, 4, B)
	buffer.writeu32(Digest, 8, C)
	buffer.writeu32(Digest, 12, D)
	buffer.writeu32(Digest, 16, E)
	buffer.writeu32(Digest, 20, F)
	buffer.writeu32(Digest, 24, G)
	buffer.writeu32(Digest, 28, H)

	return string.format("%08x%08x%08x%08x%08x%08x%08x%08x", A, B, C, D, E, F, G, H), Digest
end

return SHA256]]></ProtectedString>
								<string name="ScriptGuid">{BB547359-2428-4002-9566-9EA3445A4EB9}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SHA256</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCA5B57A4629A4BD0B9F0AD756B3998D0">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: SHA384

	Sizes:
		Digest: 48 bytes

	Return type: (string, buffer)
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Hash, HashBuffer = SHA384(Message)
--]=]

--!strict
--!optimize 2
--!native

local K_HI = {
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
	0xca273ece, 0xd186b8c7, 0xeada7dd6, 0xf57d4f7f, 0x06f067aa, 0x0a637dc5, 0x113f9804, 0x1b710b35,
	0x28db77f5, 0x32caab7b, 0x3c9ebe0a, 0x431d67c4, 0x4cc5d4be, 0x597f299c, 0x5fcb6fab, 0x6c44198c,
}

local K_LO = {
	0xd728ae22, 0x23ef65cd, 0xec4d3b2f, 0x8189dbbc, 0xf348b538, 0xb605d019, 0xaf194f9b, 0xda6d8118,
	0xa3030242, 0x45706fbe, 0x4ee4b28c, 0xd5ffb4e2, 0xf27b896f, 0x3b1696b1, 0x25c71235, 0xcf692694,
	0x9ef14ad2, 0x384f25e3, 0x8b8cd5b5, 0x77ac9c65, 0x592b0275, 0x6ea6e483, 0xbd41fbd4, 0x831153b5,
	0xee66dfab, 0x2db43210, 0x98fb213f, 0xbeef0ee4, 0x3da88fc2, 0x930aa725, 0xe003826f, 0x0a0e6e70,
	0x46d22ffc, 0x5c26c926, 0x5ac42aed, 0x9d95b3df, 0x8baf63de, 0x3c77b2a8, 0x47edaee6, 0x1482353b,
	0x4cf10364, 0xbc423001, 0xd0f89791, 0x0654be30, 0xd6ef5218, 0x5565a910, 0x5771202a, 0x32bbd1b8,
	0xb8d2d0c8, 0x5141ab53, 0xdf8eeb99, 0xe19b48a8, 0xc5c95a63, 0xe3418acb, 0x7763e373, 0xd6b2b8a3,
	0x5defb2fc, 0x43172f60, 0xa1f0ab72, 0x1a6439ec, 0x23631e28, 0xde82bde9, 0xb2c67915, 0xe372532b,
	0xea26619c, 0x21c0c207, 0xcde0eb1e, 0xee6ed178, 0x72176fba, 0xa2c898a6, 0xbef90dae, 0x131c471b,
	0x23047d84, 0x40c72493, 0x15c9bebc, 0x9c100d4c, 0xcb3e42b6, 0xfc657e2a, 0x3ad6faec, 0x4a475817,
}

local W_HI = table.create(80) :: {number}
local W_LO = table.create(80) :: {number}
local DIGEST = buffer.create(48)

local function PreProcess(Contents: buffer): (buffer, number)
	local ContentLength = buffer.len(Contents)
	local Padding = (128 - ((ContentLength + 17) % 128)) % 128
	local NewLength = ContentLength + 1 + Padding + 16

	local Result = buffer.create(NewLength)
	buffer.copy(Result, 0, Contents)
	buffer.writeu8(Result, ContentLength, 0x80)
	buffer.fill(Result, ContentLength + 1, 0, Padding + 8)

	local BitLength = ContentLength * 8
	local LengthOffset = ContentLength + 1 + Padding + 8

	for Index = 7, 0, -1 do
		buffer.writeu8(Result, LengthOffset + Index, BitLength % 256)
		BitLength = BitLength // 256
	end

	return Result, NewLength
end

local function DigestBlocks(Blocks: buffer, Length: number)
	local Hi, Lo = W_HI, W_LO
	local KHi, KLo = K_HI, K_LO

	local H1Hi, H2Hi, H3Hi, H4Hi = 0xcbbb9d5d, 0x629a292a, 0x9159015a, 0x152fecd8
	local H5Hi, H6Hi, H7Hi, H8Hi = 0x67332667, 0x8eb44a87, 0xdb0c2e0d, 0x47b5481d
	local H1Lo, H2Lo, H3Lo, H4Lo = 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939
	local H5Lo, H6Lo, H7Lo, H8Lo = 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4

	for Offset = 0, Length - 1, 128 do
		for T = 1, 16 do
			local ByteOffset = Offset + (T - 1) * 8
			Hi[T] = bit32.byteswap(buffer.readu32(Blocks, ByteOffset))
			Lo[T] = bit32.byteswap(buffer.readu32(Blocks, ByteOffset + 4))
		end

		for T = 17, 80 do
			local P15Hi, P15Lo = Hi[T - 15], Lo[T - 15]
			local P2Hi, P2Lo = Hi[T - 2], Lo[T - 2]

			local S0Lo = bit32.bxor(bit32.rshift(P15Lo, 1) + bit32.lshift(P15Hi, 31), bit32.rshift(P15Lo, 8) + bit32.lshift(P15Hi, 24), bit32.rshift(P15Lo, 7) + bit32.lshift(P15Hi, 25))
			local S1Lo = bit32.bxor(bit32.rshift(P2Lo, 19) + bit32.lshift(P2Hi, 13), bit32.lshift(P2Lo, 3) + bit32.rshift(P2Hi, 29), bit32.rshift(P2Lo, 6) + bit32.lshift(P2Hi, 26))

			local TmpLo = Lo[T - 16] + S0Lo + Lo[T - 7] + S1Lo
			Lo[T] = bit32.bor(TmpLo, 0)
			Hi[T] = bit32.bxor(bit32.rshift(P15Hi, 1) + bit32.lshift(P15Lo, 31), bit32.rshift(P15Hi, 8) + bit32.lshift(P15Lo, 24), bit32.rshift(P15Hi, 7)) +
				bit32.bxor(bit32.rshift(P2Hi, 19) + bit32.lshift(P2Lo, 13), bit32.lshift(P2Hi, 3) + bit32.rshift(P2Lo, 29), bit32.rshift(P2Hi, 6)) +
				Hi[T - 16] + Hi[T - 7] + TmpLo // 0x100000000
		end

		local AHi, ALo = H1Hi, H1Lo
		local BHi, BLo = H2Hi, H2Lo
		local CHi, CLo = H3Hi, H3Lo
		local DHi, DLo = H4Hi, H4Lo
		local EHi, ELo = H5Hi, H5Lo
		local FHi, FLo = H6Hi, H6Lo
		local GHi, GLo = H7Hi, H7Lo
		local HHi, HLo = H8Hi, H8Lo

		for T = 1, 79, 2 do
			local Sigma1Lo = bit32.bxor(bit32.rshift(ELo, 14) + bit32.lshift(EHi, 18), bit32.rshift(ELo, 18) + bit32.lshift(EHi, 14), bit32.lshift(ELo, 23) + bit32.rshift(EHi, 9))
			local Sigma1Hi = bit32.bxor(bit32.rshift(EHi, 14) + bit32.lshift(ELo, 18), bit32.rshift(EHi, 18) + bit32.lshift(ELo, 14), bit32.lshift(EHi, 23) + bit32.rshift(ELo, 9))
			local Sigma0Lo = bit32.bxor(bit32.rshift(ALo, 28) + bit32.lshift(AHi, 4), bit32.lshift(ALo, 30) + bit32.rshift(AHi, 2), bit32.lshift(ALo, 25) + bit32.rshift(AHi, 7))
			local Sigma0Hi = bit32.bxor(bit32.rshift(AHi, 28) + bit32.lshift(ALo, 4), bit32.lshift(AHi, 30) + bit32.rshift(ALo, 2), bit32.lshift(AHi, 25) + bit32.rshift(ALo, 7))
			local ChLo = bit32.band(ELo, FLo) + bit32.band(-1 - ELo, GLo)
			local ChHi = bit32.band(EHi, FHi) + bit32.band(-1 - EHi, GHi)
			local MajLo = bit32.band(CLo, BLo) + bit32.band(ALo, bit32.bxor(CLo, BLo))
			local MajHi = bit32.band(CHi, BHi) + bit32.band(AHi, bit32.bxor(CHi, BHi))

			local T1Lo = HLo + Sigma1Lo + ChLo + KLo[T] + Lo[T]
			local T1Hi = HHi + Sigma1Hi + ChHi + KHi[T] + Hi[T] + T1Lo // 0x100000000
			T1Lo = bit32.bor(T1Lo, 0)

			HHi, HLo = GHi, GLo
			GHi, GLo = FHi, FLo
			FHi, FLo = EHi, ELo

			local ELoNew = DLo + T1Lo
			EHi = DHi + T1Hi + ELoNew // 0x100000000
			ELo = bit32.bor(ELoNew, 0)

			DHi, DLo = CHi, CLo
			CHi, CLo = BHi, BLo
			BHi, BLo = AHi, ALo

			local ALoNew = T1Lo + Sigma0Lo + MajLo
			AHi = T1Hi + Sigma0Hi + MajHi + ALoNew // 0x100000000
			ALo = bit32.bor(ALoNew, 0)

			local T2 = T + 1
			Sigma1Lo = bit32.bxor(bit32.rshift(ELo, 14) + bit32.lshift(EHi, 18), bit32.rshift(ELo, 18) + bit32.lshift(EHi, 14), bit32.lshift(ELo, 23) + bit32.rshift(EHi, 9))
			Sigma1Hi = bit32.bxor(bit32.rshift(EHi, 14) + bit32.lshift(ELo, 18), bit32.rshift(EHi, 18) + bit32.lshift(ELo, 14), bit32.lshift(EHi, 23) + bit32.rshift(ELo, 9))
			Sigma0Lo = bit32.bxor(bit32.rshift(ALo, 28) + bit32.lshift(AHi, 4), bit32.lshift(ALo, 30) + bit32.rshift(AHi, 2), bit32.lshift(ALo, 25) + bit32.rshift(AHi, 7))
			Sigma0Hi = bit32.bxor(bit32.rshift(AHi, 28) + bit32.lshift(ALo, 4), bit32.lshift(AHi, 30) + bit32.rshift(ALo, 2), bit32.lshift(AHi, 25) + bit32.rshift(ALo, 7))
			ChLo = bit32.band(ELo, FLo) + bit32.band(-1 - ELo, GLo)
			ChHi = bit32.band(EHi, FHi) + bit32.band(-1 - EHi, GHi)
			MajLo = bit32.band(CLo, BLo) + bit32.band(ALo, bit32.bxor(CLo, BLo))
			MajHi = bit32.band(CHi, BHi) + bit32.band(AHi, bit32.bxor(CHi, BHi))

			T1Lo = HLo + Sigma1Lo + ChLo + KLo[T2] + Lo[T2]
			T1Hi = HHi + Sigma1Hi + ChHi + KHi[T2] + Hi[T2] + T1Lo // 0x100000000
			T1Lo = bit32.bor(T1Lo, 0)

			HHi, HLo = GHi, GLo
			GHi, GLo = FHi, FLo
			FHi, FLo = EHi, ELo

			ELoNew = DLo + T1Lo
			EHi = DHi + T1Hi + ELoNew // 0x100000000
			ELo = bit32.bor(ELoNew, 0)

			DHi, DLo = CHi, CLo
			CHi, CLo = BHi, BLo
			BHi, BLo = AHi, ALo

			ALoNew = T1Lo + Sigma0Lo + MajLo
			AHi = T1Hi + Sigma0Hi + MajHi + ALoNew // 0x100000000
			ALo = bit32.bor(ALoNew, 0)
		end

		H1Lo = H1Lo + ALo
		H1Hi = bit32.bor(H1Hi + AHi + H1Lo // 0x100000000, 0)
		H1Lo = bit32.bor(H1Lo, 0)

		H2Lo = H2Lo + BLo
		H2Hi = bit32.bor(H2Hi + BHi + H2Lo // 0x100000000, 0)
		H2Lo = bit32.bor(H2Lo, 0)

		H3Lo = H3Lo + CLo
		H3Hi = bit32.bor(H3Hi + CHi + H3Lo // 0x100000000, 0)
		H3Lo = bit32.bor(H3Lo, 0)

		H4Lo = H4Lo + DLo
		H4Hi = bit32.bor(H4Hi + DHi + H4Lo // 0x100000000, 0)
		H4Lo = bit32.bor(H4Lo, 0)

		H5Lo = H5Lo + ELo
		H5Hi = bit32.bor(H5Hi + EHi + H5Lo // 0x100000000, 0)
		H5Lo = bit32.bor(H5Lo, 0)

		H6Lo = H6Lo + FLo
		H6Hi = bit32.bor(H6Hi + FHi + H6Lo // 0x100000000, 0)
		H6Lo = bit32.bor(H6Lo, 0)

		H7Lo = H7Lo + GLo
		H7Hi = bit32.bor(H7Hi + GHi + H7Lo // 0x100000000, 0)
		H7Lo = bit32.bor(H7Lo, 0)

		H8Lo = H8Lo + HLo
		H8Hi = bit32.bor(H8Hi + HHi + H8Lo // 0x100000000, 0)
		H8Lo = bit32.bor(H8Lo, 0)
	end

	buffer.writeu32(DIGEST, 0, H1Hi)
	buffer.writeu32(DIGEST, 4, H1Lo)
	buffer.writeu32(DIGEST, 8, H2Hi)
	buffer.writeu32(DIGEST, 12, H2Lo)
	buffer.writeu32(DIGEST, 16, H3Hi)
	buffer.writeu32(DIGEST, 20, H3Lo)
	buffer.writeu32(DIGEST, 24, H4Hi)
	buffer.writeu32(DIGEST, 28, H4Lo)
	buffer.writeu32(DIGEST, 32, H5Hi)
	buffer.writeu32(DIGEST, 36, H5Lo)
	buffer.writeu32(DIGEST, 40, H6Hi)
	buffer.writeu32(DIGEST, 44, H6Lo)
end

local function SHA384(Message: buffer): (string, buffer)
	local Processed, Length = PreProcess(Message)
	DigestBlocks(Processed, Length)

	local H1Hi, H1Lo = buffer.readu32(DIGEST, 0), buffer.readu32(DIGEST, 4)
	local H2Hi, H2Lo = buffer.readu32(DIGEST, 8), buffer.readu32(DIGEST, 12)
	local H3Hi, H3Lo = buffer.readu32(DIGEST, 16), buffer.readu32(DIGEST, 20)
	local H4Hi, H4Lo = buffer.readu32(DIGEST, 24), buffer.readu32(DIGEST, 28)
	local H5Hi, H5Lo = buffer.readu32(DIGEST, 32), buffer.readu32(DIGEST, 36)
	local H6Hi, H6Lo = buffer.readu32(DIGEST, 40), buffer.readu32(DIGEST, 44)

	return string.format(
		"%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x",
		H1Hi, H1Lo, H2Hi, H2Lo, H3Hi, H3Lo, H4Hi, H4Lo, H5Hi, H5Lo, H6Hi, H6Lo
	), DIGEST
end

return SHA384]]></ProtectedString>
								<string name="ScriptGuid">{70C0DF76-B2F8-4FAF-8F78-5C0F6F82D9F7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SHA384</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX241049E48AFA474298FD92DFEAD04DB3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: SHA512

	Sizes:
		Digest: 64 bytes

	Return type: (string, buffer)
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Hash, HashBuffer = SHA512(Message)
--]=]

--!strict
--!optimize 2
--!native

local K_HI = {
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
	0xca273ece, 0xd186b8c7, 0xeada7dd6, 0xf57d4f7f, 0x06f067aa, 0x0a637dc5, 0x113f9804, 0x1b710b35,
	0x28db77f5, 0x32caab7b, 0x3c9ebe0a, 0x431d67c4, 0x4cc5d4be, 0x597f299c, 0x5fcb6fab, 0x6c44198c,
}

local K_LO = {
	0xd728ae22, 0x23ef65cd, 0xec4d3b2f, 0x8189dbbc, 0xf348b538, 0xb605d019, 0xaf194f9b, 0xda6d8118,
	0xa3030242, 0x45706fbe, 0x4ee4b28c, 0xd5ffb4e2, 0xf27b896f, 0x3b1696b1, 0x25c71235, 0xcf692694,
	0x9ef14ad2, 0x384f25e3, 0x8b8cd5b5, 0x77ac9c65, 0x592b0275, 0x6ea6e483, 0xbd41fbd4, 0x831153b5,
	0xee66dfab, 0x2db43210, 0x98fb213f, 0xbeef0ee4, 0x3da88fc2, 0x930aa725, 0xe003826f, 0x0a0e6e70,
	0x46d22ffc, 0x5c26c926, 0x5ac42aed, 0x9d95b3df, 0x8baf63de, 0x3c77b2a8, 0x47edaee6, 0x1482353b,
	0x4cf10364, 0xbc423001, 0xd0f89791, 0x0654be30, 0xd6ef5218, 0x5565a910, 0x5771202a, 0x32bbd1b8,
	0xb8d2d0c8, 0x5141ab53, 0xdf8eeb99, 0xe19b48a8, 0xc5c95a63, 0xe3418acb, 0x7763e373, 0xd6b2b8a3,
	0x5defb2fc, 0x43172f60, 0xa1f0ab72, 0x1a6439ec, 0x23631e28, 0xde82bde9, 0xb2c67915, 0xe372532b,
	0xea26619c, 0x21c0c207, 0xcde0eb1e, 0xee6ed178, 0x72176fba, 0xa2c898a6, 0xbef90dae, 0x131c471b,
	0x23047d84, 0x40c72493, 0x15c9bebc, 0x9c100d4c, 0xcb3e42b6, 0xfc657e2a, 0x3ad6faec, 0x4a475817,
}

local W_HI = table.create(80) :: {number}
local W_LO = table.create(80) :: {number}
local DIGEST = buffer.create(64)

local function PreProcess(Contents: buffer): (buffer, number)
	local ContentLength = buffer.len(Contents)
	local Padding = (128 - ((ContentLength + 17) % 128)) % 128
	local NewLength = ContentLength + 1 + Padding + 16

	local Result = buffer.create(NewLength)
	buffer.copy(Result, 0, Contents)
	buffer.writeu8(Result, ContentLength, 0x80)
	buffer.fill(Result, ContentLength + 1, 0, Padding + 8)

	local BitLength = ContentLength * 8
	local LengthOffset = ContentLength + 1 + Padding + 8

	for Index = 7, 0, -1 do
		buffer.writeu8(Result, LengthOffset + Index, BitLength % 256)
		BitLength = BitLength // 256
	end

	return Result, NewLength
end

local function DigestBlocks(Blocks: buffer, Length: number)
	local Hi, Lo = W_HI, W_LO
	local KHi, KLo = K_HI, K_LO

	local H1Hi, H2Hi, H3Hi, H4Hi = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a
	local H5Hi, H6Hi, H7Hi, H8Hi = 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	local H1Lo, H2Lo, H3Lo, H4Lo = 0xf3bcc908, 0x84caa73b, 0xfe94f82b, 0x5f1d36f1
	local H5Lo, H6Lo, H7Lo, H8Lo = 0xade682d1, 0x2b3e6c1f, 0xfb41bd6b, 0x137e2179

	for Offset = 0, Length - 1, 128 do
		for T = 1, 16 do
			local ByteOffset = Offset + (T - 1) * 8
			Hi[T] = bit32.byteswap(buffer.readu32(Blocks, ByteOffset))
			Lo[T] = bit32.byteswap(buffer.readu32(Blocks, ByteOffset + 4))
		end

		for T = 17, 80 do
			local P15Hi, P15Lo = Hi[T - 15], Lo[T - 15]
			local P2Hi, P2Lo = Hi[T - 2], Lo[T - 2]

			local S0Lo = bit32.bxor(bit32.rshift(P15Lo, 1) + bit32.lshift(P15Hi, 31), bit32.rshift(P15Lo, 8) + bit32.lshift(P15Hi, 24), bit32.rshift(P15Lo, 7) + bit32.lshift(P15Hi, 25))
			local S1Lo = bit32.bxor(bit32.rshift(P2Lo, 19) + bit32.lshift(P2Hi, 13), bit32.lshift(P2Lo, 3) + bit32.rshift(P2Hi, 29), bit32.rshift(P2Lo, 6) + bit32.lshift(P2Hi, 26))

			local TmpLo = Lo[T - 16] + S0Lo + Lo[T - 7] + S1Lo
			Lo[T] = bit32.bor(TmpLo, 0)
			Hi[T] = bit32.bxor(bit32.rshift(P15Hi, 1) + bit32.lshift(P15Lo, 31), bit32.rshift(P15Hi, 8) + bit32.lshift(P15Lo, 24), bit32.rshift(P15Hi, 7)) +
				bit32.bxor(bit32.rshift(P2Hi, 19) + bit32.lshift(P2Lo, 13), bit32.lshift(P2Hi, 3) + bit32.rshift(P2Lo, 29), bit32.rshift(P2Hi, 6)) +
				Hi[T - 16] + Hi[T - 7] + TmpLo // 0x100000000
		end

		local AHi, ALo = H1Hi, H1Lo
		local BHi, BLo = H2Hi, H2Lo
		local CHi, CLo = H3Hi, H3Lo
		local DHi, DLo = H4Hi, H4Lo
		local EHi, ELo = H5Hi, H5Lo
		local FHi, FLo = H6Hi, H6Lo
		local GHi, GLo = H7Hi, H7Lo
		local HHi, HLo = H8Hi, H8Lo

		for T = 1, 79, 2 do
			local Sigma1Lo = bit32.bxor(bit32.rshift(ELo, 14) + bit32.lshift(EHi, 18), bit32.rshift(ELo, 18) + bit32.lshift(EHi, 14), bit32.lshift(ELo, 23) + bit32.rshift(EHi, 9))
			local Sigma1Hi = bit32.bxor(bit32.rshift(EHi, 14) + bit32.lshift(ELo, 18), bit32.rshift(EHi, 18) + bit32.lshift(ELo, 14), bit32.lshift(EHi, 23) + bit32.rshift(ELo, 9))
			local Sigma0Lo = bit32.bxor(bit32.rshift(ALo, 28) + bit32.lshift(AHi, 4), bit32.lshift(ALo, 30) + bit32.rshift(AHi, 2), bit32.lshift(ALo, 25) + bit32.rshift(AHi, 7))
			local Sigma0Hi = bit32.bxor(bit32.rshift(AHi, 28) + bit32.lshift(ALo, 4), bit32.lshift(AHi, 30) + bit32.rshift(ALo, 2), bit32.lshift(AHi, 25) + bit32.rshift(ALo, 7))
			local ChLo = bit32.band(ELo, FLo) + bit32.band(-1 - ELo, GLo)
			local ChHi = bit32.band(EHi, FHi) + bit32.band(-1 - EHi, GHi)
			local MajLo = bit32.band(CLo, BLo) + bit32.band(ALo, bit32.bxor(CLo, BLo))
			local MajHi = bit32.band(CHi, BHi) + bit32.band(AHi, bit32.bxor(CHi, BHi))

			local T1Lo = HLo + Sigma1Lo + ChLo + KLo[T] + Lo[T]
			local T1Hi = HHi + Sigma1Hi + ChHi + KHi[T] + Hi[T] + T1Lo // 0x100000000
			T1Lo = bit32.bor(T1Lo, 0)

			HHi, HLo = GHi, GLo
			GHi, GLo = FHi, FLo
			FHi, FLo = EHi, ELo

			local ELoNew = DLo + T1Lo
			EHi = DHi + T1Hi + ELoNew // 0x100000000
			ELo = bit32.bor(ELoNew, 0)

			DHi, DLo = CHi, CLo
			CHi, CLo = BHi, BLo
			BHi, BLo = AHi, ALo

			local ALoNew = T1Lo + Sigma0Lo + MajLo
			AHi = T1Hi + Sigma0Hi + MajHi + ALoNew // 0x100000000
			ALo = bit32.bor(ALoNew, 0)

			local T2 = T + 1
			Sigma1Lo = bit32.bxor(bit32.rshift(ELo, 14) + bit32.lshift(EHi, 18), bit32.rshift(ELo, 18) + bit32.lshift(EHi, 14), bit32.lshift(ELo, 23) + bit32.rshift(EHi, 9))
			Sigma1Hi = bit32.bxor(bit32.rshift(EHi, 14) + bit32.lshift(ELo, 18), bit32.rshift(EHi, 18) + bit32.lshift(ELo, 14), bit32.lshift(EHi, 23) + bit32.rshift(ELo, 9))
			Sigma0Lo = bit32.bxor(bit32.rshift(ALo, 28) + bit32.lshift(AHi, 4), bit32.lshift(ALo, 30) + bit32.rshift(AHi, 2), bit32.lshift(ALo, 25) + bit32.rshift(AHi, 7))
			Sigma0Hi = bit32.bxor(bit32.rshift(AHi, 28) + bit32.lshift(ALo, 4), bit32.lshift(AHi, 30) + bit32.rshift(ALo, 2), bit32.lshift(AHi, 25) + bit32.rshift(ALo, 7))
			ChLo = bit32.band(ELo, FLo) + bit32.band(-1 - ELo, GLo)
			ChHi = bit32.band(EHi, FHi) + bit32.band(-1 - EHi, GHi)
			MajLo = bit32.band(CLo, BLo) + bit32.band(ALo, bit32.bxor(CLo, BLo))
			MajHi = bit32.band(CHi, BHi) + bit32.band(AHi, bit32.bxor(CHi, BHi))

			T1Lo = HLo + Sigma1Lo + ChLo + KLo[T2] + Lo[T2]
			T1Hi = HHi + Sigma1Hi + ChHi + KHi[T2] + Hi[T2] + T1Lo // 0x100000000
			T1Lo = bit32.bor(T1Lo, 0)

			HHi, HLo = GHi, GLo
			GHi, GLo = FHi, FLo
			FHi, FLo = EHi, ELo

			ELoNew = DLo + T1Lo
			EHi = DHi + T1Hi + ELoNew // 0x100000000
			ELo = bit32.bor(ELoNew, 0)

			DHi, DLo = CHi, CLo
			CHi, CLo = BHi, BLo
			BHi, BLo = AHi, ALo

			ALoNew = T1Lo + Sigma0Lo + MajLo
			AHi = T1Hi + Sigma0Hi + MajHi + ALoNew // 0x100000000
			ALo = bit32.bor(ALoNew, 0)
		end

		H1Lo = H1Lo + ALo
		H1Hi = bit32.bor(H1Hi + AHi + H1Lo // 0x100000000, 0)
		H1Lo = bit32.bor(H1Lo, 0)

		H2Lo = H2Lo + BLo
		H2Hi = bit32.bor(H2Hi + BHi + H2Lo // 0x100000000, 0)
		H2Lo = bit32.bor(H2Lo, 0)

		H3Lo = H3Lo + CLo
		H3Hi = bit32.bor(H3Hi + CHi + H3Lo // 0x100000000, 0)
		H3Lo = bit32.bor(H3Lo, 0)

		H4Lo = H4Lo + DLo
		H4Hi = bit32.bor(H4Hi + DHi + H4Lo // 0x100000000, 0)
		H4Lo = bit32.bor(H4Lo, 0)

		H5Lo = H5Lo + ELo
		H5Hi = bit32.bor(H5Hi + EHi + H5Lo // 0x100000000, 0)
		H5Lo = bit32.bor(H5Lo, 0)

		H6Lo = H6Lo + FLo
		H6Hi = bit32.bor(H6Hi + FHi + H6Lo // 0x100000000, 0)
		H6Lo = bit32.bor(H6Lo, 0)

		H7Lo = H7Lo + GLo
		H7Hi = bit32.bor(H7Hi + GHi + H7Lo // 0x100000000, 0)
		H7Lo = bit32.bor(H7Lo, 0)

		H8Lo = H8Lo + HLo
		H8Hi = bit32.bor(H8Hi + HHi + H8Lo // 0x100000000, 0)
		H8Lo = bit32.bor(H8Lo, 0)
	end

	buffer.writeu32(DIGEST, 0, H1Hi)
	buffer.writeu32(DIGEST, 4, H1Lo)
	buffer.writeu32(DIGEST, 8, H2Hi)
	buffer.writeu32(DIGEST, 12, H2Lo)
	buffer.writeu32(DIGEST, 16, H3Hi)
	buffer.writeu32(DIGEST, 20, H3Lo)
	buffer.writeu32(DIGEST, 24, H4Hi)
	buffer.writeu32(DIGEST, 28, H4Lo)
	buffer.writeu32(DIGEST, 32, H5Hi)
	buffer.writeu32(DIGEST, 36, H5Lo)
	buffer.writeu32(DIGEST, 40, H6Hi)
	buffer.writeu32(DIGEST, 44, H6Lo)
	buffer.writeu32(DIGEST, 48, H7Hi)
	buffer.writeu32(DIGEST, 52, H7Lo)
	buffer.writeu32(DIGEST, 56, H8Hi)
	buffer.writeu32(DIGEST, 60, H8Lo)
end

local function SHA512(Message: buffer): (string, buffer)
	local Processed, Length = PreProcess(Message)
	DigestBlocks(Processed, Length)

	local H1Hi, H1Lo = buffer.readu32(DIGEST, 0), buffer.readu32(DIGEST, 4)
	local H2Hi, H2Lo = buffer.readu32(DIGEST, 8), buffer.readu32(DIGEST, 12)
	local H3Hi, H3Lo = buffer.readu32(DIGEST, 16), buffer.readu32(DIGEST, 20)
	local H4Hi, H4Lo = buffer.readu32(DIGEST, 24), buffer.readu32(DIGEST, 28)
	local H5Hi, H5Lo = buffer.readu32(DIGEST, 32), buffer.readu32(DIGEST, 36)
	local H6Hi, H6Lo = buffer.readu32(DIGEST, 40), buffer.readu32(DIGEST, 44)
	local H7Hi, H7Lo = buffer.readu32(DIGEST, 48), buffer.readu32(DIGEST, 52)
	local H8Hi, H8Lo = buffer.readu32(DIGEST, 56), buffer.readu32(DIGEST, 60)

	return string.format(
		"%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x",
		H1Hi, H1Lo, H2Hi, H2Lo, H3Hi, H3Lo, H4Hi, H4Lo,
		H5Hi, H5Lo, H6Hi, H6Lo, H7Hi, H7Lo, H8Hi, H8Lo
	), DIGEST
end

return SHA512]]></ProtectedString>
								<string name="ScriptGuid">{9157A083-D02A-4C91-96AE-C1C04948B715}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SHA512</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX57CA4FA6CC8C4021AC275A5A18B3887C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Keccak/SHA-3
	
	Sizes:
		SHA3-224 Digest: 28 bytes
		SHA3-256 Digest: 32 bytes
		SHA3-384 Digest: 48 bytes
		SHA3-512 Digest: 64 bytes
		SHAKE128 Digest: variable
		SHAKE256 Digest: variable

	Return type: string
	Example usage:
		local Message = buffer.fromstring("Hello World")
		
		local Result1 = SHA3_256(Message)
		local Result2 = SHAKE128(Message, 32)
--]=]

--!strict
--!optimize 2
--!native

local SHA3 = {}

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local LOW_ROUND, HIGH_ROUND = buffer.create(96), buffer.create(96) do
	local HighFactorKeccak = 0
	local ShiftRegister = 29
	local function GetNextBit(): number
		local Result = ShiftRegister % 2
		ShiftRegister = bit32.bxor((ShiftRegister - Result) // 2, 142 * Result)

		return Result
	end

	for Index = 0, 23 do
		local LowValue = 0
		local Multiplier: number

		for _ = 1, 6 do
			Multiplier = if Multiplier then Multiplier * Multiplier * 2 else 1
			LowValue += GetNextBit() * Multiplier
		end

		local HighValue = GetNextBit() * Multiplier
		buffer.writeu32(HIGH_ROUND, Index * 4, HighValue)
		buffer.writeu32(LOW_ROUND, Index * 4, LowValue + HighValue * HighFactorKeccak)
	end
end

local LANES_LOW = buffer.create(100)
local LANES_HIGH = buffer.create(100)

local function Keccak(LanesLow: buffer, LanesHigh: buffer, InputBuffer: buffer, Offset: number, Size: number, BlockSizeInBytes: number): ()
	local QuadWordsQuantity = BlockSizeInBytes // 8
	local RCHigh, RCLow = HIGH_ROUND, LOW_ROUND

	for Position = Offset, Offset + Size - 1, BlockSizeInBytes do
		for Index = 0, (QuadWordsQuantity - 1) * 4, 4 do
			local BufferPos = Position + Index * 2

			buffer.writeu32(LanesLow, Index, bit32.bxor(
				buffer.readu32(LanesLow, Index),
				buffer.readu32(InputBuffer, BufferPos)
				))

			buffer.writeu32(LanesHigh, Index, bit32.bxor(
				buffer.readu32(LanesHigh, Index),
				buffer.readu32(InputBuffer, BufferPos + 4)
				))
		end

		local Lane01Low, Lane01High = buffer.readu32(LanesLow, 0), buffer.readu32(LanesHigh, 0)
		local Lane02Low, Lane02High = buffer.readu32(LanesLow, 4), buffer.readu32(LanesHigh, 4)
		local Lane03Low, Lane03High = buffer.readu32(LanesLow, 8), buffer.readu32(LanesHigh, 8)

		local Lane04Low, Lane04High = buffer.readu32(LanesLow, 12), buffer.readu32(LanesHigh, 12)
		local Lane05Low, Lane05High = buffer.readu32(LanesLow, 16), buffer.readu32(LanesHigh, 16)
		local Lane06Low, Lane06High = buffer.readu32(LanesLow, 20), buffer.readu32(LanesHigh, 20)

		local Lane07Low, Lane07High = buffer.readu32(LanesLow, 24), buffer.readu32(LanesHigh, 24)
		local Lane08Low, Lane08High = buffer.readu32(LanesLow, 28), buffer.readu32(LanesHigh, 28)
		local Lane09Low, Lane09High = buffer.readu32(LanesLow, 32), buffer.readu32(LanesHigh, 32)

		local Lane10Low, Lane10High = buffer.readu32(LanesLow, 36), buffer.readu32(LanesHigh, 36)
		local Lane11Low, Lane11High = buffer.readu32(LanesLow, 40), buffer.readu32(LanesHigh, 40)
		local Lane12Low, Lane12High = buffer.readu32(LanesLow, 44), buffer.readu32(LanesHigh, 44)

		local Lane13Low, Lane13High = buffer.readu32(LanesLow, 48), buffer.readu32(LanesHigh, 48)
		local Lane14Low, Lane14High = buffer.readu32(LanesLow, 52), buffer.readu32(LanesHigh, 52)
		local Lane15Low, Lane15High = buffer.readu32(LanesLow, 56), buffer.readu32(LanesHigh, 56)

		local Lane16Low, Lane16High = buffer.readu32(LanesLow, 60), buffer.readu32(LanesHigh, 60)
		local Lane17Low, Lane17High = buffer.readu32(LanesLow, 64), buffer.readu32(LanesHigh, 64)
		local Lane18Low, Lane18High = buffer.readu32(LanesLow, 68), buffer.readu32(LanesHigh, 68)

		local Lane19Low, Lane19High = buffer.readu32(LanesLow, 72), buffer.readu32(LanesHigh, 72)
		local Lane20Low, Lane20High = buffer.readu32(LanesLow, 76), buffer.readu32(LanesHigh, 76)
		local Lane21Low, Lane21High = buffer.readu32(LanesLow, 80), buffer.readu32(LanesHigh, 80)

		local Lane22Low, Lane22High = buffer.readu32(LanesLow, 84), buffer.readu32(LanesHigh, 84)
		local Lane23Low, Lane23High = buffer.readu32(LanesLow, 88), buffer.readu32(LanesHigh, 88)
		local Lane24Low, Lane24High = buffer.readu32(LanesLow, 92), buffer.readu32(LanesHigh, 92)

		local Lane25Low, Lane25High = buffer.readu32(LanesLow, 96), buffer.readu32(LanesHigh, 96)

		for RoundIndex = 0, 92, 4 do
			local Column1Low, Column1High = bit32.bxor(Lane01Low, Lane06Low, Lane11Low, Lane16Low, Lane21Low), bit32.bxor(Lane01High, Lane06High, Lane11High, Lane16High, Lane21High)
			local Column2Low, Column2High = bit32.bxor(Lane02Low, Lane07Low, Lane12Low, Lane17Low, Lane22Low), bit32.bxor(Lane02High, Lane07High, Lane12High, Lane17High, Lane22High)
			local Column3Low, Column3High = bit32.bxor(Lane03Low, Lane08Low, Lane13Low, Lane18Low, Lane23Low), bit32.bxor(Lane03High, Lane08High, Lane13High, Lane18High, Lane23High)
			local Column4Low, Column4High = bit32.bxor(Lane04Low, Lane09Low, Lane14Low, Lane19Low, Lane24Low), bit32.bxor(Lane04High, Lane09High, Lane14High, Lane19High, Lane24High)
			local Column5Low, Column5High = bit32.bxor(Lane05Low, Lane10Low, Lane15Low, Lane20Low, Lane25Low), bit32.bxor(Lane05High, Lane10High, Lane15High, Lane20High, Lane25High)

			local DeltaLow, DeltaHigh = bit32.bxor(Column1Low, Column3Low * 2 + Column3High // 2147483648), bit32.bxor(Column1High, Column3High * 2 + Column3Low // 2147483648)
			local Temp0Low, Temp0High = bit32.bxor(DeltaLow, Lane02Low), bit32.bxor(DeltaHigh, Lane02High)
			local Temp1Low, Temp1High = bit32.bxor(DeltaLow, Lane07Low), bit32.bxor(DeltaHigh, Lane07High)
			local Temp2Low, Temp2High = bit32.bxor(DeltaLow, Lane12Low), bit32.bxor(DeltaHigh, Lane12High)
			local Temp3Low, Temp3High = bit32.bxor(DeltaLow, Lane17Low), bit32.bxor(DeltaHigh, Lane17High)
			local Temp4Low, Temp4High = bit32.bxor(DeltaLow, Lane22Low), bit32.bxor(DeltaHigh, Lane22High)

			Lane02Low = Temp1Low // 1048576 + (Temp1High * 4096); Lane02High = Temp1High // 1048576 + (Temp1Low * 4096)
			Lane07Low = Temp3Low // 524288 + (Temp3High * 8192); Lane07High = Temp3High // 524288 + (Temp3Low * 8192)
			Lane12Low = Temp0Low * 2 + Temp0High // 2147483648; Lane12High = Temp0High * 2 + Temp0Low // 2147483648
			Lane17Low = Temp2Low * 1024 + Temp2High // 4194304; Lane17High = Temp2High * 1024 + Temp2Low // 4194304
			Lane22Low = Temp4Low * 4 + Temp4High // 1073741824; Lane22High = Temp4High * 4 + Temp4Low // 1073741824

			DeltaLow = bit32.bxor(Column2Low, Column4Low * 2 + Column4High // 2147483648); DeltaHigh = bit32.bxor(Column2High, Column4High * 2 + Column4Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane03Low); Temp0High = bit32.bxor(DeltaHigh, Lane03High)
			Temp1Low = bit32.bxor(DeltaLow, Lane08Low); Temp1High = bit32.bxor(DeltaHigh, Lane08High)
			Temp2Low = bit32.bxor(DeltaLow, Lane13Low); Temp2High = bit32.bxor(DeltaHigh, Lane13High)
			Temp3Low = bit32.bxor(DeltaLow, Lane18Low); Temp3High = bit32.bxor(DeltaHigh, Lane18High)
			Temp4Low = bit32.bxor(DeltaLow, Lane23Low); Temp4High = bit32.bxor(DeltaHigh, Lane23High)

			Lane03Low = Temp2Low // 2097152 + (Temp2High * 2048); Lane03High = Temp2High // 2097152 + (Temp2Low * 2048)
			Lane08Low = Temp4Low // 8 + bit32.bor(Temp4High * 536870912, 0); Lane08High = Temp4High // 8 + bit32.bor(Temp4Low * 536870912, 0)
			Lane13Low = Temp1Low * 64 + Temp1High // 67108864; Lane13High = Temp1High * 64 + Temp1Low // 67108864
			Lane18Low = (Temp3Low * 32768) + Temp3High // 131072; Lane18High = (Temp3High * 32768) + Temp3Low // 131072
			Lane23Low = Temp0Low // 4 + bit32.bor(Temp0High * 1073741824, 0); Lane23High = Temp0High // 4 + bit32.bor(Temp0Low * 1073741824, 0)

			DeltaLow = bit32.bxor(Column3Low, Column5Low * 2 + Column5High // 2147483648); DeltaHigh = bit32.bxor(Column3High, Column5High * 2 + Column5Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane04Low); Temp0High = bit32.bxor(DeltaHigh, Lane04High)
			Temp1Low = bit32.bxor(DeltaLow, Lane09Low); Temp1High = bit32.bxor(DeltaHigh, Lane09High)
			Temp2Low = bit32.bxor(DeltaLow, Lane14Low); Temp2High = bit32.bxor(DeltaHigh, Lane14High)
			Temp3Low = bit32.bxor(DeltaLow, Lane19Low); Temp3High = bit32.bxor(DeltaHigh, Lane19High)
			Temp4Low = bit32.bxor(DeltaLow, Lane24Low); Temp4High = bit32.bxor(DeltaHigh, Lane24High)

			Lane04Low = bit32.bor(Temp3Low * 2097152, 0) + Temp3High // 2048; Lane04High = bit32.bor(Temp3High * 2097152, 0) + Temp3Low // 2048
			Lane09Low = bit32.bor(Temp0Low * 268435456, 0) + Temp0High // 16; Lane09High = bit32.bor(Temp0High * 268435456, 0) + Temp0Low // 16
			Lane14Low = bit32.bor(Temp2Low * 33554432, 0) + Temp2High // 128; Lane14High = bit32.bor(Temp2High * 33554432, 0) + Temp2Low // 128
			Lane19Low = Temp4Low // 256 + bit32.bor(Temp4High * 16777216, 0); Lane19High = Temp4High // 256 + bit32.bor(Temp4Low * 16777216, 0)
			Lane24Low = Temp1Low // 512 + bit32.bor(Temp1High * 8388608, 0); Lane24High = Temp1High // 512 + bit32.bor(Temp1Low * 8388608, 0)
			DeltaLow = bit32.bxor(Column4Low, Column1Low * 2 + Column1High // 2147483648); DeltaHigh = bit32.bxor(Column4High, Column1High * 2 + Column1Low // 2147483648)

			Temp0Low = bit32.bxor(DeltaLow, Lane05Low); Temp0High = bit32.bxor(DeltaHigh, Lane05High)
			Temp1Low = bit32.bxor(DeltaLow, Lane10Low); Temp1High = bit32.bxor(DeltaHigh, Lane10High)
			Temp2Low = bit32.bxor(DeltaLow, Lane15Low); Temp2High = bit32.bxor(DeltaHigh, Lane15High)
			Temp3Low = bit32.bxor(DeltaLow, Lane20Low); Temp3High = bit32.bxor(DeltaHigh, Lane20High)
			Temp4Low = bit32.bxor(DeltaLow, Lane25Low); Temp4High = bit32.bxor(DeltaHigh, Lane25High)

			Lane05Low = (Temp4Low * 16384) + Temp4High // 262144; Lane05High = (Temp4High * 16384) + Temp4Low // 262144
			Lane10Low = bit32.bor(Temp1Low * 1048576, 0) + Temp1High // 4096; Lane10High = bit32.bor(Temp1High * 1048576, 0) + Temp1Low // 4096
			Lane15Low = Temp3Low * 256 + Temp3High // 16777216; Lane15High = Temp3High * 256 + Temp3Low // 16777216
			Lane20Low = bit32.bor(Temp0Low * 134217728, 0) + Temp0High // 32; Lane20High = bit32.bor(Temp0High * 134217728, 0) + Temp0Low // 32
			Lane25Low = Temp2Low // 33554432 + Temp2High * 128; Lane25High = Temp2High // 33554432 + Temp2Low * 128

			DeltaLow = bit32.bxor(Column5Low, Column2Low * 2 + Column2High // 2147483648); DeltaHigh = bit32.bxor(Column5High, Column2High * 2 + Column2Low // 2147483648)
			Temp1Low = bit32.bxor(DeltaLow, Lane06Low); Temp1High = bit32.bxor(DeltaHigh, Lane06High)
			Temp2Low = bit32.bxor(DeltaLow, Lane11Low); Temp2High = bit32.bxor(DeltaHigh, Lane11High)
			Temp3Low = bit32.bxor(DeltaLow, Lane16Low); Temp3High = bit32.bxor(DeltaHigh, Lane16High)
			Temp4Low = bit32.bxor(DeltaLow, Lane21Low); Temp4High = bit32.bxor(DeltaHigh, Lane21High)
			Lane06Low = Temp2Low * 8 + Temp2High // 536870912; Lane06High = Temp2High * 8 + Temp2Low // 536870912
			Lane11Low = (Temp4Low * 262144) + Temp4High // 16384; Lane11High = (Temp4High * 262144) + Temp4Low // 16384
			Lane16Low = Temp1Low // 268435456 + Temp1High * 16; Lane16High = Temp1High // 268435456 + Temp1Low * 16
			Lane21Low = Temp3Low // 8388608 + Temp3High * 512; Lane21High = Temp3High // 8388608 + Temp3Low * 512
			Lane01Low = bit32.bxor(DeltaLow, Lane01Low); Lane01High = bit32.bxor(DeltaHigh, Lane01High)

			Lane01Low, Lane02Low, Lane03Low, Lane04Low, Lane05Low = bit32.bxor(Lane01Low, bit32.band(-1 - Lane02Low, Lane03Low)), bit32.bxor(Lane02Low, bit32.band(-1 - Lane03Low, Lane04Low)), bit32.bxor(Lane03Low, bit32.band(-1 - Lane04Low, Lane05Low)), bit32.bxor(Lane04Low, bit32.band(-1 - Lane05Low, Lane01Low)), bit32.bxor(Lane05Low, bit32.band(-1 - Lane01Low, Lane02Low)) :: number
			Lane01High, Lane02High, Lane03High, Lane04High, Lane05High = bit32.bxor(Lane01High, bit32.band(-1 - Lane02High, Lane03High)), bit32.bxor(Lane02High, bit32.band(-1 - Lane03High, Lane04High)), bit32.bxor(Lane03High, bit32.band(-1 - Lane04High, Lane05High)), bit32.bxor(Lane04High, bit32.band(-1 - Lane05High, Lane01High)), bit32.bxor(Lane05High, bit32.band(-1 - Lane01High, Lane02High)) :: number
			Lane06Low, Lane07Low, Lane08Low, Lane09Low, Lane10Low = bit32.bxor(Lane09Low, bit32.band(-1 - Lane10Low, Lane06Low)), bit32.bxor(Lane10Low, bit32.band(-1 - Lane06Low, Lane07Low)), bit32.bxor(Lane06Low, bit32.band(-1 - Lane07Low, Lane08Low)), bit32.bxor(Lane07Low, bit32.band(-1 - Lane08Low, Lane09Low)), bit32.bxor(Lane08Low, bit32.band(-1 - Lane09Low, Lane10Low)) :: number
			Lane06High, Lane07High, Lane08High, Lane09High, Lane10High = bit32.bxor(Lane09High, bit32.band(-1 - Lane10High, Lane06High)), bit32.bxor(Lane10High, bit32.band(-1 - Lane06High, Lane07High)), bit32.bxor(Lane06High, bit32.band(-1 - Lane07High, Lane08High)), bit32.bxor(Lane07High, bit32.band(-1 - Lane08High, Lane09High)), bit32.bxor(Lane08High, bit32.band(-1 - Lane09High, Lane10High)) :: number
			Lane11Low, Lane12Low, Lane13Low, Lane14Low, Lane15Low = bit32.bxor(Lane12Low, bit32.band(-1 - Lane13Low, Lane14Low)), bit32.bxor(Lane13Low, bit32.band(-1 - Lane14Low, Lane15Low)), bit32.bxor(Lane14Low, bit32.band(-1 - Lane15Low, Lane11Low)), bit32.bxor(Lane15Low, bit32.band(-1 - Lane11Low, Lane12Low)), bit32.bxor(Lane11Low, bit32.band(-1 - Lane12Low, Lane13Low)) :: number
			Lane11High, Lane12High, Lane13High, Lane14High, Lane15High = bit32.bxor(Lane12High, bit32.band(-1 - Lane13High, Lane14High)), bit32.bxor(Lane13High, bit32.band(-1 - Lane14High, Lane15High)), bit32.bxor(Lane14High, bit32.band(-1 - Lane15High, Lane11High)), bit32.bxor(Lane15High, bit32.band(-1 - Lane11High, Lane12High)), bit32.bxor(Lane11High, bit32.band(-1 - Lane12High, Lane13High)) :: number
			Lane16Low, Lane17Low, Lane18Low, Lane19Low, Lane20Low = bit32.bxor(Lane20Low, bit32.band(-1 - Lane16Low, Lane17Low)), bit32.bxor(Lane16Low, bit32.band(-1 - Lane17Low, Lane18Low)), bit32.bxor(Lane17Low, bit32.band(-1 - Lane18Low, Lane19Low)), bit32.bxor(Lane18Low, bit32.band(-1 - Lane19Low, Lane20Low)), bit32.bxor(Lane19Low, bit32.band(-1 - Lane20Low, Lane16Low)) :: number
			Lane16High, Lane17High, Lane18High, Lane19High, Lane20High = bit32.bxor(Lane20High, bit32.band(-1 - Lane16High, Lane17High)), bit32.bxor(Lane16High, bit32.band(-1 - Lane17High, Lane18High)), bit32.bxor(Lane17High, bit32.band(-1 - Lane18High, Lane19High)), bit32.bxor(Lane18High, bit32.band(-1 - Lane19High, Lane20High)), bit32.bxor(Lane19High, bit32.band(-1 - Lane20High, Lane16High)) :: number
			Lane21Low, Lane22Low, Lane23Low, Lane24Low, Lane25Low = bit32.bxor(Lane23Low, bit32.band(-1 - Lane24Low, Lane25Low)), bit32.bxor(Lane24Low, bit32.band(-1 - Lane25Low, Lane21Low)), bit32.bxor(Lane25Low, bit32.band(-1 - Lane21Low, Lane22Low)), bit32.bxor(Lane21Low, bit32.band(-1 - Lane22Low, Lane23Low)), bit32.bxor(Lane22Low, bit32.band(-1 - Lane23Low, Lane24Low)) :: number
			Lane21High, Lane22High, Lane23High, Lane24High, Lane25High = bit32.bxor(Lane23High, bit32.band(-1 - Lane24High, Lane25High)), bit32.bxor(Lane24High, bit32.band(-1 - Lane25High, Lane21High)), bit32.bxor(Lane25High, bit32.band(-1 - Lane21High, Lane22High)), bit32.bxor(Lane21High, bit32.band(-1 - Lane22High, Lane23High)), bit32.bxor(Lane22High, bit32.band(-1 - Lane23High, Lane24High)) :: number

			Lane01Low = bit32.bxor(Lane01Low, buffer.readu32(RCLow, RoundIndex))
			Lane01High = bit32.bxor(Lane01High, buffer.readu32(RCHigh, RoundIndex))
		end

		buffer.writeu32(LanesLow, 0, Lane01Low); buffer.writeu32(LanesHigh, 0, Lane01High)
		buffer.writeu32(LanesLow, 4, Lane02Low); buffer.writeu32(LanesHigh, 4, Lane02High)
		buffer.writeu32(LanesLow, 8, Lane03Low); buffer.writeu32(LanesHigh, 8, Lane03High)
		buffer.writeu32(LanesLow, 12, Lane04Low); buffer.writeu32(LanesHigh, 12, Lane04High)
		buffer.writeu32(LanesLow, 16, Lane05Low); buffer.writeu32(LanesHigh, 16, Lane05High)
		buffer.writeu32(LanesLow, 20, Lane06Low); buffer.writeu32(LanesHigh, 20, Lane06High)
		buffer.writeu32(LanesLow, 24, Lane07Low); buffer.writeu32(LanesHigh, 24, Lane07High)
		buffer.writeu32(LanesLow, 28, Lane08Low); buffer.writeu32(LanesHigh, 28, Lane08High)
		buffer.writeu32(LanesLow, 32, Lane09Low); buffer.writeu32(LanesHigh, 32, Lane09High)
		buffer.writeu32(LanesLow, 36, Lane10Low); buffer.writeu32(LanesHigh, 36, Lane10High)
		buffer.writeu32(LanesLow, 40, Lane11Low); buffer.writeu32(LanesHigh, 40, Lane11High)
		buffer.writeu32(LanesLow, 44, Lane12Low); buffer.writeu32(LanesHigh, 44, Lane12High)
		buffer.writeu32(LanesLow, 48, Lane13Low); buffer.writeu32(LanesHigh, 48, Lane13High)
		buffer.writeu32(LanesLow, 52, Lane14Low); buffer.writeu32(LanesHigh, 52, Lane14High)
		buffer.writeu32(LanesLow, 56, Lane15Low); buffer.writeu32(LanesHigh, 56, Lane15High)
		buffer.writeu32(LanesLow, 60, Lane16Low); buffer.writeu32(LanesHigh, 60, Lane16High)
		buffer.writeu32(LanesLow, 64, Lane17Low); buffer.writeu32(LanesHigh, 64, Lane17High)
		buffer.writeu32(LanesLow, 68, Lane18Low); buffer.writeu32(LanesHigh, 68, Lane18High)
		buffer.writeu32(LanesLow, 72, Lane19Low); buffer.writeu32(LanesHigh, 72, Lane19High)
		buffer.writeu32(LanesLow, 76, Lane20Low); buffer.writeu32(LanesHigh, 76, Lane20High)
		buffer.writeu32(LanesLow, 80, Lane21Low); buffer.writeu32(LanesHigh, 80, Lane21High)
		buffer.writeu32(LanesLow, 84, Lane22Low); buffer.writeu32(LanesHigh, 84, Lane22High)
		buffer.writeu32(LanesLow, 88, Lane23Low); buffer.writeu32(LanesHigh, 88, Lane23High)
		buffer.writeu32(LanesLow, 92, Lane24Low); buffer.writeu32(LanesHigh, 92, Lane24High)
		buffer.writeu32(LanesLow, 96, Lane25Low); buffer.writeu32(LanesHigh, 96, Lane25High)
	end
end

local function ProcessSponge(Message: buffer, CapacityBits: number, OutputBytes: number, DomainSeparator: number): (string, buffer)
	local RateBytes = (1600 - CapacityBits) // 8
	buffer.fill(LANES_LOW, 0, 0, 100)
	buffer.fill(LANES_HIGH, 0, 0, 100)

	local LanesLow = LANES_LOW
	local LanesHigh = LANES_HIGH

	local MessageLength: number = buffer.len(Message)
	local PaddedLength: number = MessageLength + 1

	local Remainder = PaddedLength % RateBytes
	if Remainder ~= 0 then
		PaddedLength += (RateBytes - Remainder)
	end

	local PaddedMessage = buffer.create(PaddedLength)

	if MessageLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
	end

	if PaddedLength - MessageLength == 1 then
		buffer.writeu8(PaddedMessage, MessageLength, bit32.bor(DomainSeparator, 0x80))
	else
		buffer.writeu8(PaddedMessage, MessageLength, DomainSeparator)
		if PaddedLength - MessageLength > 2 then
			buffer.fill(PaddedMessage, MessageLength + 1, 0, PaddedLength - MessageLength - 2)
		end
		buffer.writeu8(PaddedMessage, PaddedLength - 1, 0x80)
	end

	Keccak(LanesLow, LanesHigh, PaddedMessage, 0, PaddedLength, RateBytes)

	local Output = buffer.create(OutputBytes)
	local Length = buffer.len(Output)
	local Hex = buffer.create(Length * 2)

	local Lookup = ENCODE_LOOKUP

	local Leftover = Length % 8
	local HexCursor = 0
	local OutputOffset = 0

	local ZeroBuffer = buffer.create(RateBytes)
	while OutputOffset < OutputBytes do
		local BytesThisRound = math.min(RateBytes, OutputBytes - OutputOffset)

		for ByteIndex = 0, BytesThisRound - 1 do
			local AbsoluteIndex = OutputOffset + ByteIndex
			if AbsoluteIndex < OutputBytes then
				local Lane = ByteIndex // 8
				local ByteInLane = ByteIndex % 8
				local LaneOffset = Lane * 4

				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), ByteInLane * 8, 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), (ByteInLane - 4) * 8, 8)
				end
				buffer.writeu8(Output, AbsoluteIndex, Value)
			end
		end

		OutputOffset += BytesThisRound

		if OutputOffset < OutputBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
		end
	end

	for Index = 0, Length - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Output, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = Length - Leftover, Length - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Output, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end
	
	return buffer.tostring(Hex), Output
end

function SHA3.SHA3_224(Message: buffer): (string, buffer)
	return ProcessSponge(Message, 448, 28, 0x06)
end

function SHA3.SHA3_256(Message: buffer): (string, buffer)
	return ProcessSponge(Message, 512, 32, 0x06)
end

function SHA3.SHA3_384(Message: buffer): (string, buffer)
	return ProcessSponge(Message, 768, 48, 0x06)
end

function SHA3.SHA3_512(Message: buffer): (string, buffer)
	return ProcessSponge(Message, 1024, 64, 0x06)
end

function SHA3.SHAKE128(Message: buffer, OutputBytes: number): (string, buffer)
	return ProcessSponge(Message, 256, OutputBytes, 0x1F)
end

function SHA3.SHAKE256(Message: buffer, OutputBytes: number): (string, buffer)
	return ProcessSponge(Message, 512, OutputBytes, 0x1F)
end

return SHA3]]></ProtectedString>
							<string name="ScriptGuid">{3EC4F208-49AA-4D14-8AC6-A47A583434E5}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA3</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0DBF074CF20A4923AB09A11F34911675">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: XXHash32
	
	 WARNING: XXHash32 wasn't designed with cryptographic security in mind!
	Only use for non-security purposes. For security, use SHA256 or higher. 
	
	Return type: number
	Example usage:
		local Message = buffer.fromstring("Hello World")

		--------Usage Case 1--------
		local Result = XXHash32(Message)
		
		--------Usage Case 2--------
		local Seed = 0xDEADBEEF
		local Result = XXHash32(Message, Seed)
--]=]

--!strict
--!optimize 2
--!native

local function XXH32(Message: buffer, Seed: number?): number
	local PRIME_1, PRIME_1_HIGH, PRIME_1_LOW = 0x9e3779B1, 40503, 31153
	local PRIME_2, PRIME_2_HIGH, PRIME_2_LOW = 0x85ebca77, 34283, 51831
	local PRIME_3_HIGH, PRIME_3_LOW = 49842, 44605
	local PRIME_4_HIGH, PRIME_4_LOW = 10196, 60207
	local PRIME_5, PRIME_5_HIGH, PRIME_5_LOW = 0x165667b1, 5718, 26545

	local UsedSeed = Seed or 0
	local MessageLength = buffer.len(Message)
	local Digest: number
	local CurrentOffset = 0

	if MessageLength >= 16 then
		local Accumulator1 = UsedSeed + PRIME_1 + PRIME_2
		local Accumulator2 = UsedSeed + PRIME_2
		local Accumulator3 = UsedSeed
		local Accumulator4 = UsedSeed - PRIME_1

		while CurrentOffset <= MessageLength - 16 do
			local Word1 = buffer.readu32(Message, CurrentOffset)
			local Word2 = buffer.readu32(Message, CurrentOffset + 4)
			local Word3 = buffer.readu32(Message, CurrentOffset + 8)
			local Word4 = buffer.readu32(Message, CurrentOffset + 12)

			local AHigh1, ALow1 = bit32.rshift(Word1, 16), bit32.band(Word1, 65535)
			local Mult1 = bit32.lshift((AHigh1 * PRIME_2_LOW) + (ALow1 * PRIME_2_HIGH), 16) + (ALow1 * PRIME_2_LOW)

			local Temp1 = bit32.lrotate(Accumulator1 + Mult1, 13)
			local AHigh1_2, ALow1_2 = bit32.rshift(Temp1, 16), bit32.band(Temp1, 65535)
			Accumulator1 = bit32.lshift((AHigh1_2 * PRIME_1_LOW) + (ALow1_2 * PRIME_1_HIGH), 16) + (ALow1_2 * PRIME_1_LOW)

			local AHigh2, ALow2 = bit32.rshift(Word2, 16), bit32.band(Word2, 65535)
			local Mult2 = bit32.lshift((AHigh2 * PRIME_2_LOW) + (ALow2 * PRIME_2_HIGH), 16) + (ALow2 * PRIME_2_LOW)

			local Temp2 = bit32.lrotate(Accumulator2 + Mult2, 13)
			local AHigh2_2, ALow2_2 = bit32.rshift(Temp2, 16), bit32.band(Temp2, 65535)
			Accumulator2 = bit32.lshift((AHigh2_2 * PRIME_1_LOW) + (ALow2_2 * PRIME_1_HIGH), 16) + (ALow2_2 * PRIME_1_LOW)

			local AHigh3, ALow3 = bit32.rshift(Word3, 16), bit32.band(Word3, 65535)
			local Mult3 = bit32.lshift((AHigh3 * PRIME_2_LOW) + (ALow3 * PRIME_2_HIGH), 16) + (ALow3 * PRIME_2_LOW)

			local Temp3 = bit32.lrotate(Accumulator3 + Mult3, 13)
			local AHigh3_2, ALow3_2 = bit32.rshift(Temp3, 16), bit32.band(Temp3, 65535)
			Accumulator3 = bit32.lshift((AHigh3_2 * PRIME_1_LOW) + (ALow3_2 * PRIME_1_HIGH), 16) + (ALow3_2 * PRIME_1_LOW)

			local AHigh4, ALow4 = bit32.rshift(Word4, 16), bit32.band(Word4, 65535)
			local Mult4 = bit32.lshift((AHigh4 * PRIME_2_LOW) + (ALow4 * PRIME_2_HIGH), 16) + (ALow4 * PRIME_2_LOW)

			local Temp4 = bit32.lrotate(Accumulator4 + Mult4, 13)
			local AHigh4_2, ALow4_2 = bit32.rshift(Temp4, 16), bit32.band(Temp4, 65535)
			Accumulator4 = bit32.lshift((AHigh4_2 * PRIME_1_LOW) + (ALow4_2 * PRIME_1_HIGH), 16) + (ALow4_2 * PRIME_1_LOW)

			CurrentOffset += 16
		end

		Digest = bit32.lrotate(Accumulator1, 1) + bit32.lrotate(Accumulator2, 7) + bit32.lrotate(Accumulator3, 12) + bit32.lrotate(Accumulator4, 18)
	else
		Digest = UsedSeed + PRIME_5
	end

	Digest += MessageLength

	while CurrentOffset <= MessageLength - 4 do
		if CurrentOffset + 4 <= buffer.len(Message) then
			local Word = buffer.readu32(Message, CurrentOffset)

			local AHigh_w, ALow_w = bit32.rshift(Word, 16), bit32.band(Word, 65535)
			local Mult_w = bit32.lshift((AHigh_w * PRIME_3_LOW) + (ALow_w * PRIME_3_HIGH), 16) + (ALow_w * PRIME_3_LOW)

			Digest += Mult_w

			local Rotated = bit32.lrotate(Digest, 17)
			local AHigh_r, ALow_r = bit32.rshift(Rotated, 16), bit32.band(Rotated, 65535)
			Digest = bit32.lshift((AHigh_r * PRIME_4_LOW) + (ALow_r * PRIME_4_HIGH), 16) + (ALow_r * PRIME_4_LOW)
		end
		CurrentOffset += 4
	end

	while CurrentOffset < MessageLength do
		if CurrentOffset < buffer.len(Message) then
			local ByteValue = buffer.readu8(Message, CurrentOffset)

			local AHigh_b, ALow_b = bit32.rshift(ByteValue, 16), bit32.band(ByteValue, 65535)
			local Mult_b = bit32.lshift((AHigh_b * PRIME_5_LOW) + (ALow_b * PRIME_5_HIGH), 16) + (ALow_b * PRIME_5_LOW)

			Digest += Mult_b

			local Rotated_b = bit32.lrotate(Digest, 11)
			local AHigh_rb, ALow_rb = bit32.rshift(Rotated_b, 16), bit32.band(Rotated_b, 65535)
			Digest = bit32.lshift((AHigh_rb * PRIME_1_LOW) + (ALow_rb * PRIME_1_HIGH), 16) + (ALow_rb * PRIME_1_LOW)
		end
		CurrentOffset += 1
	end

	local XorResult1 = bit32.bxor(Digest, bit32.rshift(Digest, 15))
	local AHigh_f1, ALow_f1 = bit32.rshift(XorResult1, 16), bit32.band(XorResult1, 65535)
	Digest = bit32.lshift((AHigh_f1 * PRIME_2_LOW) + (ALow_f1 * PRIME_2_HIGH), 16) + (ALow_f1 * PRIME_2_LOW)

	local XorResult2 = bit32.bxor(Digest, bit32.rshift(Digest, 13))
	local AHigh_f2, ALow_f2 = bit32.rshift(XorResult2, 16), bit32.band(XorResult2, 65535)
	Digest = bit32.lshift((AHigh_f2 * PRIME_3_LOW) + (ALow_f2 * PRIME_3_HIGH), 16) + (ALow_f2 * PRIME_3_LOW)

	return bit32.bxor(Digest, bit32.rshift(Digest, 16))
end

return XXH32]]></ProtectedString>
							<string name="ScriptGuid">{2FAD0676-C07E-41F7-B4B5-63ADDC019D90}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">XXH32</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB41C4AF591C34A24BF709CC8A01B6657">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: KMAC (Keccak Message Authentication Code)
	
	KMAC128 and KMAC256 are keyed hash functions based on cSHAKE128 and cSHAKE256.
	They give variable length output and strong authentication.
	
	Unlike SHAKE and cSHAKE, changing the output length generates a new,
	unrelated output. Both variants support up to 256 bits of security strength.
	
	Key Derivation Usage:
		For key derivation, use information related to the derived keying material
		as input data. Include identities and optionally a nonce.
	
	Return type: (string, buffer)
	Example usage:
		local Key = buffer.fromstring("my-secret-key")
		local Message = buffer.fromstring("Hello World")
		local Output = buffer.create(32)
		
		-- KMAC128 with 32-byte output
		local Hex, Digest = KMAC128(Message, Key, Output, buffer.create(0))
		
		-- KMAC256 with custom string
		local Hex2, Digest2 = KMAC256(Message, Key, Output, buffer.fromstring("super-code"))
--]=]

--!strict
--!optimize 2
--!native

local KMAC = {}

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local LOW_ROUND, HIGH_ROUND = buffer.create(96), buffer.create(96) do
	local HighFactorKeccak = 0
	local ShiftRegister = 29
	local function GetNextBit(): number
		local Result = ShiftRegister % 2
		ShiftRegister = bit32.bxor((ShiftRegister - Result) // 2, 142 * Result)

		return Result
	end

	for Index = 0, 23 do
		local LowValue = 0
		local Multiplier: number

		for _ = 1, 6 do
			Multiplier = if Multiplier then Multiplier * Multiplier * 2 else 1
			LowValue += GetNextBit() * Multiplier
		end

		local HighValue = GetNextBit() * Multiplier
		buffer.writeu32(HIGH_ROUND, Index * 4, HighValue)
		buffer.writeu32(LOW_ROUND, Index * 4, LowValue + HighValue * HighFactorKeccak)
	end
end

local LANES_LOW = buffer.create(100)
local LANES_HIGH = buffer.create(100)
local FUNCTION_NAME = buffer.fromstring("KMAC")

local function Keccak(LanesLow: buffer, LanesHigh: buffer, InputBuffer: buffer, Offset: number, Size: number, BlockSizeInBytes: number): ()
	local QuadWordsQuantity = BlockSizeInBytes // 8
	local RCHigh, RCLow = HIGH_ROUND, LOW_ROUND

	for Position = Offset, Offset + Size - 1, BlockSizeInBytes do
		for Index = 0, (QuadWordsQuantity - 1) * 4, 4 do
			local BufferPos = Position + Index * 2

			buffer.writeu32(LanesLow, Index, bit32.bxor(
				buffer.readu32(LanesLow, Index),
				buffer.readu32(InputBuffer, BufferPos)
				))

			buffer.writeu32(LanesHigh, Index, bit32.bxor(
				buffer.readu32(LanesHigh, Index),
				buffer.readu32(InputBuffer, BufferPos + 4)
				))
		end

		local Lane01Low, Lane01High = buffer.readu32(LanesLow, 0), buffer.readu32(LanesHigh, 0)
		local Lane02Low, Lane02High = buffer.readu32(LanesLow, 4), buffer.readu32(LanesHigh, 4)
		local Lane03Low, Lane03High = buffer.readu32(LanesLow, 8), buffer.readu32(LanesHigh, 8)

		local Lane04Low, Lane04High = buffer.readu32(LanesLow, 12), buffer.readu32(LanesHigh, 12)
		local Lane05Low, Lane05High = buffer.readu32(LanesLow, 16), buffer.readu32(LanesHigh, 16)
		local Lane06Low, Lane06High = buffer.readu32(LanesLow, 20), buffer.readu32(LanesHigh, 20)

		local Lane07Low, Lane07High = buffer.readu32(LanesLow, 24), buffer.readu32(LanesHigh, 24)
		local Lane08Low, Lane08High = buffer.readu32(LanesLow, 28), buffer.readu32(LanesHigh, 28)
		local Lane09Low, Lane09High = buffer.readu32(LanesLow, 32), buffer.readu32(LanesHigh, 32)

		local Lane10Low, Lane10High = buffer.readu32(LanesLow, 36), buffer.readu32(LanesHigh, 36)
		local Lane11Low, Lane11High = buffer.readu32(LanesLow, 40), buffer.readu32(LanesHigh, 40)
		local Lane12Low, Lane12High = buffer.readu32(LanesLow, 44), buffer.readu32(LanesHigh, 44)

		local Lane13Low, Lane13High = buffer.readu32(LanesLow, 48), buffer.readu32(LanesHigh, 48)
		local Lane14Low, Lane14High = buffer.readu32(LanesLow, 52), buffer.readu32(LanesHigh, 52)
		local Lane15Low, Lane15High = buffer.readu32(LanesLow, 56), buffer.readu32(LanesHigh, 56)

		local Lane16Low, Lane16High = buffer.readu32(LanesLow, 60), buffer.readu32(LanesHigh, 60)
		local Lane17Low, Lane17High = buffer.readu32(LanesLow, 64), buffer.readu32(LanesHigh, 64)
		local Lane18Low, Lane18High = buffer.readu32(LanesLow, 68), buffer.readu32(LanesHigh, 68)

		local Lane19Low, Lane19High = buffer.readu32(LanesLow, 72), buffer.readu32(LanesHigh, 72)
		local Lane20Low, Lane20High = buffer.readu32(LanesLow, 76), buffer.readu32(LanesHigh, 76)
		local Lane21Low, Lane21High = buffer.readu32(LanesLow, 80), buffer.readu32(LanesHigh, 80)

		local Lane22Low, Lane22High = buffer.readu32(LanesLow, 84), buffer.readu32(LanesHigh, 84)
		local Lane23Low, Lane23High = buffer.readu32(LanesLow, 88), buffer.readu32(LanesHigh, 88)
		local Lane24Low, Lane24High = buffer.readu32(LanesLow, 92), buffer.readu32(LanesHigh, 92)

		local Lane25Low, Lane25High = buffer.readu32(LanesLow, 96), buffer.readu32(LanesHigh, 96)

		for RoundIndex = 0, 92, 4 do
			local Column1Low, Column1High = bit32.bxor(Lane01Low, Lane06Low, Lane11Low, Lane16Low, Lane21Low), bit32.bxor(Lane01High, Lane06High, Lane11High, Lane16High, Lane21High)
			local Column2Low, Column2High = bit32.bxor(Lane02Low, Lane07Low, Lane12Low, Lane17Low, Lane22Low), bit32.bxor(Lane02High, Lane07High, Lane12High, Lane17High, Lane22High)
			local Column3Low, Column3High = bit32.bxor(Lane03Low, Lane08Low, Lane13Low, Lane18Low, Lane23Low), bit32.bxor(Lane03High, Lane08High, Lane13High, Lane18High, Lane23High)
			local Column4Low, Column4High = bit32.bxor(Lane04Low, Lane09Low, Lane14Low, Lane19Low, Lane24Low), bit32.bxor(Lane04High, Lane09High, Lane14High, Lane19High, Lane24High)
			local Column5Low, Column5High = bit32.bxor(Lane05Low, Lane10Low, Lane15Low, Lane20Low, Lane25Low), bit32.bxor(Lane05High, Lane10High, Lane15High, Lane20High, Lane25High)

			local DeltaLow, DeltaHigh = bit32.bxor(Column1Low, Column3Low * 2 + Column3High // 2147483648), bit32.bxor(Column1High, Column3High * 2 + Column3Low // 2147483648)
			local Temp0Low, Temp0High = bit32.bxor(DeltaLow, Lane02Low), bit32.bxor(DeltaHigh, Lane02High)
			local Temp1Low, Temp1High = bit32.bxor(DeltaLow, Lane07Low), bit32.bxor(DeltaHigh, Lane07High)
			local Temp2Low, Temp2High = bit32.bxor(DeltaLow, Lane12Low), bit32.bxor(DeltaHigh, Lane12High)
			local Temp3Low, Temp3High = bit32.bxor(DeltaLow, Lane17Low), bit32.bxor(DeltaHigh, Lane17High)
			local Temp4Low, Temp4High = bit32.bxor(DeltaLow, Lane22Low), bit32.bxor(DeltaHigh, Lane22High)

			Lane02Low = Temp1Low // 1048576 + (Temp1High * 4096); Lane02High = Temp1High // 1048576 + (Temp1Low * 4096)
			Lane07Low = Temp3Low // 524288 + (Temp3High * 8192); Lane07High = Temp3High // 524288 + (Temp3Low * 8192)
			Lane12Low = Temp0Low * 2 + Temp0High // 2147483648; Lane12High = Temp0High * 2 + Temp0Low // 2147483648
			Lane17Low = Temp2Low * 1024 + Temp2High // 4194304; Lane17High = Temp2High * 1024 + Temp2Low // 4194304
			Lane22Low = Temp4Low * 4 + Temp4High // 1073741824; Lane22High = Temp4High * 4 + Temp4Low // 1073741824

			DeltaLow = bit32.bxor(Column2Low, Column4Low * 2 + Column4High // 2147483648); DeltaHigh = bit32.bxor(Column2High, Column4High * 2 + Column4Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane03Low); Temp0High = bit32.bxor(DeltaHigh, Lane03High)
			Temp1Low = bit32.bxor(DeltaLow, Lane08Low); Temp1High = bit32.bxor(DeltaHigh, Lane08High)
			Temp2Low = bit32.bxor(DeltaLow, Lane13Low); Temp2High = bit32.bxor(DeltaHigh, Lane13High)
			Temp3Low = bit32.bxor(DeltaLow, Lane18Low); Temp3High = bit32.bxor(DeltaHigh, Lane18High)
			Temp4Low = bit32.bxor(DeltaLow, Lane23Low); Temp4High = bit32.bxor(DeltaHigh, Lane23High)

			Lane03Low = Temp2Low // 2097152 + (Temp2High * 2048); Lane03High = Temp2High // 2097152 + (Temp2Low * 2048)
			Lane08Low = Temp4Low // 8 + bit32.bor(Temp4High * 536870912, 0); Lane08High = Temp4High // 8 + bit32.bor(Temp4Low * 536870912, 0)
			Lane13Low = Temp1Low * 64 + Temp1High // 67108864; Lane13High = Temp1High * 64 + Temp1Low // 67108864
			Lane18Low = (Temp3Low * 32768) + Temp3High // 131072; Lane18High = (Temp3High * 32768) + Temp3Low // 131072
			Lane23Low = Temp0Low // 4 + bit32.bor(Temp0High * 1073741824, 0); Lane23High = Temp0High // 4 + bit32.bor(Temp0Low * 1073741824, 0)

			DeltaLow = bit32.bxor(Column3Low, Column5Low * 2 + Column5High // 2147483648); DeltaHigh = bit32.bxor(Column3High, Column5High * 2 + Column5Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane04Low); Temp0High = bit32.bxor(DeltaHigh, Lane04High)
			Temp1Low = bit32.bxor(DeltaLow, Lane09Low); Temp1High = bit32.bxor(DeltaHigh, Lane09High)
			Temp2Low = bit32.bxor(DeltaLow, Lane14Low); Temp2High = bit32.bxor(DeltaHigh, Lane14High)
			Temp3Low = bit32.bxor(DeltaLow, Lane19Low); Temp3High = bit32.bxor(DeltaHigh, Lane19High)
			Temp4Low = bit32.bxor(DeltaLow, Lane24Low); Temp4High = bit32.bxor(DeltaHigh, Lane24High)

			Lane04Low = bit32.bor(Temp3Low * 2097152, 0) + Temp3High // 2048; Lane04High = bit32.bor(Temp3High * 2097152, 0) + Temp3Low // 2048
			Lane09Low = bit32.bor(Temp0Low * 268435456, 0) + Temp0High // 16; Lane09High = bit32.bor(Temp0High * 268435456, 0) + Temp0Low // 16
			Lane14Low = bit32.bor(Temp2Low * 33554432, 0) + Temp2High // 128; Lane14High = bit32.bor(Temp2High * 33554432, 0) + Temp2Low // 128
			Lane19Low = Temp4Low // 256 + bit32.bor(Temp4High * 16777216, 0); Lane19High = Temp4High // 256 + bit32.bor(Temp4Low * 16777216, 0)
			Lane24Low = Temp1Low // 512 + bit32.bor(Temp1High * 8388608, 0); Lane24High = Temp1High // 512 + bit32.bor(Temp1Low * 8388608, 0)
			DeltaLow = bit32.bxor(Column4Low, Column1Low * 2 + Column1High // 2147483648); DeltaHigh = bit32.bxor(Column4High, Column1High * 2 + Column1Low // 2147483648)

			Temp0Low = bit32.bxor(DeltaLow, Lane05Low); Temp0High = bit32.bxor(DeltaHigh, Lane05High)
			Temp1Low = bit32.bxor(DeltaLow, Lane10Low); Temp1High = bit32.bxor(DeltaHigh, Lane10High)
			Temp2Low = bit32.bxor(DeltaLow, Lane15Low); Temp2High = bit32.bxor(DeltaHigh, Lane15High)
			Temp3Low = bit32.bxor(DeltaLow, Lane20Low); Temp3High = bit32.bxor(DeltaHigh, Lane20High)
			Temp4Low = bit32.bxor(DeltaLow, Lane25Low); Temp4High = bit32.bxor(DeltaHigh, Lane25High)

			Lane05Low = (Temp4Low * 16384) + Temp4High // 262144; Lane05High = (Temp4High * 16384) + Temp4Low // 262144
			Lane10Low = bit32.bor(Temp1Low * 1048576, 0) + Temp1High // 4096; Lane10High = bit32.bor(Temp1High * 1048576, 0) + Temp1Low // 4096
			Lane15Low = Temp3Low * 256 + Temp3High // 16777216; Lane15High = Temp3High * 256 + Temp3Low // 16777216
			Lane20Low = bit32.bor(Temp0Low * 134217728, 0) + Temp0High // 32; Lane20High = bit32.bor(Temp0High * 134217728, 0) + Temp0Low // 32
			Lane25Low = Temp2Low // 33554432 + Temp2High * 128; Lane25High = Temp2High // 33554432 + Temp2Low * 128

			DeltaLow = bit32.bxor(Column5Low, Column2Low * 2 + Column2High // 2147483648); DeltaHigh = bit32.bxor(Column5High, Column2High * 2 + Column2Low // 2147483648)
			Temp1Low = bit32.bxor(DeltaLow, Lane06Low); Temp1High = bit32.bxor(DeltaHigh, Lane06High)
			Temp2Low = bit32.bxor(DeltaLow, Lane11Low); Temp2High = bit32.bxor(DeltaHigh, Lane11High)
			Temp3Low = bit32.bxor(DeltaLow, Lane16Low); Temp3High = bit32.bxor(DeltaHigh, Lane16High)
			Temp4Low = bit32.bxor(DeltaLow, Lane21Low); Temp4High = bit32.bxor(DeltaHigh, Lane21High)
			Lane06Low = Temp2Low * 8 + Temp2High // 536870912; Lane06High = Temp2High * 8 + Temp2Low // 536870912
			Lane11Low = (Temp4Low * 262144) + Temp4High // 16384; Lane11High = (Temp4High * 262144) + Temp4Low // 16384
			Lane16Low = Temp1Low // 268435456 + Temp1High * 16; Lane16High = Temp1High // 268435456 + Temp1Low * 16
			Lane21Low = Temp3Low // 8388608 + Temp3High * 512; Lane21High = Temp3High // 8388608 + Temp3Low * 512
			Lane01Low = bit32.bxor(DeltaLow, Lane01Low); Lane01High = bit32.bxor(DeltaHigh, Lane01High)

			Lane01Low, Lane02Low, Lane03Low, Lane04Low, Lane05Low = bit32.bxor(Lane01Low, bit32.band(-1 - Lane02Low, Lane03Low)), bit32.bxor(Lane02Low, bit32.band(-1 - Lane03Low, Lane04Low)), bit32.bxor(Lane03Low, bit32.band(-1 - Lane04Low, Lane05Low)), bit32.bxor(Lane04Low, bit32.band(-1 - Lane05Low, Lane01Low)), bit32.bxor(Lane05Low, bit32.band(-1 - Lane01Low, Lane02Low)) :: number
			Lane01High, Lane02High, Lane03High, Lane04High, Lane05High = bit32.bxor(Lane01High, bit32.band(-1 - Lane02High, Lane03High)), bit32.bxor(Lane02High, bit32.band(-1 - Lane03High, Lane04High)), bit32.bxor(Lane03High, bit32.band(-1 - Lane04High, Lane05High)), bit32.bxor(Lane04High, bit32.band(-1 - Lane05High, Lane01High)), bit32.bxor(Lane05High, bit32.band(-1 - Lane01High, Lane02High)) :: number
			Lane06Low, Lane07Low, Lane08Low, Lane09Low, Lane10Low = bit32.bxor(Lane09Low, bit32.band(-1 - Lane10Low, Lane06Low)), bit32.bxor(Lane10Low, bit32.band(-1 - Lane06Low, Lane07Low)), bit32.bxor(Lane06Low, bit32.band(-1 - Lane07Low, Lane08Low)), bit32.bxor(Lane07Low, bit32.band(-1 - Lane08Low, Lane09Low)), bit32.bxor(Lane08Low, bit32.band(-1 - Lane09Low, Lane10Low)) :: number
			Lane06High, Lane07High, Lane08High, Lane09High, Lane10High = bit32.bxor(Lane09High, bit32.band(-1 - Lane10High, Lane06High)), bit32.bxor(Lane10High, bit32.band(-1 - Lane06High, Lane07High)), bit32.bxor(Lane06High, bit32.band(-1 - Lane07High, Lane08High)), bit32.bxor(Lane07High, bit32.band(-1 - Lane08High, Lane09High)), bit32.bxor(Lane08High, bit32.band(-1 - Lane09High, Lane10High)) :: number
			Lane11Low, Lane12Low, Lane13Low, Lane14Low, Lane15Low = bit32.bxor(Lane12Low, bit32.band(-1 - Lane13Low, Lane14Low)), bit32.bxor(Lane13Low, bit32.band(-1 - Lane14Low, Lane15Low)), bit32.bxor(Lane14Low, bit32.band(-1 - Lane15Low, Lane11Low)), bit32.bxor(Lane15Low, bit32.band(-1 - Lane11Low, Lane12Low)), bit32.bxor(Lane11Low, bit32.band(-1 - Lane12Low, Lane13Low)) :: number
			Lane11High, Lane12High, Lane13High, Lane14High, Lane15High = bit32.bxor(Lane12High, bit32.band(-1 - Lane13High, Lane14High)), bit32.bxor(Lane13High, bit32.band(-1 - Lane14High, Lane15High)), bit32.bxor(Lane14High, bit32.band(-1 - Lane15High, Lane11High)), bit32.bxor(Lane15High, bit32.band(-1 - Lane11High, Lane12High)), bit32.bxor(Lane11High, bit32.band(-1 - Lane12High, Lane13High)) :: number
			Lane16Low, Lane17Low, Lane18Low, Lane19Low, Lane20Low = bit32.bxor(Lane20Low, bit32.band(-1 - Lane16Low, Lane17Low)), bit32.bxor(Lane16Low, bit32.band(-1 - Lane17Low, Lane18Low)), bit32.bxor(Lane17Low, bit32.band(-1 - Lane18Low, Lane19Low)), bit32.bxor(Lane18Low, bit32.band(-1 - Lane19Low, Lane20Low)), bit32.bxor(Lane19Low, bit32.band(-1 - Lane20Low, Lane16Low)) :: number
			Lane16High, Lane17High, Lane18High, Lane19High, Lane20High = bit32.bxor(Lane20High, bit32.band(-1 - Lane16High, Lane17High)), bit32.bxor(Lane16High, bit32.band(-1 - Lane17High, Lane18High)), bit32.bxor(Lane17High, bit32.band(-1 - Lane18High, Lane19High)), bit32.bxor(Lane18High, bit32.band(-1 - Lane19High, Lane20High)), bit32.bxor(Lane19High, bit32.band(-1 - Lane20High, Lane16High)) :: number
			Lane21Low, Lane22Low, Lane23Low, Lane24Low, Lane25Low = bit32.bxor(Lane23Low, bit32.band(-1 - Lane24Low, Lane25Low)), bit32.bxor(Lane24Low, bit32.band(-1 - Lane25Low, Lane21Low)), bit32.bxor(Lane25Low, bit32.band(-1 - Lane21Low, Lane22Low)), bit32.bxor(Lane21Low, bit32.band(-1 - Lane22Low, Lane23Low)), bit32.bxor(Lane22Low, bit32.band(-1 - Lane23Low, Lane24Low)) :: number
			Lane21High, Lane22High, Lane23High, Lane24High, Lane25High = bit32.bxor(Lane23High, bit32.band(-1 - Lane24High, Lane25High)), bit32.bxor(Lane24High, bit32.band(-1 - Lane25High, Lane21High)), bit32.bxor(Lane25High, bit32.band(-1 - Lane21High, Lane22High)), bit32.bxor(Lane21High, bit32.band(-1 - Lane22High, Lane23High)), bit32.bxor(Lane22High, bit32.band(-1 - Lane23High, Lane24High)) :: number

			Lane01Low = bit32.bxor(Lane01Low, buffer.readu32(RCLow, RoundIndex))
			Lane01High = bit32.bxor(Lane01High, buffer.readu32(RCHigh, RoundIndex))
		end

		buffer.writeu32(LanesLow, 0, Lane01Low); buffer.writeu32(LanesHigh, 0, Lane01High)
		buffer.writeu32(LanesLow, 4, Lane02Low); buffer.writeu32(LanesHigh, 4, Lane02High)
		buffer.writeu32(LanesLow, 8, Lane03Low); buffer.writeu32(LanesHigh, 8, Lane03High)
		buffer.writeu32(LanesLow, 12, Lane04Low); buffer.writeu32(LanesHigh, 12, Lane04High)
		buffer.writeu32(LanesLow, 16, Lane05Low); buffer.writeu32(LanesHigh, 16, Lane05High)
		buffer.writeu32(LanesLow, 20, Lane06Low); buffer.writeu32(LanesHigh, 20, Lane06High)
		buffer.writeu32(LanesLow, 24, Lane07Low); buffer.writeu32(LanesHigh, 24, Lane07High)
		buffer.writeu32(LanesLow, 28, Lane08Low); buffer.writeu32(LanesHigh, 28, Lane08High)
		buffer.writeu32(LanesLow, 32, Lane09Low); buffer.writeu32(LanesHigh, 32, Lane09High)
		buffer.writeu32(LanesLow, 36, Lane10Low); buffer.writeu32(LanesHigh, 36, Lane10High)
		buffer.writeu32(LanesLow, 40, Lane11Low); buffer.writeu32(LanesHigh, 40, Lane11High)
		buffer.writeu32(LanesLow, 44, Lane12Low); buffer.writeu32(LanesHigh, 44, Lane12High)
		buffer.writeu32(LanesLow, 48, Lane13Low); buffer.writeu32(LanesHigh, 48, Lane13High)
		buffer.writeu32(LanesLow, 52, Lane14Low); buffer.writeu32(LanesHigh, 52, Lane14High)
		buffer.writeu32(LanesLow, 56, Lane15Low); buffer.writeu32(LanesHigh, 56, Lane15High)
		buffer.writeu32(LanesLow, 60, Lane16Low); buffer.writeu32(LanesHigh, 60, Lane16High)
		buffer.writeu32(LanesLow, 64, Lane17Low); buffer.writeu32(LanesHigh, 64, Lane17High)
		buffer.writeu32(LanesLow, 68, Lane18Low); buffer.writeu32(LanesHigh, 68, Lane18High)
		buffer.writeu32(LanesLow, 72, Lane19Low); buffer.writeu32(LanesHigh, 72, Lane19High)
		buffer.writeu32(LanesLow, 76, Lane20Low); buffer.writeu32(LanesHigh, 76, Lane20High)
		buffer.writeu32(LanesLow, 80, Lane21Low); buffer.writeu32(LanesHigh, 80, Lane21High)
		buffer.writeu32(LanesLow, 84, Lane22Low); buffer.writeu32(LanesHigh, 84, Lane22High)
		buffer.writeu32(LanesLow, 88, Lane23Low); buffer.writeu32(LanesHigh, 88, Lane23High)
		buffer.writeu32(LanesLow, 92, Lane24Low); buffer.writeu32(LanesHigh, 92, Lane24High)
		buffer.writeu32(LanesLow, 96, Lane25Low); buffer.writeu32(LanesHigh, 96, Lane25High)
	end
end

local LEFT_ENCODE_RESULT = buffer.create(5)
local RIGHT_ENCODE_RESULT = buffer.create(5)

local function LeftEncode(Value: number): (buffer, number)
	local Result = LEFT_ENCODE_RESULT

	if Value <= 0xFF then
		buffer.writeu8(Result, 0, 1)
		buffer.writeu8(Result, 1, Value)
		return Result, 2
	end

	if Value <= 0xFFFF then
		buffer.writeu8(Result, 0, 2)
		buffer.writeu16(Result, 1, bit32.byteswap(bit32.lshift(Value, 16)))
		return Result, 3
	end

	local ByteLength = if Value > 0xFFFFFF then 4 else 3
	buffer.writeu8(Result, 0, ByteLength)
	buffer.writeu32(Result, 1, bit32.byteswap(bit32.lshift(Value, (4 - ByteLength) * 8)))
	return Result, ByteLength + 1
end

local function RightEncode(Value: number): (buffer, number)
	local Result = RIGHT_ENCODE_RESULT

	if Value <= 0xFF then
		buffer.writeu8(Result, 0, Value)
		buffer.writeu8(Result, 1, 1)
		return Result, 2
	end

	if Value <= 0xFFFF then
		buffer.writeu16(Result, 0, bit32.byteswap(bit32.lshift(Value, 16)))
		buffer.writeu8(Result, 2, 2)
		return Result, 3
	end

	local ByteLength = if Value > 0xFFFFFF then 4 else 3
	buffer.writeu32(Result, 0, bit32.byteswap(bit32.lshift(Value, (4 - ByteLength) * 8)))
	buffer.writeu8(Result, ByteLength, ByteLength)
	return Result, ByteLength + 1
end

local function EncodeString(Data: buffer): buffer
	local DataLength = buffer.len(Data)
	
	local LengthEncoding, LengthEncodingSize = LeftEncode(DataLength * 8)
	
	local Result = buffer.create(LengthEncodingSize + DataLength)

	buffer.copy(Result, 0, LengthEncoding, 0, LengthEncodingSize)
	buffer.copy(Result, LengthEncodingSize, Data, 0, DataLength)

	return Result
end

local function Bytepad(Data: buffer, Rate: number): buffer
	local DataLength = buffer.len(Data)
	
	local RateEncoding, RateEncodingSize = LeftEncode(Rate)
	
	local TotalPrePadLength = RateEncodingSize + DataLength
	local PadLength = Rate - (TotalPrePadLength % Rate)
	if PadLength == Rate then
		PadLength = 0
	end

	local Result = buffer.create(TotalPrePadLength + PadLength)
	buffer.copy(Result, 0, RateEncoding, 0, RateEncodingSize)
	buffer.copy(Result, RateEncodingSize, Data, 0, DataLength)

	return Result
end

local function CSHAKE(Output: buffer, CustomBuffer: buffer?, Data: buffer, RateBytes: number): ()	
	buffer.fill(LANES_LOW, 0, 0, 100)
	buffer.fill(LANES_HIGH, 0, 0, 100)

	local LanesLow = LANES_LOW
	local LanesHigh = LANES_HIGH

	local OutputBytes = buffer.len(Output)

	local EncodedFunctionName = EncodeString(FUNCTION_NAME)
	local EncodedFunctionNameSize = buffer.len(EncodedFunctionName)

	local PrefixData: buffer
	if CustomBuffer then
		local EncodedCustomization = EncodeString(CustomBuffer)
		local EncodedCustomizationSize = buffer.len(EncodedCustomization)
		PrefixData = buffer.create(EncodedFunctionNameSize + EncodedCustomizationSize)
		buffer.copy(PrefixData, 0, EncodedFunctionName, 0, EncodedFunctionNameSize)
		buffer.copy(PrefixData, EncodedFunctionNameSize, EncodedCustomization, 0, EncodedCustomizationSize)
	else
		PrefixData = EncodedFunctionName
	end

	local BytepaddedPrefix = Bytepad(PrefixData, RateBytes)
	local BytepaddedPrefixSize = buffer.len(BytepaddedPrefix)
	local DataSize = buffer.len(Data)
	local TotalInputSize = BytepaddedPrefixSize + DataSize

	local PaddedLength = TotalInputSize + 1
	local Remainder = PaddedLength % RateBytes
	if Remainder ~= 0 then
		PaddedLength += (RateBytes - Remainder)
	end

	local PaddedMessage = buffer.create(PaddedLength)
	buffer.copy(PaddedMessage, 0, BytepaddedPrefix, 0, BytepaddedPrefixSize)
	buffer.copy(PaddedMessage, BytepaddedPrefixSize, Data, 0, DataSize)

	local DomainSeparator = 0x04
	if PaddedLength - TotalInputSize == 1 then
		buffer.writeu8(PaddedMessage, TotalInputSize, bit32.bor(DomainSeparator, 0x80))
	else
		buffer.writeu8(PaddedMessage, TotalInputSize, DomainSeparator)
		if PaddedLength - TotalInputSize > 2 then
			buffer.fill(PaddedMessage, TotalInputSize + 1, 0, PaddedLength - TotalInputSize - 2)
		end
		buffer.writeu8(PaddedMessage, PaddedLength - 1, 0x80)
	end

	Keccak(LanesLow, LanesHigh, PaddedMessage, 0, PaddedLength, RateBytes)

	local OutputOffset = 0
	local ZeroBuffer = buffer.create(RateBytes)

	while OutputOffset < OutputBytes do
		local BytesThisRound = math.min(RateBytes, OutputBytes - OutputOffset)

		for ByteIndex = 0, BytesThisRound - 1 do
			local AbsoluteIndex = OutputOffset + ByteIndex
			if AbsoluteIndex < OutputBytes then
				local Lane = ByteIndex // 8
				local ByteInLane = ByteIndex % 8
				local LaneOffset = Lane * 4

				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), ByteInLane * 8, 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), (ByteInLane - 4) * 8, 8)
				end
				buffer.writeu8(Output, AbsoluteIndex, Value)
			end
		end

		OutputOffset += BytesThisRound

		if OutputOffset < OutputBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
		end
	end
end

function KMAC.KMAC128(Data: buffer, Key: buffer, Output: buffer, CustomBuffer: buffer?): (string, buffer)
	local OutputBytes = buffer.len(Output)

	local EncodedKey = EncodeString(Key)
	local BytepaddedKey = Bytepad(EncodedKey, 168)

	local BytepaddedKeySize = buffer.len(BytepaddedKey)
	local DataSize = buffer.len(Data)

	local RightEncodedLength, RightEncodedLengthSize = RightEncode(OutputBytes * 8)

	local Hex = buffer.create(OutputBytes * 2)
	local Lookup = ENCODE_LOOKUP

	local Leftover = OutputBytes % 8
	local HexCursor = 0

	local CombinedData = buffer.create(BytepaddedKeySize + DataSize + RightEncodedLengthSize)
	buffer.copy(CombinedData, 0, BytepaddedKey, 0, BytepaddedKeySize)
	buffer.copy(CombinedData, BytepaddedKeySize, Data, 0, DataSize)
	buffer.copy(CombinedData, BytepaddedKeySize + DataSize, RightEncodedLength, 0, RightEncodedLengthSize)

	CSHAKE(Output, CustomBuffer, CombinedData, 168)

	for Index = 0, OutputBytes - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Output, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = OutputBytes - Leftover, OutputBytes - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Output, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex), Output
end

function KMAC.KMAC256(Data: buffer, Key: buffer, Output: buffer, CustomBuffer: buffer?): (string, buffer)
	local OutputBytes = buffer.len(Output)

	local EncodedKey = EncodeString(Key)
	local BytepaddedKey = Bytepad(EncodedKey, 136)

	local BytepaddedKeySize = buffer.len(BytepaddedKey)
	local DataSize = buffer.len(Data)

	local RightEncodedLength, RightEncodedLengthSize = RightEncode(OutputBytes * 8)

	local Hex = buffer.create(OutputBytes * 2)
	local Lookup = ENCODE_LOOKUP

	local Leftover = OutputBytes % 8
	local HexCursor = 0

	local CombinedData = buffer.create(BytepaddedKeySize + DataSize + RightEncodedLengthSize)
	buffer.copy(CombinedData, 0, BytepaddedKey, 0, BytepaddedKeySize)
	buffer.copy(CombinedData, BytepaddedKeySize, Data, 0, DataSize)
	buffer.copy(CombinedData, BytepaddedKeySize + DataSize, RightEncodedLength, 0, RightEncodedLengthSize)

	CSHAKE(Output, CustomBuffer, CombinedData, 136)

	for Index = 0, OutputBytes - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Output, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Output, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = OutputBytes - Leftover, OutputBytes - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Output, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex), Output
end

return KMAC]]></ProtectedString>
							<string name="ScriptGuid">{51498DC0-C6E9-4A53-A007-D09FE7F6ADCD}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">KMAC</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXE99615D345834AC186D89287E2ADD3F7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!strict

local Algorithms = table.freeze({
	RandomString = require("@self/RandomString"),
	Conversions = require("@self/Conversions"),
	Base64 = require("@self/Base64"),
	CSPRNG = require("@self/CSPRNG")
})

return Algorithms]]></ProtectedString>
						<string name="ScriptGuid">{037956EE-E7A2-4CB6-85B2-218D31C95D2C}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Utilities</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE8E7D5AA82AC403FA7121A8EBD3F51E8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Base64
	
	Return type: buffer
	Example usage:
		local Input = buffer.fromstring("Hello World")
		local Encoded = Base64.Encode(Input)
		local Decoded = Base64.Decode(Encoded)
--]=]

--!strict
--!optimize 2
--!native

local PADDING_CHARACTER = 61
local ALPHABET_BYTES = buffer.create(64) do
	local Characters = {
		65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
		81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
		97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
		113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
		48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
		43, 47 
	}

	for Index = 1, 64 do
		buffer.writeu8(ALPHABET_BYTES, Index - 1, Characters[Index])
	end
end

local ENCODE_A, ENCODE_B = buffer.create(131072), buffer.create(131072) do
	for Byte0 = 0, 255 do
		local Sextet0 = Byte0 // 4
		local Sextet0Char = buffer.readu8(ALPHABET_BYTES, Sextet0)
		local Byte0Low = Byte0 % 4
		for Byte1 = 0, 255 do
			local Sextet1 = Byte0Low * 16 + (Byte1 // 16)
			local Index = (Byte0 + Byte1 * 256) * 2
			buffer.writeu16(ENCODE_A, Index, Sextet0Char + buffer.readu8(ALPHABET_BYTES, Sextet1) * 256)
		end
	end

	for Byte1 = 0, 255 do
		local Nibble = (Byte1 % 16) * 4
		for Byte2 = 0, 255 do
			local Sextet2 = Nibble + (Byte2 // 64)
			local Sextet3 = Byte2 % 64
			local Index = (Byte1 + Byte2 * 256) * 2
			buffer.writeu16(ENCODE_B, Index, buffer.readu8(ALPHABET_BYTES, Sextet2) + buffer.readu8(ALPHABET_BYTES, Sextet3) * 256)
		end
	end
end

local DECODE_TET = buffer.create(256) do
	for Index = 1, 64 do
		buffer.writeu8(DECODE_TET, buffer.readu8(ALPHABET_BYTES, Index - 1), Index - 1)
	end

	buffer.writeu8(DECODE_TET, PADDING_CHARACTER, 254)
end

local DECODE_PAIR = buffer.create(131072) do
	for Char0 = 0, 255 do
		local Decoded0 = buffer.readu8(DECODE_TET, Char0)
		for Char1 = 0, 255 do
			local Decoded1 = buffer.readu8(DECODE_TET, Char1)
			local Key = (Char0 + Char1 * 256) * 2
			if Decoded0 < 64 and Decoded1 < 64 then
				buffer.writeu16(DECODE_PAIR, Key, Decoded0 * 64 + Decoded1)
			elseif Decoded0 == 254 or Decoded1 == 254 then
				buffer.writeu16(DECODE_PAIR, Key, 254)
			end
		end
	end
end

local PAIR_A_BYTE1_HIGH = buffer.create(4096)
local PAIR_B_BYTE1_LOW = buffer.create(4096)

local PAIR_A_BYTE0, PAIR_B_BYTE2 = buffer.create(4096), buffer.create(4096) do
	for PairA = 0, 4095 do
		local Sextet0 = PairA // 64
		local Sextet1 = PairA % 64
		buffer.writeu8(PAIR_A_BYTE0, PairA, Sextet0 * 4 + (Sextet1 // 16))
		buffer.writeu8(PAIR_A_BYTE1_HIGH, PairA, (Sextet1 % 16) * 16)
	end

	for PairB = 0, 4095 do
		local Sextet2 = PairB // 64
		local Sextet3 = PairB % 64
		buffer.writeu8(PAIR_B_BYTE1_LOW, PairB, Sextet2 // 4)
		buffer.writeu8(PAIR_B_BYTE2, PairB, (Sextet2 % 4) * 64 + Sextet3)
	end
end

local function Encode(Input: buffer): buffer
	local InputLength = buffer.len(Input)
	if InputLength == 0 then
		return buffer.create(0)
	end

	local Output = buffer.create(((InputLength + 2) // 3) * 4)
	local InputIndex = 0
	local OutputIndex = 0
	local FullTripletEnd = InputLength - (InputLength % 3)
	local UnrollStop = InputLength - 13

	local EncodeA = ENCODE_A
	local EncodeB = ENCODE_B
	local AlphabetBytes = ALPHABET_BYTES

	while InputIndex <= UnrollStop do
		local Word0 = buffer.readu32(Input, InputIndex)
		local Word1 = buffer.readu32(Input, InputIndex + 3)
		local Word2 = buffer.readu32(Input, InputIndex + 6)
		local Word3 = buffer.readu32(Input, InputIndex + 9)

		local KeyA0 = Word0 % 65536
		local KeyB0 = (Word0 // 256) % 65536
		buffer.writeu32(Output, OutputIndex, buffer.readu16(EncodeA, KeyA0 * 2) + buffer.readu16(EncodeB, KeyB0 * 2) * 0x10000)

		local KeyA1 = Word1 % 65536
		local KeyB1 = (Word1 // 256) % 65536
		buffer.writeu32(Output, OutputIndex + 4, buffer.readu16(EncodeA, KeyA1 * 2) + buffer.readu16(EncodeB, KeyB1 * 2) * 0x10000)

		local KeyA2 = Word2 % 65536
		local KeyB2 = (Word2 // 256) % 65536
		buffer.writeu32(Output, OutputIndex + 8, buffer.readu16(EncodeA, KeyA2 * 2) + buffer.readu16(EncodeB, KeyB2 * 2) * 0x10000)

		local KeyA3 = Word3 % 65536
		local KeyB3 = (Word3 // 256) % 65536
		buffer.writeu32(Output, OutputIndex + 12, buffer.readu16(EncodeA, KeyA3 * 2) + buffer.readu16(EncodeB, KeyB3 * 2) * 0x10000)

		InputIndex += 12
		OutputIndex += 16
	end

	while InputIndex < FullTripletEnd do
		local KeyA = buffer.readu16(Input, InputIndex)
		local Byte2 = buffer.readu8(Input, InputIndex + 2)
		local KeyB = (KeyA // 256) + Byte2 * 256
		buffer.writeu32(Output, OutputIndex, buffer.readu16(EncodeA, KeyA * 2) + buffer.readu16(EncodeB, KeyB * 2) * 0x10000)
		InputIndex += 3
		OutputIndex += 4
	end

	local Remainder = InputLength - InputIndex
	if Remainder == 1 then
		local Byte0 = buffer.readu8(Input, InputIndex)
		local Sextet0 = Byte0 // 4
		local Sextet1 = (Byte0 % 4) * 16
		local Pair = buffer.readu8(AlphabetBytes, Sextet0) + buffer.readu8(AlphabetBytes, Sextet1) * 256
		buffer.writeu16(Output, OutputIndex, Pair)
		buffer.writeu8(Output, OutputIndex + 2, PADDING_CHARACTER)
		buffer.writeu8(Output, OutputIndex + 3, PADDING_CHARACTER)
	elseif Remainder == 2 then
		local Byte0 = buffer.readu8(Input, InputIndex)
		local Byte1 = buffer.readu8(Input, InputIndex + 1)
		local KeyA = Byte0 + Byte1 * 256
		buffer.writeu16(Output, OutputIndex, buffer.readu16(EncodeA, KeyA * 2))
		local Sextet2 = (Byte1 % 16) * 4
		buffer.writeu8(Output, OutputIndex + 2, buffer.readu8(AlphabetBytes, Sextet2))
		buffer.writeu8(Output, OutputIndex + 3, PADDING_CHARACTER)
	end

	return Output
end

local function Decode(Input: buffer): buffer
	local InputLength = buffer.len(Input)
	if InputLength == 0 then
		return buffer.create(0)
	end

	local Padding = 0
	if buffer.readu8(Input, InputLength - 1) == PADDING_CHARACTER then
		Padding = 1
		if buffer.readu8(Input, InputLength - 2) == PADDING_CHARACTER then
			Padding = 2
		end
	end

	local Output = buffer.create((InputLength // 4) * 3 - Padding)
	local InputIndex = 0
	local OutputIndex = 0
	local BodyEnd = InputLength - 4
	local UnrollStop = BodyEnd - 8

	local DecodePair = DECODE_PAIR
	local Pair0 = PAIR_A_BYTE0
	local PairAHigh = PAIR_A_BYTE1_HIGH
	local PairBLow = PAIR_B_BYTE1_LOW
	local Pair2 = PAIR_B_BYTE2
	local Dtet = DECODE_TET

	while InputIndex <= UnrollStop do
		local Word0 = buffer.readu32(Input, InputIndex)
		local Word1 = buffer.readu32(Input, InputIndex + 4)

		local PairA0 = buffer.readu16(DecodePair, (Word0 % 65536) * 2)
		local PairB0 = buffer.readu16(DecodePair, (Word0 // 65536) * 2)
		buffer.writeu8(Output, OutputIndex, buffer.readu8(Pair0, PairA0))
		buffer.writeu8(Output, OutputIndex + 1, buffer.readu8(PairAHigh, PairA0) + buffer.readu8(PairBLow, PairB0))
		buffer.writeu8(Output, OutputIndex + 2, buffer.readu8(Pair2, PairB0))

		local PairA1 = buffer.readu16(DecodePair, (Word1 % 65536) * 2)
		local PairB1 = buffer.readu16(DecodePair, (Word1 // 65536) * 2)
		buffer.writeu8(Output, OutputIndex + 3, buffer.readu8(Pair0, PairA1))
		buffer.writeu8(Output, OutputIndex + 4, buffer.readu8(PairAHigh, PairA1) + buffer.readu8(PairBLow, PairB1))
		buffer.writeu8(Output, OutputIndex + 5, buffer.readu8(Pair2, PairB1))

		InputIndex += 8
		OutputIndex += 6
	end

	while InputIndex <= BodyEnd - 4 do
		local Word = buffer.readu32(Input, InputIndex)
		local PairA = buffer.readu16(DecodePair, (Word % 65536) * 2)
		local PairB = buffer.readu16(DecodePair, (Word // 65536) * 2)
		buffer.writeu8(Output, OutputIndex, buffer.readu8(Pair0, PairA))
		buffer.writeu8(Output, OutputIndex + 1, buffer.readu8(PairAHigh, PairA) + buffer.readu8(PairBLow, PairB))
		buffer.writeu8(Output, OutputIndex + 2, buffer.readu8(Pair2, PairB))
		InputIndex += 4
		OutputIndex += 3
	end

	local Char0 = buffer.readu8(Input, InputIndex)
	local Char1 = buffer.readu8(Input, InputIndex + 1)
	local Char2 = buffer.readu8(Input, InputIndex + 2)
	local Char3 = buffer.readu8(Input, InputIndex + 3)
	local Decoded0 = buffer.readu8(Dtet, Char0)
	local Decoded1 = buffer.readu8(Dtet, Char1)

	if Char2 == PADDING_CHARACTER then
		local PairA = Decoded0 * 64 + Decoded1
		buffer.writeu8(Output, OutputIndex, buffer.readu8(Pair0, PairA))
	elseif Char3 == PADDING_CHARACTER then
		local Decoded2 = buffer.readu8(Dtet, Char2)
		local PairA = Decoded0 * 64 + Decoded1
		local PairB = Decoded2 * 64
		buffer.writeu8(Output, OutputIndex, buffer.readu8(Pair0, PairA))
		buffer.writeu8(Output, OutputIndex + 1, buffer.readu8(PairAHigh, PairA) + (PairB // 256))
	else
		local Decoded2 = buffer.readu8(Dtet, Char2)
		local Decoded3 = buffer.readu8(Dtet, Char3)
		local PairA = Decoded0 * 64 + Decoded1
		local PairB = Decoded2 * 64 + Decoded3
		buffer.writeu8(Output, OutputIndex, buffer.readu8(Pair0, PairA))
		buffer.writeu8(Output, OutputIndex + 1, buffer.readu8(PairAHigh, PairA) + buffer.readu8(PairBLow, PairB))
		buffer.writeu8(Output, OutputIndex + 2, buffer.readu8(Pair2, PairB))
	end

	return Output
end

return {
	Encode = Encode,
	Decode = Decode
}]]></ProtectedString>
							<string name="ScriptGuid">{EBEAAB5A-D7E2-4865-B42C-43C24B0BA080}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Base64</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX202F99E80E984ECBBA5D79DF411AC561">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Cryptographically Secure RNG
	
	Usage:
		local RandomFloat = CSPRNG.Random()
		local RandomInt = CSPRNG.RandomInt(1, 100)
		local RandomNumber = CSPRNG.RandomNumber(0.5, 10.5)
		local RandomBytes = CSPRNG.RandomBytes(32)
		local RandomHex = CSPRNG.RandomHex(16)
		local FastString = CSPRNG.RandomString(16, false)
		local FastBuffer = CSPRNG.RandomString(32, true)
		
		local Ed25519Clamped = CSPRNG.Ed25519ClampedBytes(SomeBuffer)
		local Ed25519Random = CSPRNG.Ed25519Random()
		
		CSPRNG.AddEntropyProvider(function)
		CSPRNG.RemoveEntropyProvider(function)
		CSPRNG.Reseed()
		
		CSPRNG.BytesLeft
--]=]

--!strict
--!optimize 2
--!native

local Conversions = require("@self/Conversions")
local ChaCha20 = require("@self/ChaCha20")
local Blake3 = require("@self/Blake3")

export type EntropyProvider = (BytesLeft: number) -> buffer?

type CSPRNGModule = {
	BlockExpansion: boolean,

	SizeTarget: number,
	RekeyAfter: number,

	Key: buffer,
	Nonce: buffer,
	Buffer: buffer,

	Counter: number,
	BufferPosition: number,
	BufferSize: number,
	BytesLeft: number,

	EntropyProviders: { EntropyProvider },

	Reseed: (CustomEntropy: buffer?) -> (),
	AddEntropyProvider: (ProviderFunction: EntropyProvider) -> (),
	RemoveEntropyProvider: (ProviderFunction: EntropyProvider) -> (),

	Random: () -> number,
	RandomInt: (Min: number, Max: number?) -> number,
	RandomNumber: (Min: number, Max: number?) -> number,
	RandomBytes: (Count: number) -> buffer,
	RandomString: (Length: number, AsBuffer: boolean?) -> string | buffer,
	RandomHex: (Length: number) -> string,
	Ed25519ClampedBytes: (Input: buffer) -> buffer,
	Ed25519Random: () -> buffer,
}

local BLOCK_SIZE = 64
local KEY_SIZE = 32
local NONCE_SIZE = 12

local CSPRNG: CSPRNGModule = {
	BlockExpansion = true,
	SizeTarget = 2048,
	RekeyAfter = 1024,

	Key = buffer.create(0),
	Nonce = buffer.create(0),
	Buffer = buffer.create(0),

	Counter = 0,
	BufferPosition = 0,
	BufferSize = 0,
	BytesLeft = 0,

	EntropyProviders = {}
} :: CSPRNGModule

local INPUT_BUFFER = buffer.create(BLOCK_SIZE)
local REKEY_THRESHOLD = math.max(math.floor(CSPRNG.RekeyAfter), 2)
local SIZE_TARGET_CLAMPED = math.clamp(math.floor(CSPRNG.SizeTarget), 64, 4294967295)

local function Reset()
	CSPRNG.Key = buffer.create(0)
	CSPRNG.Nonce = buffer.create(0)
	CSPRNG.Buffer = buffer.create(0)

	CSPRNG.Counter = 0
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = 0
end

local function GatherEntropy(CustomEntropy: buffer?): number
	local EntropyBuffers = buffer.create(1024)
	local Offset = 0

	local function WriteToBuffer(Source: buffer)
		local Size = buffer.len(Source)
		buffer.copy(EntropyBuffers, Offset, Source, 0, Size)
		Offset += Size
	end

	local CurrentTime = 1.234
	if tick then
		CurrentTime = tick()
		local TimeBuffer = buffer.create(8)
		buffer.writef64(TimeBuffer, 0, CurrentTime)
		WriteToBuffer(TimeBuffer)
	end

	local ClockTime = os.clock()
	local ClockBuffer = buffer.create(8)
	buffer.writef64(ClockBuffer, 0, ClockTime)
	WriteToBuffer(ClockBuffer)

	local UnixTime = os.time()
	local UnixBuffer = buffer.create(8)
	buffer.writeu32(UnixBuffer, 0, UnixTime % 0x100000000)
	buffer.writeu32(UnixBuffer, 4, math.floor(UnixTime / 0x100000000))
	WriteToBuffer(UnixBuffer)

	local DateTimeMillis = 5.678
	if DateTime then
		DateTimeMillis = DateTime.now().UnixTimestampMillis
		local DateTimeBuffer = buffer.create(8)
		buffer.writef64(DateTimeBuffer, 0, DateTimeMillis)
		WriteToBuffer(DateTimeBuffer)

		local DateTimePrecisionBuffer = buffer.create(16)
		buffer.writef32(DateTimePrecisionBuffer, 0, DateTimeMillis / 1000)
		buffer.writef32(DateTimePrecisionBuffer, 4, (DateTimeMillis % 1000) / 100)
		buffer.writef32(DateTimePrecisionBuffer, 8, DateTimeMillis / 86400000)
		buffer.writef32(DateTimePrecisionBuffer, 12, (DateTimeMillis * 0.001) % 1)
		WriteToBuffer(DateTimePrecisionBuffer)
	else
		WriteToBuffer(buffer.create(24))
	end

	local FracTimeBuffer = buffer.create(16)
	buffer.writef32(FracTimeBuffer, 0, ClockTime / 100)
	buffer.writef32(FracTimeBuffer, 4, CurrentTime / 1000)
	buffer.writef32(FracTimeBuffer, 8, (ClockTime * 12345.6789) % 1)
	buffer.writef32(FracTimeBuffer, 12, (CurrentTime * 98765.4321) % 1)
	WriteToBuffer(FracTimeBuffer)

	local NoiseBuffer = buffer.create(32)
	for Index = 0, 7 do
		local Noise1 = math.noise(ClockTime + Index, UnixTime + Index, ClockTime + UnixTime + Index)
		local Noise2 = math.noise(CurrentTime + Index * 0.1, DateTimeMillis * 0.0001 + Index, ClockTime * 1.5 + Index)
		local Noise3 = math.noise(UnixTime * 0.01 + Index, ClockTime + DateTimeMillis * 0.001, CurrentTime + Index * 2)
		local Noise4 = math.noise(DateTimeMillis * 0.00001 + Index, UnixTime + ClockTime + Index, CurrentTime * 0.1 + Index)

		buffer.writef32(NoiseBuffer, Index * 4, Noise1 + Noise2 + Noise3 + Noise4)
	end
	WriteToBuffer(NoiseBuffer)

	local BenchmarkTimings = buffer.create(32)
	for Index = 0, 7 do
		local StartTime = os.clock()
		local Sum = 0

		local Iterations = 50 + (Index * 25)
		for Iteration = 1, Iterations do
			Sum += Iteration * Iteration + math.sin(Iteration / 10) * math.cos(Iteration / 7)
		end

		local EndTime = os.clock()
		local TimingDelta = EndTime - StartTime
		buffer.writef32(BenchmarkTimings, Index * 4, TimingDelta * 1000000)
	end
	WriteToBuffer(BenchmarkTimings)

	local AllocTimings = buffer.create(24)
	for Index = 0, 5 do
		local AllocStart = os.clock()

		for AllocIndex = 1, 20 do
			local _TempBuf = buffer.create(64 + AllocIndex)
		end

		local AllocEnd = os.clock()
		buffer.writef32(AllocTimings, Index * 4, (AllocEnd - AllocStart) * 10000000)
	end
	WriteToBuffer(AllocTimings)

	local MicroTime = math.floor(CurrentTime * 1000000)
	local MicroTimeBuffer = buffer.create(8)
	buffer.writeu32(MicroTimeBuffer, 0, MicroTime % 0x100000000)
	buffer.writeu32(MicroTimeBuffer, 4, math.floor(MicroTime / 0x100000000))
	WriteToBuffer(MicroTimeBuffer)

	if game then
		if game.JobId and #game.JobId > 0 then
			local JobIdBuffer = buffer.fromstring(game.JobId)
			WriteToBuffer(JobIdBuffer)
		end

		if game.PlaceId then
			local PlaceIdBuffer = buffer.create(8)
			buffer.writeu32(PlaceIdBuffer, 0, game.PlaceId % 0x100000000)
			buffer.writeu32(PlaceIdBuffer, 4, math.floor(game.PlaceId / 0x100000000))
			WriteToBuffer(PlaceIdBuffer)
		end

		if workspace and workspace.DistributedGameTime then
			local DistTimeBuffer = buffer.create(8)
			buffer.writef64(DistTimeBuffer, 0, workspace.DistributedGameTime)
			WriteToBuffer(DistTimeBuffer)

			local DistMicroTime = math.floor(workspace.DistributedGameTime * 1000000)
			local DistMicroBuffer = buffer.create(8)
			buffer.writeu32(DistMicroBuffer, 0, DistMicroTime % 0x100000000)
			buffer.writeu32(DistMicroBuffer, 4, math.floor(DistMicroTime / 0x100000000))
			WriteToBuffer(DistMicroBuffer)
		end
	end

	local AddressEntropy = buffer.create(128)
	for Index = 0, 7 do
		local TempTable = {}
		local TempFunc = function() end
		local TempBuffer = buffer.create(0)
		local TempUserdata = newproxy()

		local TableAddr = string.gsub(tostring(TempTable), "table: ", "")
		local FuncAddr = string.gsub(tostring(TempFunc), "function: ", "")
		local BufferAddr = string.gsub(tostring(TempBuffer), "buffer: ", "")
		local UserdataAddr = string.gsub(tostring(TempUserdata), "userdata: ", "")

		local TableHash = 0
		local ThreadHash = 0
		local FuncHash = 0
		local BufferHash = 0
		local UserdataHash = 0

		for AddrIndex = 1, #TableAddr do
			TableHash = bit32.bxor(TableHash, string.byte(TableAddr, AddrIndex)) * 31
		end

		if coroutine then
			local ThreadAddr = string.gsub(tostring(coroutine.create(function() end)), "thread: ", "")
			for AddrIndex = 1, #ThreadAddr do
				ThreadHash = bit32.bxor(ThreadHash, string.byte(ThreadAddr, AddrIndex)) * 31
			end
		end

		for AddrIndex = 1, #FuncAddr do
			FuncHash = bit32.bxor(FuncHash, string.byte(FuncAddr, AddrIndex)) * 37
		end
		for AddrIndex = 1, #BufferAddr do
			BufferHash = bit32.bxor(BufferHash, string.byte(BufferAddr, AddrIndex)) * 41
		end
		for AddrIndex = 1, #UserdataAddr do
			UserdataHash = bit32.bxor(UserdataHash, string.byte(UserdataAddr, AddrIndex)) * 43
		end

		buffer.writeu32(AddressEntropy, Index * 16, TableHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 4, ThreadHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 8, FuncHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 12, bit32.bxor(BufferHash, UserdataHash))
	end
	WriteToBuffer(AddressEntropy)

	local function AddExtraEntropy(Entropy: buffer?, Warn: boolean, Provider: string?)
		if not Entropy then
			return
		end

		local BytesLeft = 1024 - Offset

		if BytesLeft > 0 then
			local Extra = buffer.len(Entropy) - BytesLeft
			local Truncated = math.min(BytesLeft, buffer.len(Entropy))

			if Extra > 0 and Warn and Provider then
				warn(`CSPRNG: {Provider} returned {Extra} bytes more than available and was truncated to {Truncated} bytes`)
			end

			buffer.copy(EntropyBuffers, Offset, Entropy, 0, Truncated)
		end
	end

	for Index, Provider in CSPRNG.EntropyProviders do
		local BytesLeft = 1024 - Offset
		if BytesLeft > 0 then
			local Success: boolean, ExtraEntropy: buffer? = pcall(Provider, BytesLeft)
			if not Success then
				warn(`CSPRNG Provider errored with {ExtraEntropy}`)
			end

			AddExtraEntropy(ExtraEntropy, true, `Entropy Provider #{Index}`)
		end
	end

	if CustomEntropy then
		AddExtraEntropy(CustomEntropy, false)
	end

	local KeyMaterial = Blake3(EntropyBuffers, KEY_SIZE + NONCE_SIZE)

	CSPRNG.Key = buffer.create(KEY_SIZE)
	buffer.copy(CSPRNG.Key, 0, KeyMaterial, 0, KEY_SIZE)

	CSPRNG.Nonce = buffer.create(NONCE_SIZE)
	buffer.copy(CSPRNG.Nonce, 0, KeyMaterial, KEY_SIZE, NONCE_SIZE)

	return buffer.len(EntropyBuffers) - Offset
end

local function GenerateBlock()
	buffer.fill(INPUT_BUFFER, 0, 0, BLOCK_SIZE)
	local ChaChaOutput = ChaCha20(INPUT_BUFFER, CSPRNG.Key, CSPRNG.Nonce, CSPRNG.Counter, 20)

	CSPRNG.Buffer = if CSPRNG.BlockExpansion then Blake3(ChaChaOutput, SIZE_TARGET_CLAMPED) else ChaChaOutput
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = buffer.len(CSPRNG.Buffer)
	CSPRNG.Counter += 1

	if CSPRNG.Counter % REKEY_THRESHOLD == 0 then
		GatherEntropy() 
		CSPRNG.Counter = 0
	end
end

local function GetBytes(Count: number): buffer
	local Result = buffer.create(Count)
	local ResultPosition = 0

	while ResultPosition < Count do
		if CSPRNG.BufferPosition >= CSPRNG.BufferSize then
			GenerateBlock()
		end

		local BytesNeeded = Count - ResultPosition
		local BytesAvailable = CSPRNG.BufferSize - CSPRNG.BufferPosition
		local BytesToCopy = math.min(BytesNeeded, BytesAvailable)

		buffer.copy(Result, ResultPosition, CSPRNG.Buffer, CSPRNG.BufferPosition, BytesToCopy)
		ResultPosition += BytesToCopy
		CSPRNG.BufferPosition += BytesToCopy
	end

	return Result
end

local function GetFloat(): number
	if CSPRNG.BufferPosition + 8 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value1 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	local Value2 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition + 4)
	CSPRNG.BufferPosition += 8

	local High = bit32.rshift(Value1, 5)
	local Low = bit32.rshift(Value2, 6)

	return (High * 67108864.0 + Low) / 9007199254740992.0
end

local function GetIntRange(Min: number, Max: number): number
	local Range = Max - Min + 1
	local MaxUInt32 = 0xFFFFFFFF
	local Limit = MaxUInt32 - (MaxUInt32 % Range)

	if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	CSPRNG.BufferPosition += 4

	if bit32.band(Range, Range - 1) == 0 then
		return Min + bit32.band(Value, Range - 1)
	else
		while Value > Limit do
			if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
				GenerateBlock()
			end
			Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
			CSPRNG.BufferPosition += 4
		end

		return Min + (Value % Range)
	end
end

local function GetNumberRange(Min: number, Max: number): number
	if Min > Max then
		Min, Max = Max, Min
	end

	local Range = Max - Min
	if Range <= 0 then
		return Min
	end

	return Min + (GetFloat() * Range)
end

local function GetRandomString(Length: number, AsBuffer: boolean?): string | buffer
	local Characters = buffer.create(Length)

	for Index = 0, Length - 1 do
		buffer.writeu8(Characters, Index, GetIntRange(36, 122))
	end

	return if AsBuffer
		then Characters
		else buffer.tostring(Characters)
end

local function GetEd25519RandomBytes(): buffer
	local Output = buffer.create(32)

	for Index = 0, 31 do
		buffer.writeu8(Output, Index, GetIntRange(0, 255))
	end

	return Output
end

local function GetEd25519ClampedBytes(Input: buffer): buffer
	local Output = buffer.create(32)
	buffer.copy(Output, 0, Input, 0, 32)

	local FirstByte = buffer.readu8(Output, 0)
	FirstByte = bit32.band(FirstByte, 0xF8)
	buffer.writeu8(Output, 0, FirstByte)

	local LastByte = buffer.readu8(Output, 31)
	LastByte = bit32.band(LastByte, 0x7F)
	LastByte = bit32.bor(LastByte, 0x40)
	buffer.writeu8(Output, 31, LastByte)

	local HasVariation = false
	local FirstMiddleByte = buffer.readu8(Output, 1)
	for Index = 2, 30 do
		if buffer.readu8(Output, Index) ~= FirstMiddleByte then
			HasVariation = true
			break
		end
	end

	if not HasVariation then
		buffer.writeu8(Output, 15, bit32.bxor(FirstMiddleByte, 0x55))
	end

	return Output
end

local function GetHexString(Length: number): string
	local BytesNeeded = Length / 2
	local Bytes = GetBytes(BytesNeeded)
	local Hex = Conversions.ToHex(Bytes)

	return Hex
end

function CSPRNG.AddEntropyProvider(ProviderFunction: EntropyProvider)
	table.insert(CSPRNG.EntropyProviders, ProviderFunction)
end

function CSPRNG.RemoveEntropyProvider(ProviderFunction: EntropyProvider)
	for Index = #CSPRNG.EntropyProviders, 1, -1 do
		if CSPRNG.EntropyProviders[Index] == ProviderFunction then
			table.remove(CSPRNG.EntropyProviders, Index)
			break
		end
	end
end

function CSPRNG.Random(): number
	return GetFloat()
end

function CSPRNG.RandomInt(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) can't be less than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 1
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetIntRange(ActualMin, ActualMax)
end

function CSPRNG.RandomNumber(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) must be bigger than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 0
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetNumberRange(ActualMin, ActualMax)
end

function CSPRNG.RandomBytes(Count: number): buffer
	if type(Count) ~= "number" then
		error(`Count must be a number, got {typeof(Count)}`, 2)
	end

	if Count <= 0 then
		error(`Count must be bigger than 0, got {Count}`, 2)
	end

	if Count % 1 ~= 0 then
		error("Count must be an integer", 2)
	end

	return GetBytes(Count)
end

function CSPRNG.RandomString(Length: number, AsBuffer: boolean?): string | buffer
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if AsBuffer ~= nil and type(AsBuffer) ~= "boolean" then
		error(`AsBuffer must be a boolean or nil, got {typeof(AsBuffer)}`, 2)
	end

	return GetRandomString(Length, AsBuffer)
end

function CSPRNG.RandomHex(Length: number): string
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`, 2)
	end

	return GetHexString(Length)
end

function CSPRNG.Ed25519ClampedBytes(Input: buffer): buffer
	if type(Input) ~= "buffer" then
		error(`Input must be a buffer, got {typeof(Input)}`, 2)
	end

	return GetEd25519ClampedBytes(Input)
end

function CSPRNG.Ed25519Random(): buffer
	return GetEd25519ClampedBytes(GetEd25519RandomBytes())
end

function CSPRNG.Reseed(CustomEntropy: buffer?)
	if CustomEntropy ~= nil and type(CustomEntropy) ~= "buffer" then
		error(`CustomEntropy must be a buffer or nil, got {typeof(CustomEntropy)}`, 2)
	end

	Reset()
	GatherEntropy(CustomEntropy)
end

CSPRNG.BytesLeft = GatherEntropy()
GenerateBlock()

return CSPRNG]]></ProtectedString>
							<string name="ScriptGuid">{4591E61C-B08C-4CA5-8335-66855ECBAC97}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CSPRNG</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX157C86539C99441E932DC9BAB625AECF">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Blake3
	
	Sizes:
		Key: 32 bytes
		Output: variable
	
	Return type: string (hex)
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		
		--------Standard Hash--------
		local Hash = Blake3.Digest(Message, 32)
		
		--------Keyed Hash--------
		local KeyedHash = Blake3.DigestKeyed(Key, Message, 32)
		
		--------Key Derivation--------
		local Context = buffer.fromstring("my context")
		local KeyDeriver = Blake3.DeriveKey(Context)
		local DerivedKey = KeyDeriver(Message, 32)
--]=]

--!strict
--!optimize 2
--!native

local BLOCK_SIZE = 64
local CV_SIZE = 32
local EXTENDED_CV_SIZE = 64
local MAX_STACK_DEPTH = 64
local STACK_BUFFER_SIZE = MAX_STACK_DEPTH * CV_SIZE

local CHUNK_START = 0x01
local CHUNK_END = 0x02
local PARENT_FLAG = 0x04
local ROOT_FLAG = 0x08

local INITIAL_VECTORS = buffer.create(CV_SIZE) do
	local IV = {
		0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
		0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
	}
	for Index, Value in ipairs(IV) do
		buffer.writeu32(INITIAL_VECTORS, (Index - 1) * 4, Value)
	end
end

local function Compress(Hash: buffer, MessageBlock: buffer, Counter: number, V14: number, V15: number, IsFull: boolean?): buffer
	local Hash00 = buffer.readu32(Hash, 0)
	local Hash01 = buffer.readu32(Hash, 4)
	local Hash02 = buffer.readu32(Hash, 8)
	local Hash03 = buffer.readu32(Hash, 12)
	local Hash04 = buffer.readu32(Hash, 16)
	local Hash05 = buffer.readu32(Hash, 20)
	local Hash06 = buffer.readu32(Hash, 24)
	local Hash07 = buffer.readu32(Hash, 28)

	local V00, V01, V02, V03 = Hash00, Hash01, Hash02, Hash03
	local V04, V05, V06, V07 = Hash04, Hash05, Hash06, Hash07
	local V08, V09, V10, V11 = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a

	local V12 = Counter % (2 ^ 32)
	local V13 = (Counter - V12) * (2 ^ -32)

	local M00 = buffer.readu32(MessageBlock, 0)
	local M01 = buffer.readu32(MessageBlock, 4)
	local M02 = buffer.readu32(MessageBlock, 8)
	local M03 = buffer.readu32(MessageBlock, 12)
	local M04 = buffer.readu32(MessageBlock, 16)
	local M05 = buffer.readu32(MessageBlock, 20)
	local M06 = buffer.readu32(MessageBlock, 24)
	local M07 = buffer.readu32(MessageBlock, 28)
	local M08 = buffer.readu32(MessageBlock, 32)
	local M09 = buffer.readu32(MessageBlock, 36)
	local M10 = buffer.readu32(MessageBlock, 40)
	local M11 = buffer.readu32(MessageBlock, 44)
	local M12 = buffer.readu32(MessageBlock, 48)
	local M13 = buffer.readu32(MessageBlock, 52)
	local M14 = buffer.readu32(MessageBlock, 56)
	local M15 = buffer.readu32(MessageBlock, 60)

	local Temp
	for Index = 1, 7 do
		V00 += V04 + M00; V12 = bit32.lrotate(bit32.bxor(V12, V00), 16)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 20)
		V00 += V04 + M01; V12 = bit32.lrotate(bit32.bxor(V12, V00), 24)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 25)

		V01 += V05 + M02; V13 = bit32.lrotate(bit32.bxor(V13, V01), 16)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 20)
		V01 += V05 + M03; V13 = bit32.lrotate(bit32.bxor(V13, V01), 24)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 25)

		V02 += V06 + M04; V14 = bit32.lrotate(bit32.bxor(V14, V02), 16)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 20)
		V02 += V06 + M05; V14 = bit32.lrotate(bit32.bxor(V14, V02), 24)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 25)

		V03 += V07 + M06; V15 = bit32.lrotate(bit32.bxor(V15, V03), 16)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 20)
		V03 += V07 + M07; V15 = bit32.lrotate(bit32.bxor(V15, V03), 24)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 25)

		V00 += V05 + M08; V15 = bit32.lrotate(bit32.bxor(V15, V00), 16)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 20)
		V00 += V05 + M09; V15 = bit32.lrotate(bit32.bxor(V15, V00), 24)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 25)

		V01 += V06 + M10; V12 = bit32.lrotate(bit32.bxor(V12, V01), 16)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 20)
		V01 += V06 + M11; V12 = bit32.lrotate(bit32.bxor(V12, V01), 24)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 25)

		V02 += V07 + M12; V13 = bit32.lrotate(bit32.bxor(V13, V02), 16)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 20)
		V02 += V07 + M13; V13 = bit32.lrotate(bit32.bxor(V13, V02), 24)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 25)

		V03 += V04 + M14; V14 = bit32.lrotate(bit32.bxor(V14, V03), 16)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 20)
		V03 += V04 + M15; V14 = bit32.lrotate(bit32.bxor(V14, V03), 24)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 25)

		if Index ~= 7 then
			Temp = M02
			M02 = M03
			M03 = M10
			M10 = M12
			M12 = M09
			M09 = M11
			M11 = M05
			M05 = M00
			M00 = Temp

			Temp = M06
			M06 = M04
			M04 = M07
			M07 = M13
			M13 = M14
			M14 = M15
			M15 = M08
			M08 = M01
			M01 = Temp
		end
	end

	if IsFull then
		local Result = buffer.create(EXTENDED_CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		buffer.writeu32(Result, 32, bit32.bxor(V08, Hash00))
		buffer.writeu32(Result, 36, bit32.bxor(V09, Hash01))
		buffer.writeu32(Result, 40, bit32.bxor(V10, Hash02))
		buffer.writeu32(Result, 44, bit32.bxor(V11, Hash03))
		buffer.writeu32(Result, 48, bit32.bxor(V12, Hash04))
		buffer.writeu32(Result, 52, bit32.bxor(V13, Hash05))
		buffer.writeu32(Result, 56, bit32.bxor(V14, Hash06))
		buffer.writeu32(Result, 60, bit32.bxor(V15, Hash07))

		return Result
	else
		local Result = buffer.create(CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		return Result
	end
end

local function ProcessMessage(InitialHashVector: buffer, Flags: number, Message: buffer, Length: number): buffer
	local MessageLength = buffer.len(Message)
	local StateCvs = buffer.create(STACK_BUFFER_SIZE)
	local StackSize = 0
	local StateCv = buffer.create(CV_SIZE)
	buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)

	local StateCounter = 0
	local StateChunkNumber = 0
	local StateEndFlag = 0
	local StateStartFlag = CHUNK_START

	local BlockBuffer = buffer.create(BLOCK_SIZE)

	for BlockOffset = 0, MessageLength - BLOCK_SIZE - 1, BLOCK_SIZE do
		buffer.copy(BlockBuffer, 0, Message, BlockOffset, BLOCK_SIZE)
		local StateFlags = Flags + StateStartFlag + StateEndFlag

		StateCv = Compress(StateCv, BlockBuffer, StateCounter, BLOCK_SIZE, StateFlags)
		StateStartFlag = 0
		StateChunkNumber += 1

		if StateChunkNumber == 15 then
			StateEndFlag = CHUNK_END
		elseif StateChunkNumber == 16 then
			local MergeCv = StateCv
			local MergeAmount = StateCounter + 1

			while MergeAmount % 2 == 0 do
				StackSize = StackSize - 1
				local PopCv = buffer.create(CV_SIZE)
				buffer.copy(PopCv, 0, StateCvs, StackSize * CV_SIZE, CV_SIZE)

				local Block = buffer.create(EXTENDED_CV_SIZE)
				buffer.copy(Block, 0, PopCv, 0, CV_SIZE)
				buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

				MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
				MergeAmount = MergeAmount / 2
			end

			buffer.copy(StateCvs, StackSize * CV_SIZE, MergeCv, 0, CV_SIZE)
			StackSize = StackSize + 1
			buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)
			StateStartFlag = CHUNK_START

			StateCounter += 1
			StateChunkNumber = 0
			StateEndFlag = 0
		end
	end

	local LastLength = MessageLength == 0 and 0 or ((MessageLength - 1) % BLOCK_SIZE + 1)
	local PaddedMessage = buffer.create(BLOCK_SIZE)

	if LastLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, MessageLength - LastLength, LastLength)
	end

	local OutputCv: buffer
	local OutputBlock: buffer
	local OutputLength: number
	local OutputFlags: number

	if StateCounter > 0 then
		local StateFlags = Flags + StateStartFlag + CHUNK_END
		local MergeCv = Compress(StateCv, PaddedMessage, StateCounter, LastLength, StateFlags)

		for Index = StackSize, 2, -1 do
			local StackCv = buffer.create(CV_SIZE)
			buffer.copy(StackCv, 0, StateCvs, (Index - 1) * CV_SIZE, CV_SIZE)

			local Block = buffer.create(EXTENDED_CV_SIZE)
			buffer.copy(Block, 0, StackCv, 0, CV_SIZE)
			buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

			MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
		end

		OutputCv = InitialHashVector
		local FirstStackCv = buffer.create(CV_SIZE)
		buffer.copy(FirstStackCv, 0, StateCvs, 0, CV_SIZE)

		OutputBlock = buffer.create(EXTENDED_CV_SIZE)
		buffer.copy(OutputBlock, 0, FirstStackCv, 0, CV_SIZE)
		buffer.copy(OutputBlock, CV_SIZE, MergeCv, 0, CV_SIZE)

		OutputLength = BLOCK_SIZE
		OutputFlags = Flags + ROOT_FLAG + PARENT_FLAG
	else
		OutputCv = StateCv
		OutputBlock = PaddedMessage
		OutputLength = LastLength
		OutputFlags = Flags + StateStartFlag + CHUNK_END + ROOT_FLAG
	end

	local Output = buffer.create(Length)
	local OutputOffset = 0

	for Index = 0, Length // BLOCK_SIZE do
		local MessageDigest = Compress(OutputCv, OutputBlock, Index, OutputLength, OutputFlags, true)

		local BytesToCopy = math.min(BLOCK_SIZE, Length - OutputOffset)
		buffer.copy(Output, OutputOffset, MessageDigest, 0, BytesToCopy)
		OutputOffset += BytesToCopy

		if OutputOffset >= Length then
			break
		end
	end

	return Output
end

return function(Message: buffer, Length: number?): buffer
	return ProcessMessage(INITIAL_VECTORS, 0, Message, Length or 32)
end]]></ProtectedString>
								<string name="ScriptGuid">{8C9E1802-6E85-46DE-959E-5445959D46F3}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Blake3</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX292A3ECAEF984C62A2A06E8B14D08814">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: ChaCha20
	
	Sizes:
		Nonce: 12 bytes
		Key: 16/32 bytes
	
	Return type: buffer
	Example usage:
		local Data = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		local Nonce = buffer.fromstring(string.rep("n", 12))
		
		--------Usage Case 1--------
		local Encrypted = ChaCha20(Data, Key, Nonce)
		
		--------Usage Case 2--------
		local Decrypted = ChaCha20(Encrypted, Key, Nonce)
--]=]

--!strict
--!native
--!optimize 2

local DWORD = 4
local BLOCK_SIZE = 64
local STATE_SIZE = 16

local CHACHA20_NONCE_SIZE = 12
local CHACHA20_KEY_SIZE_16 = 16
local CHACHA20_KEY_SIZE_32 = 32

local SIGMA_CONSTANTS = buffer.create(16) do
	local SigmaBytes = { string.byte("expand 32-byte k", 1, -1) }
	for Index, ByteValue in SigmaBytes do
		buffer.writeu8(SIGMA_CONSTANTS, Index - 1, ByteValue)
	end
end

local TAU_CONSTANTS = buffer.create(16) do
	local TauBytes = { string.byte("expand 16-byte k", 1, -1) }
	for Index, ByteValue in TauBytes do
		buffer.writeu8(TAU_CONSTANTS, Index - 1, ByteValue)
	end
end

local function ProcessBlock(InitialState: buffer, Rounds: number)
	local S0: number, S1: number, S2: number, S3: number, S4: number, S5: number, S6: number, S7: number, S8: number, S9: number, S10: number, S11: number, S12: number, S13: number, S14: number, S15: number =
		buffer.readu32(InitialState, 0), buffer.readu32(InitialState, 4),
		buffer.readu32(InitialState, 8), buffer.readu32(InitialState, 12),
		buffer.readu32(InitialState, 16), buffer.readu32(InitialState, 20),
		buffer.readu32(InitialState, 24), buffer.readu32(InitialState, 28),
		buffer.readu32(InitialState, 32), buffer.readu32(InitialState, 36),
		buffer.readu32(InitialState, 40), buffer.readu32(InitialState, 44),
		buffer.readu32(InitialState, 48), buffer.readu32(InitialState, 52),
		buffer.readu32(InitialState, 56), buffer.readu32(InitialState, 60)

	for Round = 1, Rounds do
		local IsOddRound = Round % 2 == 1

		if IsOddRound then
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 16)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 12)
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 8)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 7)

			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 16)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 12)
			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 8)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 7)

			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 16)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 12)
			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 8)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 7)

			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 16)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 12)
			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 8)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 7)
		else
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 16)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 12)
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 8)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 7)

			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 16)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 12)
			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 8)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 7)

			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 16)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 12)
			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 8)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 7)

			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 16)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 12)
			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 8)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 7)
		end
	end
	
	buffer.writeu32(InitialState, 0, buffer.readu32(InitialState, 0) + S0)
	buffer.writeu32(InitialState, 4, buffer.readu32(InitialState, 4) + S1)
	buffer.writeu32(InitialState, 8, buffer.readu32(InitialState, 8) + S2)
	buffer.writeu32(InitialState, 12, buffer.readu32(InitialState, 12) + S3)
	buffer.writeu32(InitialState, 16, buffer.readu32(InitialState, 16) + S4)
	buffer.writeu32(InitialState, 20, buffer.readu32(InitialState, 20) + S5)
	buffer.writeu32(InitialState, 24, buffer.readu32(InitialState, 24) + S6)
	buffer.writeu32(InitialState, 28, buffer.readu32(InitialState, 28) + S7)
	buffer.writeu32(InitialState, 32, buffer.readu32(InitialState, 32) + S8)
	buffer.writeu32(InitialState, 36, buffer.readu32(InitialState, 36) + S9)
	buffer.writeu32(InitialState, 40, buffer.readu32(InitialState, 40) + S10)
	buffer.writeu32(InitialState, 44, buffer.readu32(InitialState, 44) + S11)
	buffer.writeu32(InitialState, 48, buffer.readu32(InitialState, 48) + S12)
	buffer.writeu32(InitialState, 52, buffer.readu32(InitialState, 52) + S13)
	buffer.writeu32(InitialState, 56, buffer.readu32(InitialState, 56) + S14)
	buffer.writeu32(InitialState, 60, buffer.readu32(InitialState, 60) + S15)
end

local function InitializeState(Key: buffer, Nonce: buffer, Counter: number): buffer
	local KeyLength = buffer.len(Key)
	local State = buffer.create(STATE_SIZE * DWORD)

	local Constants = KeyLength == 32 and SIGMA_CONSTANTS or TAU_CONSTANTS

	buffer.copy(State, 0, Constants, 0, 16)

	buffer.copy(State, 16, Key, 0, math.min(KeyLength, 16))
	if KeyLength == 32 then
		buffer.copy(State, 32, Key, 16, 16)
	else
		buffer.copy(State, 32, Key, 0, 16)
	end

	buffer.writeu32(State, 48, Counter)
	buffer.copy(State, 52, Nonce, 0, 12)

	return State
end

local function ChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?): buffer
	if Data == nil then
		error("Data cannot be nil", 2)
	end

	if typeof(Data) ~= "buffer" then
		error(`Data must be a buffer, got {typeof(Data)}`, 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE_16 and KeyLength ~= CHACHA20_KEY_SIZE_32 then
		error(`Key must be {CHACHA20_KEY_SIZE_16} or {CHACHA20_KEY_SIZE_32} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	if NonceLength ~= CHACHA20_NONCE_SIZE then
		error(`Nonce must be exactly {CHACHA20_NONCE_SIZE} bytes long, got {NonceLength} bytes`, 2)
	end

	if Counter then
		if typeof(Counter) ~= "number" then
			error(`Counter must be a number, got {typeof(Counter)}`, 2)
		end

		if Counter < 0 then
			error(`Counter cannot be negative, got {Counter}`, 2)
		end

		if Counter ~= math.floor(Counter) then
			error(`Counter must be an integer, got {Counter}`, 2)
		end

		if Counter >= 2^32 then
			error(`Counter must be less than 2^32, got {Counter}`, 2)
		end
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds ~= math.floor(Rounds) then
			error(`Rounds must be an integer, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockCounter = Counter or 1
	local BlockRounds = Rounds or 20

	local DataLength = buffer.len(Data)
	if DataLength == 0 then
		return buffer.create(0)
	end

	local Output = buffer.create(DataLength)

	local DataOffset = 0

	local State = InitializeState(Key, Nonce, BlockCounter)
	local StateBackup = buffer.create(64)
	buffer.copy(StateBackup, 0, State, 0)
	
	while DataOffset < DataLength do
		ProcessBlock(State, BlockRounds)

		local BytesToProcess = math.min(BLOCK_SIZE, DataLength - DataOffset)

		for Index = 0, BytesToProcess - 1 do
			local DataByte = buffer.readu8(Data, DataOffset + Index)
			local KeystreamByte = buffer.readu8(State, Index)
			buffer.writeu8(Output, DataOffset + Index, bit32.bxor(DataByte, KeystreamByte))
		end

		DataOffset += BytesToProcess
		BlockCounter += 1
		buffer.copy(State, 0, StateBackup, 0)
		buffer.writeu32(State, 48, BlockCounter)
	end
	
	return Output
end

return ChaCha20]]></ProtectedString>
								<string name="ScriptGuid">{ACEA2747-5CFD-44D6-A182-E4E605C72BFF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ChaCha20</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX78038FBB7BA5449187CD4D4F1B55790A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Conversions
	
	Return type: string / buffer
	Example Usage:
		local HexString = Conversions.ToHex(buffer.fromstring("Hello World"))
		local OriginalBuffer = Conversions.FromHex("48656c6c6f20576f726c64")
--]=]

--!strict
--!optimize 2
--!native

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local DECODE_LOOKUP = buffer.create(65536 * 2) do
	for High = 0, 255 do
		for Low = 0, 255 do
			local HighNibble = 0
			local LowNibble = 0

			if High >= 48 and High <= 57 then
				HighNibble = High - 48
			elseif High >= 65 and High <= 70 then
				HighNibble = High - 55
			elseif High >= 97 and High <= 102 then
				HighNibble = High - 87
			else
				HighNibble = 0
			end

			if Low >= 48 and Low <= 57 then
				LowNibble = Low - 48
			elseif Low >= 65 and Low <= 70 then
				LowNibble = Low - 55
			elseif Low >= 97 and Low <= 102 then
				LowNibble = Low - 87
			else
				LowNibble = 0
			end

			local Combined = bit32.lshift(HighNibble, 4) + LowNibble
			local Index = bit32.lshift(Low, 8) + High
			buffer.writeu16(DECODE_LOOKUP, Index * 2, Combined)
		end
	end
end

local Conversions = {}

function Conversions.ToHex(Buffer: buffer): string
	local Length = buffer.len(Buffer)
	local Hex = buffer.create(Length * 2)

	local Lookup = ENCODE_LOOKUP

	local Leftover = Length % 8
	local HexCursor = 0

	for Index = 0, Length - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = Length - Leftover, Length - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex)
end

function Conversions.FromHex(Hex: string | buffer): buffer
	local BufferHex = if type(Hex) == "string" then buffer.fromstring(Hex) else Hex
	local Length = buffer.len(BufferHex)
	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`)
	end

	local Buffer = buffer.create(bit32.rshift(Length, 1))
	local Leftover = Length % 16
	local BufferCursor = 0
	local Lookup = DECODE_LOOKUP

	for Index = 0, Length - Leftover - 1, 16 do
		local Pair1 = buffer.readu16(BufferHex, Index)
		local Pair2 = buffer.readu16(BufferHex, Index + 2)
		local Pair3 = buffer.readu16(BufferHex, Index + 4)
		local Pair4 = buffer.readu16(BufferHex, Index + 6)
		local Pair5 = buffer.readu16(BufferHex, Index + 8)
		local Pair6 = buffer.readu16(BufferHex, Index + 10)
		local Pair7 = buffer.readu16(BufferHex, Index + 12)
		local Pair8 = buffer.readu16(BufferHex, Index + 14)

		local Byte1 = buffer.readu16(Lookup, Pair1 * 2)
		local Byte2 = buffer.readu16(Lookup, Pair2 * 2)
		local Byte3 = buffer.readu16(Lookup, Pair3 * 2)
		local Byte4 = buffer.readu16(Lookup, Pair4 * 2)
		local Byte5 = buffer.readu16(Lookup, Pair5 * 2)
		local Byte6 = buffer.readu16(Lookup, Pair6 * 2)
		local Byte7 = buffer.readu16(Lookup, Pair7 * 2)
		local Byte8 = buffer.readu16(Lookup, Pair8 * 2)

		local Chunk1 = bit32.lshift(Byte4, 24) + bit32.lshift(Byte3, 16) + 
			bit32.lshift(Byte2, 8) + Byte1
		local Chunk2 = bit32.lshift(Byte8, 24) + bit32.lshift(Byte7, 16) + 
			bit32.lshift(Byte6, 8) + Byte5

		buffer.writeu32(Buffer, BufferCursor, Chunk1)
		buffer.writeu32(Buffer, BufferCursor + 4, Chunk2)
		BufferCursor += 8
	end

	for Index = Length - Leftover, Length - 1, 2 do
		local Pair = buffer.readu16(BufferHex, Index)
		local Byte = buffer.readu16(Lookup, Pair * 2)
		buffer.writeu8(Buffer, BufferCursor, Byte)
		BufferCursor += 1
	end

	return Buffer
end

return Conversions]]></ProtectedString>
								<string name="ScriptGuid">{3102B329-F8D5-4497-B666-B1ED668CF0F7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Conversions</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX85D844B28B884111AFE7C880F055DC35">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Conversions
	
	Return type: string / buffer
	Example Usage:
		local HexString = Conversions.ToHex(buffer.fromstring("Hello World"))
		local OriginalBuffer = Conversions.FromHex("48656c6c6f20576f726c64")
--]=]

--!strict
--!optimize 2
--!native

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local DECODE_LOOKUP = buffer.create(65536 * 2) do
	for High = 0, 255 do
		for Low = 0, 255 do
			local HighNibble = 0
			local LowNibble = 0

			if High >= 48 and High <= 57 then
				HighNibble = High - 48
			elseif High >= 65 and High <= 70 then
				HighNibble = High - 55
			elseif High >= 97 and High <= 102 then
				HighNibble = High - 87
			else
				HighNibble = 0
			end

			if Low >= 48 and Low <= 57 then
				LowNibble = Low - 48
			elseif Low >= 65 and Low <= 70 then
				LowNibble = Low - 55
			elseif Low >= 97 and Low <= 102 then
				LowNibble = Low - 87
			else
				LowNibble = 0
			end

			local Combined = bit32.lshift(HighNibble, 4) + LowNibble
			local Index = bit32.lshift(Low, 8) + High
			buffer.writeu16(DECODE_LOOKUP, Index * 2, Combined)
		end
	end
end

local Conversions = {}

function Conversions.ToHex(Buffer: buffer): string
	local Length = buffer.len(Buffer)
	local Hex = buffer.create(Length * 2)

	local Lookup = ENCODE_LOOKUP

	local Leftover = Length % 8
	local HexCursor = 0

	for Index = 0, Length - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = Length - Leftover, Length - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex)
end

function Conversions.FromHex(Hex: string | buffer): buffer
	local BufferHex = if type(Hex) == "string" then buffer.fromstring(Hex) else Hex
	local Length = buffer.len(BufferHex)
	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`)
	end

	local Buffer = buffer.create(bit32.rshift(Length, 1))
	local Leftover = Length % 16
	local BufferCursor = 0
	local Lookup = DECODE_LOOKUP

	for Index = 0, Length - Leftover - 1, 16 do
		local Pair1 = buffer.readu16(BufferHex, Index)
		local Pair2 = buffer.readu16(BufferHex, Index + 2)
		local Pair3 = buffer.readu16(BufferHex, Index + 4)
		local Pair4 = buffer.readu16(BufferHex, Index + 6)
		local Pair5 = buffer.readu16(BufferHex, Index + 8)
		local Pair6 = buffer.readu16(BufferHex, Index + 10)
		local Pair7 = buffer.readu16(BufferHex, Index + 12)
		local Pair8 = buffer.readu16(BufferHex, Index + 14)

		local Byte1 = buffer.readu16(Lookup, Pair1 * 2)
		local Byte2 = buffer.readu16(Lookup, Pair2 * 2)
		local Byte3 = buffer.readu16(Lookup, Pair3 * 2)
		local Byte4 = buffer.readu16(Lookup, Pair4 * 2)
		local Byte5 = buffer.readu16(Lookup, Pair5 * 2)
		local Byte6 = buffer.readu16(Lookup, Pair6 * 2)
		local Byte7 = buffer.readu16(Lookup, Pair7 * 2)
		local Byte8 = buffer.readu16(Lookup, Pair8 * 2)

		local Chunk1 = bit32.lshift(Byte4, 24) + bit32.lshift(Byte3, 16) + 
			bit32.lshift(Byte2, 8) + Byte1
		local Chunk2 = bit32.lshift(Byte8, 24) + bit32.lshift(Byte7, 16) + 
			bit32.lshift(Byte6, 8) + Byte5

		buffer.writeu32(Buffer, BufferCursor, Chunk1)
		buffer.writeu32(Buffer, BufferCursor + 4, Chunk2)
		BufferCursor += 8
	end

	for Index = Length - Leftover, Length - 1, 2 do
		local Pair = buffer.readu16(BufferHex, Index)
		local Byte = buffer.readu16(Lookup, Pair * 2)
		buffer.writeu8(Buffer, BufferCursor, Byte)
		BufferCursor += 1
	end

	return Buffer
end

return Conversions]]></ProtectedString>
							<string name="ScriptGuid">{978819AD-D7BF-4ACA-B8EB-C293E08CF3B9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Conversions</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX61B00C699FC3408399ABB641EFA63403">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Random String Generator
	
	WARNING: This is not using cryptographically secure random numbers. 
	For Security use CSPRNG.
	
	Return type: string | buffer
	Example Usage:
		local String = RandomString(500)
--]=]

--!strict
--!optimize 2
--!native

local function RandomString(Length: number, AsBuffer: boolean?): string | buffer
	local Characters = buffer.create(Length)

	for Index = 0, Length - 1 do
		buffer.writeu8(Characters, Index, math.random(36, 122))
	end

	return if AsBuffer
		then Characters
		else buffer.tostring(Characters)
end

return RandomString]]></ProtectedString>
							<string name="ScriptGuid">{DDB972E0-A655-4DCC-8B7A-11A0250F9542}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">RandomString</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXB9BE3E58B0294D8988A816BBBA7D65D3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!strict

local Algorithms = table.freeze({
	EdDSA = require("@self/EdDSA"),
	MlDSA = require("@self/MlDSA"),
	MlKEM = require("@self/MlKEM"),
})

return Algorithms]]></ProtectedString>
						<string name="ScriptGuid">{56A7F82B-822F-48B3-8B8C-4854D432C075}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Verification</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX07105357E97543D48964FF53C499088D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: EdDSA (Ed25519) with Batch Verification

	Return type: varies by function
	Example usage:
		local EdDSA = require("EdDSA")

		--------Usage Case 1--------
		local SecretKey = RandomBytes.Generate(32)
		local PublicKey = EdDSA.PublicKey(SecretKey)

		--------Usage Case 2--------
		local Message = buffer.fromstring("Hello World")
		local Signature = EdDSA.Sign(Message, SecretKey, PublicKey)

		--------Usage Case 3--------
		local IsValid = EdDSA.Verify(Message, PublicKey, Signature)

		--------Usage Case 4: Batch Verification--------
		local AllValid = EdDSA.VerifyBatch({
			{Message = M1, PublicKey = PK1, Signature = S1},
			{Message = M2, PublicKey = PK2, Signature = S2},
			...
		})
--]=]

--!strict
--!optimize 2
--!native

local FieldQuadratic = require("@self/FieldQuadratic")
local FieldPrime = require("@self/FieldPrime")
local SHA512 = require("@self/SHA512")
local Edwards25519 = require("@self/Edwards25519")
local X25519 = require("@self/X25519")
local CSPRNG = require("@self/CSPRNG")

local ED25519_SECRET_KEY_SIZE = 32
local ED25519_PUBLIC_KEY_SIZE = 32
local ED25519_SIGNATURE_SIZE = 64

local function ConcatBuffers(...): buffer
	local Buffers = {...}
	local TotalLength = 0

	for _, Buffer in Buffers do
		TotalLength += buffer.len(Buffer)
	end

	local Result = buffer.create(TotalLength)
	local Offset = 0

	for _, Buffer in Buffers do
		local Length = buffer.len(Buffer)
		buffer.copy(Result, Offset, Buffer, 0, Length)
		Offset += Length
	end

	return Result
end

export type SignatureEntry = {
	PublicKey: buffer,
	Message: buffer,
	Signature: buffer,
}

local EDDSA = {
	CSPRNG = CSPRNG,
	X25519 = X25519
}

function EDDSA.PublicKey(SecretKey: buffer): buffer
	if SecretKey == nil then
		error("SecretKey cannot be nil", 2)
	end

	if typeof(SecretKey) ~= "buffer" then
		error(`SecretKey must be a buffer, got {typeof(SecretKey)}`, 2)
	end

	local SecretKeyLength = buffer.len(SecretKey)
	if SecretKeyLength ~= ED25519_SECRET_KEY_SIZE then
		error(`SecretKey must be exactly {ED25519_SECRET_KEY_SIZE} bytes long, got {SecretKeyLength} bytes`, 2)
	end

	local Hash = SHA512(SecretKey)
	local FirstHalf = buffer.create(32)
	buffer.copy(FirstHalf, 0, Hash, 0, 32)

	local ScalarX = FieldQuadratic.DecodeClamped(FirstHalf)
	local ScalarBits, BitCount = FieldQuadratic.Bits(ScalarX)

	return Edwards25519.Encode(Edwards25519.MulG(ScalarBits, BitCount))
end

function EDDSA.Sign(Message: buffer, SecretKey: buffer, PublicKey: buffer): buffer
	if SecretKey == nil then
		error("SecretKey cannot be nil", 2)
	end

	if typeof(SecretKey) ~= "buffer" then
		error(`SecretKey must be a buffer, got {typeof(SecretKey)}`, 2)
	end

	local SecretKeyLength = buffer.len(SecretKey)
	if SecretKeyLength ~= ED25519_SECRET_KEY_SIZE then
		error(`SecretKey must be exactly {ED25519_SECRET_KEY_SIZE} bytes long, got {SecretKeyLength} bytes`, 2)
	end

	if PublicKey == nil then
		error("PublicKey cannot be nil", 2)
	end

	if typeof(PublicKey) ~= "buffer" then
		error(`PublicKey must be a buffer, got {typeof(PublicKey)}`, 2)
	end

	local PublicKeyLength = buffer.len(PublicKey)
	if PublicKeyLength ~= ED25519_PUBLIC_KEY_SIZE then
		error(`PublicKey must be exactly {ED25519_PUBLIC_KEY_SIZE} bytes long, got {PublicKeyLength} bytes`, 2)
	end

	if Message == nil then
		error("Message cannot be nil", 2)
	end

	if typeof(Message) ~= "buffer" then
		error(`Message must be a buffer, got {typeof(Message)}`, 2)
	end

	local Hash = SHA512(SecretKey)

	local FirstHalf = buffer.create(32)
	buffer.copy(FirstHalf, 0, Hash, 0, 32)
	local ScalarX = FieldQuadratic.DecodeClamped(FirstHalf)

	local SecondHalf = buffer.create(32)
	buffer.copy(SecondHalf, 0, Hash, 32, 32)

	local NonceSource = ConcatBuffers(SecondHalf, Message)
	local NonceHash = SHA512(NonceSource)
	local NonceK = FieldQuadratic.DecodeWide(NonceHash)

	local NonceBits, NonceBitCount = FieldQuadratic.Bits(NonceK)
	local CommitmentR = Edwards25519.MulG(NonceBits, NonceBitCount)
	local CommitmentString = Edwards25519.Encode(CommitmentR)

	local ChallengeInput = ConcatBuffers(CommitmentString, PublicKey, Message)
	local ChallengeHash = SHA512(ChallengeInput)
	local ChallengeE = FieldQuadratic.DecodeWide(ChallengeHash)

	local ResponseS = FieldQuadratic.Add(NonceK, FieldQuadratic.Mul(ScalarX, ChallengeE))
	local ResponseString = FieldQuadratic.Encode(ResponseS)

	return ConcatBuffers(CommitmentString, ResponseString)
end

function EDDSA.Verify(Message: buffer, PublicKey: buffer, Signature: buffer): boolean
	if PublicKey == nil then
		error("PublicKey cannot be nil", 2)
	end

	if typeof(PublicKey) ~= "buffer" then
		error(`PublicKey must be a buffer, got {typeof(PublicKey)}`, 2)
	end

	local PublicKeyLength = buffer.len(PublicKey)
	if PublicKeyLength ~= ED25519_PUBLIC_KEY_SIZE then
		error(`PublicKey must be exactly {ED25519_PUBLIC_KEY_SIZE} bytes long, got {PublicKeyLength} bytes`, 2)
	end

	if Message == nil then
		error("Message cannot be nil", 2)
	end

	if typeof(Message) ~= "buffer" then
		error(`Message must be a buffer, got {typeof(Message)}`, 2)
	end

	if Signature == nil then
		error("Signature cannot be nil", 2)
	end

	if typeof(Signature) ~= "buffer" then
		error(`Signature must be a buffer, got {typeof(Signature)}`, 2)
	end

	local SignatureLength = buffer.len(Signature)
	if SignatureLength ~= ED25519_SIGNATURE_SIZE then
		error(`Signature must be exactly {ED25519_SIGNATURE_SIZE} bytes long, got {SignatureLength} bytes`, 2)
	end

	local LastByte = buffer.readu8(Signature, 63)
	if bit32.band(LastByte, 0xE0) ~= 0x00 then
		return false
	end

	local CommitmentBytes = buffer.create(32)
	buffer.copy(CommitmentBytes, 0, Signature, 0, 32)
	local ResponseBytes = buffer.create(32)
	buffer.copy(ResponseBytes, 0, Signature, 32, 32)

	if not FieldQuadratic.IsValidScalar(ResponseBytes) then
		return false
	end

	local PublicPoint = Edwards25519.Decode(PublicKey)
	if not PublicPoint then
		return false
	end

	local CommitmentPoint = Edwards25519.Decode(CommitmentBytes)
	if not CommitmentPoint then
		return false
	end

	local ChallengeInput = ConcatBuffers(CommitmentBytes, PublicKey, Message)
	local ChallengeHash = SHA512(ChallengeInput)
	local ChallengeScalar = FieldQuadratic.DecodeWide(ChallengeHash)

	local ResponseScalar = FieldQuadratic.Decode(ResponseBytes)
	local ResponseBits, ResponseBitCount = FieldQuadratic.Bits(ResponseScalar)
	local SB = Edwards25519.MulG(ResponseBits, ResponseBitCount)

	local ChallengeBits, ChallengeBitCount = FieldQuadratic.Bits(ChallengeScalar)
	local KA = Edwards25519.Mul(PublicPoint, ChallengeBits, ChallengeBitCount)

	local KANiels = Edwards25519.Niels(KA)
	local RKA = Edwards25519.Add(CommitmentPoint, KANiels)

	local SBNiels = Edwards25519.Niels(SB)
	local Difference = Edwards25519.Sub(RKA, SBNiels)

	Difference = Edwards25519.Double(Difference)
	Difference = Edwards25519.Double(Difference)
	Difference = Edwards25519.Double(Difference)

	local DifferenceX = buffer.create(104)
	local DifferenceT = buffer.create(104)
	buffer.copy(DifferenceX, 0, Difference, 0 * 104, 104)
	buffer.copy(DifferenceT, 0, Difference, 3 * 104, 104)

	local XIsZero = FieldPrime.Eqz(DifferenceX)
	local TIsZero = FieldPrime.Eqz(DifferenceT)

	return XIsZero and TIsZero
end

function EDDSA.VerifyBatch(Entries: {SignatureEntry}): boolean
	local Count = #Entries
	if Count == 0 then
		return true
	end

	if Count == 1 then
		local Entry = Entries[1]
		return EDDSA.Verify(Entry.Message, Entry.PublicKey, Entry.Signature)
	end

	local TranscriptData = {}
	local ParsedData = {}

	for Index, Entry in Entries do
		local PublicKey = Entry.PublicKey
		local Message = Entry.Message
		local Signature = Entry.Signature

		if typeof(PublicKey) ~= "buffer" or buffer.len(PublicKey) ~= ED25519_PUBLIC_KEY_SIZE then
			return false
		end

		if typeof(Message) ~= "buffer" then
			return false
		end

		if typeof(Signature) ~= "buffer" or buffer.len(Signature) ~= ED25519_SIGNATURE_SIZE then
			return false
		end

		local LastByte = buffer.readu8(Signature, 63)
		if bit32.band(LastByte, 0xE0) ~= 0x00 then
			return false
		end

		local CommitmentBytes = buffer.create(32)
		buffer.copy(CommitmentBytes, 0, Signature, 0, 32)
		local ResponseBytes = buffer.create(32)
		buffer.copy(ResponseBytes, 0, Signature, 32, 32)

		if not FieldQuadratic.IsValidScalar(ResponseBytes) then
			return false
		end

		local PublicPoint = Edwards25519.Decode(PublicKey)
		if not PublicPoint then
			return false
		end

		local CommitmentPoint = Edwards25519.Decode(CommitmentBytes)
		if not CommitmentPoint then
			return false
		end

		local ChallengeInput = ConcatBuffers(CommitmentBytes, PublicKey, Message)
		local ChallengeHash = SHA512(ChallengeInput)
		local ChallengeScalar = FieldQuadratic.DecodeWide(ChallengeHash)

		local ResponseScalar = FieldQuadratic.Decode(ResponseBytes)

		table.insert(TranscriptData, ChallengeHash)
		table.insert(TranscriptData, ResponseBytes)

		ParsedData[Index] = {
			PublicPoint = PublicPoint,
			CommitmentPoint = CommitmentPoint,
			ChallengeScalar = ChallengeScalar,
			ResponseScalar = ResponseScalar,
		}
	end

	local TranscriptBuffer = ConcatBuffers(table.unpack(TranscriptData))

	local SumS: buffer? = nil
	local Accumulator: buffer? = nil

	for Index, Parsed in ParsedData do
		local IndexBuffer = buffer.create(2)
		buffer.writeu16(IndexBuffer, 0, Index)
		local ZInput = ConcatBuffers(IndexBuffer, TranscriptBuffer)
		local ZHash = SHA512(ZInput)

		local ZBytes = buffer.create(32)
		buffer.copy(ZBytes, 0, ZHash, 0, 32)
		buffer.writeu8(ZBytes, 31, bit32.band(buffer.readu8(ZBytes, 31), 0x0F))
		local Z = FieldQuadratic.Decode(ZBytes)

		local ZS = FieldQuadratic.Mul(Z, Parsed.ResponseScalar)
		if SumS == nil then
			SumS = ZS
		else
			SumS = FieldQuadratic.Add(SumS, ZS)
		end

		local ZH = FieldQuadratic.Mul(Z, Parsed.ChallengeScalar)
		local ZHBits, ZHBitCount = FieldQuadratic.Bits(ZH)
		local ZHA = Edwards25519.Mul(Parsed.PublicPoint, ZHBits, ZHBitCount)

		local ZBits, ZBitCount = FieldQuadratic.Bits(Z)
		local ZR = Edwards25519.Mul(Parsed.CommitmentPoint, ZBits, ZBitCount)

		local ZHANiels = Edwards25519.Niels(ZHA)
		local ZRHA = Edwards25519.Add(ZR, ZHANiels)

		if Accumulator == nil then
			Accumulator = ZRHA
		else
			local ZRHANiels = Edwards25519.Niels(ZRHA)
			Accumulator = Edwards25519.Add(Accumulator, ZRHANiels)
		end
	end

	if SumS == nil or Accumulator == nil then
		return false
	end

	local SumSBits, SumSBitCount = FieldQuadratic.Bits(SumS)
	local LeftSide = Edwards25519.MulG(SumSBits, SumSBitCount)

	local LeftNiels = Edwards25519.Niels(LeftSide)
	local Difference = Edwards25519.Sub(Accumulator :: buffer, LeftNiels)

	Difference = Edwards25519.Double(Difference)
	Difference = Edwards25519.Double(Difference)
	Difference = Edwards25519.Double(Difference)

	local DifferenceX = buffer.create(104)
	local DifferenceT = buffer.create(104)
	buffer.copy(DifferenceX, 0, Difference, 0 * 104, 104)
	buffer.copy(DifferenceT, 0, Difference, 3 * 104, 104)

	local XIsZero = FieldPrime.Eqz(DifferenceX)
	local TIsZero = FieldPrime.Eqz(DifferenceT)

	return XIsZero and TIsZero
end

return EDDSA]]></ProtectedString>
							<string name="ScriptGuid">{720C2D62-3754-4986-8D96-96ADEFCE719F}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">EdDSA</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX4974CEA934C0463DA1161FFC81768BCF">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Cryptographically Secure RNG
	
	Usage:
		local RandomFloat = CSPRNG.Random()
		local RandomInt = CSPRNG.RandomInt(1, 100)
		local RandomNumber = CSPRNG.RandomNumber(0.5, 10.5)
		local RandomBytes = CSPRNG.RandomBytes(32)
		local RandomHex = CSPRNG.RandomHex(16)
		local FastString = CSPRNG.RandomString(16, false)
		local FastBuffer = CSPRNG.RandomString(32, true)
		
		local Ed25519Clamped = CSPRNG.Ed25519ClampedBytes(SomeBuffer)
		local Ed25519Random = CSPRNG.Ed25519Random()
		
		CSPRNG.AddEntropyProvider(function)
		CSPRNG.RemoveEntropyProvider(function)
		CSPRNG.Reseed()
		
		CSPRNG.BytesLeft
--]=]

--!native
--!optimize 2
--!strict

local Conversions = require("@self/Conversions")
local ChaCha20 = require("@self/ChaCha20")
local Blake3 = require("@self/Blake3")

export type EntropyProvider = (BytesLeft: number) -> buffer?

type CSPRNGModule = {
	BlockExpansion: boolean,

	SizeTarget: number,
	RekeyAfter: number,

	Key: buffer,
	Nonce: buffer,
	Buffer: buffer,

	Counter: number,
	BufferPosition: number,
	BufferSize: number,
	BytesLeft: number,

	EntropyProviders: { EntropyProvider },

	Reseed: (CustomEntropy: buffer?) -> (),
	AddEntropyProvider: (ProviderFunction: EntropyProvider) -> (),
	RemoveEntropyProvider: (ProviderFunction: EntropyProvider) -> (),

	Random: () -> number,
	RandomInt: (Min: number, Max: number?) -> number,
	RandomNumber: (Min: number, Max: number?) -> number,
	RandomBytes: (Count: number) -> buffer,
	RandomString: (Length: number, AsBuffer: boolean?) -> string | buffer,
	RandomHex: (Length: number) -> string,
	Ed25519ClampedBytes: (Input: buffer) -> buffer,
	Ed25519Random: () -> buffer,
}

local BLOCK_SIZE = 64
local KEY_SIZE = 32
local NONCE_SIZE = 12

local CSPRNG: CSPRNGModule = {
	BlockExpansion = true,
	SizeTarget = 2048,
	RekeyAfter = 1024,

	Key = buffer.create(0),
	Nonce = buffer.create(0),
	Buffer = buffer.create(0),

	Counter = 0,
	BufferPosition = 0,
	BufferSize = 0,
	BytesLeft = 0,

	EntropyProviders = {}
} :: CSPRNGModule

local INPUT_BUFFER = buffer.create(BLOCK_SIZE)
local REKEY_THRESHOLD = math.max(math.floor(CSPRNG.RekeyAfter), 2)
local SIZE_TARGET_CLAMPED = math.clamp(math.floor(CSPRNG.SizeTarget), 64, 4294967295)

local function Reset()
	CSPRNG.Key = buffer.create(0)
	CSPRNG.Nonce = buffer.create(0)
	CSPRNG.Buffer = buffer.create(0)

	CSPRNG.Counter = 0
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = 0
end

local function GatherEntropy(CustomEntropy: buffer?): number
	local EntropyBuffers = buffer.create(1024)
	local Offset = 0

	local function WriteToBuffer(Source: buffer)
		local Size = buffer.len(Source)
		buffer.copy(EntropyBuffers, Offset, Source, 0, Size)
		Offset += Size
	end

	local CurrentTime = 1.234
	if tick then
		CurrentTime = tick()
		local TimeBuffer = buffer.create(8)
		buffer.writef64(TimeBuffer, 0, CurrentTime)
		WriteToBuffer(TimeBuffer)
	end

	local ClockTime = os.clock()
	local ClockBuffer = buffer.create(8)
	buffer.writef64(ClockBuffer, 0, ClockTime)
	WriteToBuffer(ClockBuffer)

	local UnixTime = os.time()
	local UnixBuffer = buffer.create(8)
	buffer.writeu32(UnixBuffer, 0, UnixTime % 0x100000000)
	buffer.writeu32(UnixBuffer, 4, math.floor(UnixTime / 0x100000000))
	WriteToBuffer(UnixBuffer)

	local DateTimeMillis = 5.678
	if DateTime then
		DateTimeMillis = DateTime.now().UnixTimestampMillis
		local DateTimeBuffer = buffer.create(8)
		buffer.writef64(DateTimeBuffer, 0, DateTimeMillis)
		WriteToBuffer(DateTimeBuffer)

		local DateTimePrecisionBuffer = buffer.create(16)
		buffer.writef32(DateTimePrecisionBuffer, 0, DateTimeMillis / 1000)
		buffer.writef32(DateTimePrecisionBuffer, 4, (DateTimeMillis % 1000) / 100)
		buffer.writef32(DateTimePrecisionBuffer, 8, DateTimeMillis / 86400000)
		buffer.writef32(DateTimePrecisionBuffer, 12, (DateTimeMillis * 0.001) % 1)
		WriteToBuffer(DateTimePrecisionBuffer)
	else
		WriteToBuffer(buffer.create(24))
	end

	local FracTimeBuffer = buffer.create(16)
	buffer.writef32(FracTimeBuffer, 0, ClockTime / 100)
	buffer.writef32(FracTimeBuffer, 4, CurrentTime / 1000)
	buffer.writef32(FracTimeBuffer, 8, (ClockTime * 12345.6789) % 1)
	buffer.writef32(FracTimeBuffer, 12, (CurrentTime * 98765.4321) % 1)
	WriteToBuffer(FracTimeBuffer)

	local NoiseBuffer = buffer.create(32)
	for Index = 0, 7 do
		local Noise1 = math.noise(ClockTime + Index, UnixTime + Index, ClockTime + UnixTime + Index)
		local Noise2 = math.noise(CurrentTime + Index * 0.1, DateTimeMillis * 0.0001 + Index, ClockTime * 1.5 + Index)
		local Noise3 = math.noise(UnixTime * 0.01 + Index, ClockTime + DateTimeMillis * 0.001, CurrentTime + Index * 2)
		local Noise4 = math.noise(DateTimeMillis * 0.00001 + Index, UnixTime + ClockTime + Index, CurrentTime * 0.1 + Index)

		buffer.writef32(NoiseBuffer, Index * 4, Noise1 + Noise2 + Noise3 + Noise4)
	end
	WriteToBuffer(NoiseBuffer)

	local BenchmarkTimings = buffer.create(32)
	for Index = 0, 7 do
		local StartTime = os.clock()
		local Sum = 0

		local Iterations = 50 + (Index * 25)
		for Iteration = 1, Iterations do
			Sum += Iteration * Iteration + math.sin(Iteration / 10) * math.cos(Iteration / 7)
		end

		local EndTime = os.clock()
		local TimingDelta = EndTime - StartTime
		buffer.writef32(BenchmarkTimings, Index * 4, TimingDelta * 1000000)
	end
	WriteToBuffer(BenchmarkTimings)

	local AllocTimings = buffer.create(24)
	for Index = 0, 5 do
		local AllocStart = os.clock()

		for AllocIndex = 1, 20 do
			local _TempBuf = buffer.create(64 + AllocIndex)
		end

		local AllocEnd = os.clock()
		buffer.writef32(AllocTimings, Index * 4, (AllocEnd - AllocStart) * 10000000)
	end
	WriteToBuffer(AllocTimings)

	local MicroTime = math.floor(CurrentTime * 1000000)
	local MicroTimeBuffer = buffer.create(8)
	buffer.writeu32(MicroTimeBuffer, 0, MicroTime % 0x100000000)
	buffer.writeu32(MicroTimeBuffer, 4, math.floor(MicroTime / 0x100000000))
	WriteToBuffer(MicroTimeBuffer)

	if game then
		if game.JobId and #game.JobId > 0 then
			local JobIdBuffer = buffer.fromstring(game.JobId)
			WriteToBuffer(JobIdBuffer)
		end

		if game.PlaceId then
			local PlaceIdBuffer = buffer.create(8)
			buffer.writeu32(PlaceIdBuffer, 0, game.PlaceId % 0x100000000)
			buffer.writeu32(PlaceIdBuffer, 4, math.floor(game.PlaceId / 0x100000000))
			WriteToBuffer(PlaceIdBuffer)
		end

		if workspace and workspace.DistributedGameTime then
			local DistTimeBuffer = buffer.create(8)
			buffer.writef64(DistTimeBuffer, 0, workspace.DistributedGameTime)
			WriteToBuffer(DistTimeBuffer)

			local DistMicroTime = math.floor(workspace.DistributedGameTime * 1000000)
			local DistMicroBuffer = buffer.create(8)
			buffer.writeu32(DistMicroBuffer, 0, DistMicroTime % 0x100000000)
			buffer.writeu32(DistMicroBuffer, 4, math.floor(DistMicroTime / 0x100000000))
			WriteToBuffer(DistMicroBuffer)
		end
	end

	local AddressEntropy = buffer.create(128)
	for Index = 0, 7 do
		local TempTable = {}
		local TempFunc = function() end
		local TempBuffer = buffer.create(0)
		local TempUserdata = newproxy()

		local TableAddr = string.gsub(tostring(TempTable), "table: ", "")
		local FuncAddr = string.gsub(tostring(TempFunc), "function: ", "")
		local BufferAddr = string.gsub(tostring(TempBuffer), "buffer: ", "")
		local UserdataAddr = string.gsub(tostring(TempUserdata), "userdata: ", "")

		local TableHash = 0
		local ThreadHash = 0
		local FuncHash = 0
		local BufferHash = 0
		local UserdataHash = 0

		for AddrIndex = 1, #TableAddr do
			TableHash = bit32.bxor(TableHash, string.byte(TableAddr, AddrIndex)) * 31
		end

		if coroutine then
			local ThreadAddr = string.gsub(tostring(coroutine.create(function() end)), "thread: ", "")
			for AddrIndex = 1, #ThreadAddr do
				ThreadHash = bit32.bxor(ThreadHash, string.byte(ThreadAddr, AddrIndex)) * 31
			end
		end

		for AddrIndex = 1, #FuncAddr do
			FuncHash = bit32.bxor(FuncHash, string.byte(FuncAddr, AddrIndex)) * 37
		end
		for AddrIndex = 1, #BufferAddr do
			BufferHash = bit32.bxor(BufferHash, string.byte(BufferAddr, AddrIndex)) * 41
		end
		for AddrIndex = 1, #UserdataAddr do
			UserdataHash = bit32.bxor(UserdataHash, string.byte(UserdataAddr, AddrIndex)) * 43
		end

		buffer.writeu32(AddressEntropy, Index * 16, TableHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 4, ThreadHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 8, FuncHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 12, bit32.bxor(BufferHash, UserdataHash))
	end
	WriteToBuffer(AddressEntropy)

	local function AddExtraEntropy(Entropy: buffer?, Warn: boolean, Provider: string?)
		if not Entropy then
			return
		end

		local BytesLeft = 1024 - Offset

		if BytesLeft > 0 then
			local Extra = buffer.len(Entropy) - BytesLeft
			local Truncated = math.min(BytesLeft, buffer.len(Entropy))

			if Extra > 0 and Warn and Provider then
				warn(`CSPRNG: {Provider} returned {Extra} bytes more than available and was truncated to {Truncated} bytes`)
			end

			buffer.copy(EntropyBuffers, Offset, Entropy, 0, Truncated)
		end
	end

	for Index, Provider in CSPRNG.EntropyProviders do
		local BytesLeft = 1024 - Offset
		if BytesLeft > 0 then
			local Success: boolean, ExtraEntropy: buffer? = pcall(Provider, BytesLeft)
			if not Success then
				warn(`CSPRNG Provider errored with {ExtraEntropy}`)
			end

			AddExtraEntropy(ExtraEntropy, true, `Entropy Provider #{Index}`)
		end
	end

	if CustomEntropy then
		AddExtraEntropy(CustomEntropy, false)
	end

	local KeyMaterial = Blake3(EntropyBuffers, KEY_SIZE + NONCE_SIZE)

	CSPRNG.Key = buffer.create(KEY_SIZE)
	buffer.copy(CSPRNG.Key, 0, KeyMaterial, 0, KEY_SIZE)

	CSPRNG.Nonce = buffer.create(NONCE_SIZE)
	buffer.copy(CSPRNG.Nonce, 0, KeyMaterial, KEY_SIZE, NONCE_SIZE)

	return buffer.len(EntropyBuffers) - Offset
end

local function GenerateBlock()
	buffer.fill(INPUT_BUFFER, 0, 0, BLOCK_SIZE)
	local ChaChaOutput = ChaCha20(INPUT_BUFFER, CSPRNG.Key, CSPRNG.Nonce, CSPRNG.Counter, 20)

	CSPRNG.Buffer = if CSPRNG.BlockExpansion then Blake3(ChaChaOutput, SIZE_TARGET_CLAMPED) else ChaChaOutput
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = buffer.len(CSPRNG.Buffer)
	CSPRNG.Counter += 1

	if CSPRNG.Counter % REKEY_THRESHOLD == 0 then
		GatherEntropy() 
		CSPRNG.Counter = 0
	end
end

local function GetBytes(Count: number): buffer
	local Result = buffer.create(Count)
	local ResultPosition = 0

	while ResultPosition < Count do
		if CSPRNG.BufferPosition >= CSPRNG.BufferSize then
			GenerateBlock()
		end

		local BytesNeeded = Count - ResultPosition
		local BytesAvailable = CSPRNG.BufferSize - CSPRNG.BufferPosition
		local BytesToCopy = math.min(BytesNeeded, BytesAvailable)

		buffer.copy(Result, ResultPosition, CSPRNG.Buffer, CSPRNG.BufferPosition, BytesToCopy)
		ResultPosition += BytesToCopy
		CSPRNG.BufferPosition += BytesToCopy
	end

	return Result
end

local function GetFloat(): number
	if CSPRNG.BufferPosition + 8 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value1 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	local Value2 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition + 4)
	CSPRNG.BufferPosition += 8

	local High = bit32.rshift(Value1, 5)
	local Low = bit32.rshift(Value2, 6)

	return (High * 67108864.0 + Low) / 9007199254740992.0
end

local function GetIntRange(Min: number, Max: number): number
	local Range = Max - Min + 1
	local MaxUInt32 = 0xFFFFFFFF
	local Limit = MaxUInt32 - (MaxUInt32 % Range)

	if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	CSPRNG.BufferPosition += 4

	if bit32.band(Range, Range - 1) == 0 then
		return Min + bit32.band(Value, Range - 1)
	else
		while Value > Limit do
			if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
				GenerateBlock()
			end
			Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
			CSPRNG.BufferPosition += 4
		end

		return Min + (Value % Range)
	end
end

local function GetNumberRange(Min: number, Max: number): number
	if Min > Max then
		Min, Max = Max, Min
	end

	local Range = Max - Min
	if Range <= 0 then
		return Min
	end

	return Min + (GetFloat() * Range)
end

local function GetRandomString(Length: number, AsBuffer: boolean?): string | buffer
	local Characters = buffer.create(Length)

	for Index = 0, Length - 1 do
		buffer.writeu8(Characters, Index, GetIntRange(36, 122))
	end

	return if AsBuffer
		then Characters
		else buffer.tostring(Characters)
end

local function GetEd25519RandomBytes(): buffer
	local Output = buffer.create(32)

	for Index = 0, 31 do
		buffer.writeu8(Output, Index, GetIntRange(0, 255))
	end

	return Output
end

local function GetEd25519ClampedBytes(Input: buffer): buffer
	local Output = buffer.create(32)
	buffer.copy(Output, 0, Input, 0, 32)

	local FirstByte = buffer.readu8(Output, 0)
	FirstByte = bit32.band(FirstByte, 0xF8)
	buffer.writeu8(Output, 0, FirstByte)

	local LastByte = buffer.readu8(Output, 31)
	LastByte = bit32.band(LastByte, 0x7F)
	LastByte = bit32.bor(LastByte, 0x40)
	buffer.writeu8(Output, 31, LastByte)

	local HasVariation = false
	local FirstMiddleByte = buffer.readu8(Output, 1)
	for Index = 2, 30 do
		if buffer.readu8(Output, Index) ~= FirstMiddleByte then
			HasVariation = true
			break
		end
	end

	if not HasVariation then
		buffer.writeu8(Output, 15, bit32.bxor(FirstMiddleByte, 0x55))
	end

	return Output
end

local function GetHexString(Length: number): string
	local BytesNeeded = Length / 2
	local Bytes = GetBytes(BytesNeeded)
	local Hex = Conversions.ToHex(Bytes)

	return Hex
end

function CSPRNG.AddEntropyProvider(ProviderFunction: EntropyProvider)
	table.insert(CSPRNG.EntropyProviders, ProviderFunction)
end

function CSPRNG.RemoveEntropyProvider(ProviderFunction: EntropyProvider)
	for Index = #CSPRNG.EntropyProviders, 1, -1 do
		if CSPRNG.EntropyProviders[Index] == ProviderFunction then
			table.remove(CSPRNG.EntropyProviders, Index)
			break
		end
	end
end

function CSPRNG.Random(): number
	return GetFloat()
end

function CSPRNG.RandomInt(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) can't be less than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 1
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetIntRange(ActualMin, ActualMax)
end

function CSPRNG.RandomNumber(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) must be bigger than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 0
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetNumberRange(ActualMin, ActualMax)
end

function CSPRNG.RandomBytes(Count: number): buffer
	if type(Count) ~= "number" then
		error(`Count must be a number, got {typeof(Count)}`, 2)
	end

	if Count <= 0 then
		error(`Count must be bigger than 0, got {Count}`, 2)
	end

	if Count % 1 ~= 0 then
		error("Count must be an integer", 2)
	end

	return GetBytes(Count)
end

function CSPRNG.RandomString(Length: number, AsBuffer: boolean?): string | buffer
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if AsBuffer ~= nil and type(AsBuffer) ~= "boolean" then
		error(`AsBuffer must be a boolean or nil, got {typeof(AsBuffer)}`, 2)
	end

	return GetRandomString(Length, AsBuffer)
end

function CSPRNG.RandomHex(Length: number): string
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`, 2)
	end

	return GetHexString(Length)
end

function CSPRNG.Ed25519ClampedBytes(Input: buffer): buffer
	if type(Input) ~= "buffer" then
		error(`Input must be a buffer, got {typeof(Input)}`, 2)
	end

	return GetEd25519ClampedBytes(Input)
end

function CSPRNG.Ed25519Random(): buffer
	return GetEd25519ClampedBytes(GetEd25519RandomBytes())
end

function CSPRNG.Reseed(CustomEntropy: buffer?)
	if CustomEntropy ~= nil and type(CustomEntropy) ~= "buffer" then
		error(`CustomEntropy must be a buffer or nil, got {typeof(CustomEntropy)}`, 2)
	end

	Reset()
	GatherEntropy(CustomEntropy)
end

CSPRNG.BytesLeft = GatherEntropy()
GenerateBlock()

return CSPRNG]]></ProtectedString>
								<string name="ScriptGuid">{E9BCA801-3C1B-4560-B00D-C715152AFFE0}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CSPRNG</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX4F5D68DB30A84233AF51AA96B4A61110">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Blake3
	
	Sizes:
		Key: 32 bytes
		Output: variable
	
	Return type: string (hex)
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		
		--------Standard Hash--------
		local Hash = Blake3.Digest(Message, 32)
		
		--------Keyed Hash--------
		local KeyedHash = Blake3.DigestKeyed(Key, Message, 32)
		
		--------Key Derivation--------
		local Context = buffer.fromstring("my context")
		local KeyDeriver = Blake3.DeriveKey(Context)
		local DerivedKey = KeyDeriver(Message, 32)
--]=]

--!strict
--!optimize 2
--!native

local BLOCK_SIZE = 64
local CV_SIZE = 32
local EXTENDED_CV_SIZE = 64
local MAX_STACK_DEPTH = 64
local STACK_BUFFER_SIZE = MAX_STACK_DEPTH * CV_SIZE

local CHUNK_START = 0x01
local CHUNK_END = 0x02
local PARENT_FLAG = 0x04
local ROOT_FLAG = 0x08

local INITIAL_VECTORS = buffer.create(CV_SIZE) do
	local IV = {
		0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
		0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
	}
	for Index, Value in ipairs(IV) do
		buffer.writeu32(INITIAL_VECTORS, (Index - 1) * 4, Value)
	end
end

local function Compress(Hash: buffer, MessageBlock: buffer, Counter: number, V14: number, V15: number, IsFull: boolean?): buffer
	local Hash00 = buffer.readu32(Hash, 0)
	local Hash01 = buffer.readu32(Hash, 4)
	local Hash02 = buffer.readu32(Hash, 8)
	local Hash03 = buffer.readu32(Hash, 12)
	local Hash04 = buffer.readu32(Hash, 16)
	local Hash05 = buffer.readu32(Hash, 20)
	local Hash06 = buffer.readu32(Hash, 24)
	local Hash07 = buffer.readu32(Hash, 28)

	local V00, V01, V02, V03 = Hash00, Hash01, Hash02, Hash03
	local V04, V05, V06, V07 = Hash04, Hash05, Hash06, Hash07
	local V08, V09, V10, V11 = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a

	local V12 = Counter % (2 ^ 32)
	local V13 = (Counter - V12) * (2 ^ -32)

	local M00 = buffer.readu32(MessageBlock, 0)
	local M01 = buffer.readu32(MessageBlock, 4)
	local M02 = buffer.readu32(MessageBlock, 8)
	local M03 = buffer.readu32(MessageBlock, 12)
	local M04 = buffer.readu32(MessageBlock, 16)
	local M05 = buffer.readu32(MessageBlock, 20)
	local M06 = buffer.readu32(MessageBlock, 24)
	local M07 = buffer.readu32(MessageBlock, 28)
	local M08 = buffer.readu32(MessageBlock, 32)
	local M09 = buffer.readu32(MessageBlock, 36)
	local M10 = buffer.readu32(MessageBlock, 40)
	local M11 = buffer.readu32(MessageBlock, 44)
	local M12 = buffer.readu32(MessageBlock, 48)
	local M13 = buffer.readu32(MessageBlock, 52)
	local M14 = buffer.readu32(MessageBlock, 56)
	local M15 = buffer.readu32(MessageBlock, 60)

	local Temp
	for Index = 1, 7 do
		V00 += V04 + M00; V12 = bit32.lrotate(bit32.bxor(V12, V00), 16)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 20)
		V00 += V04 + M01; V12 = bit32.lrotate(bit32.bxor(V12, V00), 24)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 25)

		V01 += V05 + M02; V13 = bit32.lrotate(bit32.bxor(V13, V01), 16)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 20)
		V01 += V05 + M03; V13 = bit32.lrotate(bit32.bxor(V13, V01), 24)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 25)

		V02 += V06 + M04; V14 = bit32.lrotate(bit32.bxor(V14, V02), 16)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 20)
		V02 += V06 + M05; V14 = bit32.lrotate(bit32.bxor(V14, V02), 24)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 25)

		V03 += V07 + M06; V15 = bit32.lrotate(bit32.bxor(V15, V03), 16)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 20)
		V03 += V07 + M07; V15 = bit32.lrotate(bit32.bxor(V15, V03), 24)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 25)

		V00 += V05 + M08; V15 = bit32.lrotate(bit32.bxor(V15, V00), 16)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 20)
		V00 += V05 + M09; V15 = bit32.lrotate(bit32.bxor(V15, V00), 24)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 25)

		V01 += V06 + M10; V12 = bit32.lrotate(bit32.bxor(V12, V01), 16)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 20)
		V01 += V06 + M11; V12 = bit32.lrotate(bit32.bxor(V12, V01), 24)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 25)

		V02 += V07 + M12; V13 = bit32.lrotate(bit32.bxor(V13, V02), 16)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 20)
		V02 += V07 + M13; V13 = bit32.lrotate(bit32.bxor(V13, V02), 24)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 25)

		V03 += V04 + M14; V14 = bit32.lrotate(bit32.bxor(V14, V03), 16)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 20)
		V03 += V04 + M15; V14 = bit32.lrotate(bit32.bxor(V14, V03), 24)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 25)

		if Index ~= 7 then
			Temp = M02
			M02 = M03
			M03 = M10
			M10 = M12
			M12 = M09
			M09 = M11
			M11 = M05
			M05 = M00
			M00 = Temp

			Temp = M06
			M06 = M04
			M04 = M07
			M07 = M13
			M13 = M14
			M14 = M15
			M15 = M08
			M08 = M01
			M01 = Temp
		end
	end

	if IsFull then
		local Result = buffer.create(EXTENDED_CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		buffer.writeu32(Result, 32, bit32.bxor(V08, Hash00))
		buffer.writeu32(Result, 36, bit32.bxor(V09, Hash01))
		buffer.writeu32(Result, 40, bit32.bxor(V10, Hash02))
		buffer.writeu32(Result, 44, bit32.bxor(V11, Hash03))
		buffer.writeu32(Result, 48, bit32.bxor(V12, Hash04))
		buffer.writeu32(Result, 52, bit32.bxor(V13, Hash05))
		buffer.writeu32(Result, 56, bit32.bxor(V14, Hash06))
		buffer.writeu32(Result, 60, bit32.bxor(V15, Hash07))

		return Result
	else
		local Result = buffer.create(CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		return Result
	end
end

local function ProcessMessage(InitialHashVector: buffer, Flags: number, Message: buffer, Length: number): buffer
	local MessageLength = buffer.len(Message)
	local StateCvs = buffer.create(STACK_BUFFER_SIZE)
	local StackSize = 0
	local StateCv = buffer.create(CV_SIZE)
	buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)

	local StateCounter = 0
	local StateChunkNumber = 0
	local StateEndFlag = 0
	local StateStartFlag = CHUNK_START

	local BlockBuffer = buffer.create(BLOCK_SIZE)

	for BlockOffset = 0, MessageLength - BLOCK_SIZE - 1, BLOCK_SIZE do
		buffer.copy(BlockBuffer, 0, Message, BlockOffset, BLOCK_SIZE)
		local StateFlags = Flags + StateStartFlag + StateEndFlag

		StateCv = Compress(StateCv, BlockBuffer, StateCounter, BLOCK_SIZE, StateFlags)
		StateStartFlag = 0
		StateChunkNumber += 1

		if StateChunkNumber == 15 then
			StateEndFlag = CHUNK_END
		elseif StateChunkNumber == 16 then
			local MergeCv = StateCv
			local MergeAmount = StateCounter + 1

			while MergeAmount % 2 == 0 do
				StackSize = StackSize - 1
				local PopCv = buffer.create(CV_SIZE)
				buffer.copy(PopCv, 0, StateCvs, StackSize * CV_SIZE, CV_SIZE)

				local Block = buffer.create(EXTENDED_CV_SIZE)
				buffer.copy(Block, 0, PopCv, 0, CV_SIZE)
				buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

				MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
				MergeAmount = MergeAmount / 2
			end

			buffer.copy(StateCvs, StackSize * CV_SIZE, MergeCv, 0, CV_SIZE)
			StackSize = StackSize + 1
			buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)
			StateStartFlag = CHUNK_START

			StateCounter += 1
			StateChunkNumber = 0
			StateEndFlag = 0
		end
	end

	local LastLength = MessageLength == 0 and 0 or ((MessageLength - 1) % BLOCK_SIZE + 1)
	local PaddedMessage = buffer.create(BLOCK_SIZE)

	if LastLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, MessageLength - LastLength, LastLength)
	end

	local OutputCv: buffer
	local OutputBlock: buffer
	local OutputLength: number
	local OutputFlags: number

	if StateCounter > 0 then
		local StateFlags = Flags + StateStartFlag + CHUNK_END
		local MergeCv = Compress(StateCv, PaddedMessage, StateCounter, LastLength, StateFlags)

		for Index = StackSize, 2, -1 do
			local StackCv = buffer.create(CV_SIZE)
			buffer.copy(StackCv, 0, StateCvs, (Index - 1) * CV_SIZE, CV_SIZE)

			local Block = buffer.create(EXTENDED_CV_SIZE)
			buffer.copy(Block, 0, StackCv, 0, CV_SIZE)
			buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

			MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
		end

		OutputCv = InitialHashVector
		local FirstStackCv = buffer.create(CV_SIZE)
		buffer.copy(FirstStackCv, 0, StateCvs, 0, CV_SIZE)

		OutputBlock = buffer.create(EXTENDED_CV_SIZE)
		buffer.copy(OutputBlock, 0, FirstStackCv, 0, CV_SIZE)
		buffer.copy(OutputBlock, CV_SIZE, MergeCv, 0, CV_SIZE)

		OutputLength = BLOCK_SIZE
		OutputFlags = Flags + ROOT_FLAG + PARENT_FLAG
	else
		OutputCv = StateCv
		OutputBlock = PaddedMessage
		OutputLength = LastLength
		OutputFlags = Flags + StateStartFlag + CHUNK_END + ROOT_FLAG
	end

	local Output = buffer.create(Length)
	local OutputOffset = 0

	for Index = 0, Length // BLOCK_SIZE do
		local MessageDigest = Compress(OutputCv, OutputBlock, Index, OutputLength, OutputFlags, true)

		local BytesToCopy = math.min(BLOCK_SIZE, Length - OutputOffset)
		buffer.copy(Output, OutputOffset, MessageDigest, 0, BytesToCopy)
		OutputOffset += BytesToCopy

		if OutputOffset >= Length then
			break
		end
	end

	return Output
end

return function(Message: buffer, Length: number?): buffer
	return ProcessMessage(INITIAL_VECTORS, 0, Message, Length or 32)
end]]></ProtectedString>
									<string name="ScriptGuid">{3216024B-18C5-4BD0-B1ED-2D81B26E2A8E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Blake3</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD64801ADC06C4C88AFBDD0DC19C6B605">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: ChaCha20
	
	Sizes:
		Nonce: 12 bytes
		Key: 16/32 bytes
	
	Return type: buffer
	Example usage:
		local Data = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		local Nonce = buffer.fromstring(string.rep("n", 12))
		
		--------Usage Case 1--------
		local Encrypted = ChaCha20(Data, Key, Nonce)
		
		--------Usage Case 2--------
		local Decrypted = ChaCha20(Encrypted, Key, Nonce)
--]=]

--!strict
--!native
--!optimize 2

local DWORD = 4
local BLOCK_SIZE = 64
local STATE_SIZE = 16

local CHACHA20_NONCE_SIZE = 12
local CHACHA20_KEY_SIZE_16 = 16
local CHACHA20_KEY_SIZE_32 = 32

local SIGMA_CONSTANTS = buffer.create(16) do
	local SigmaBytes = { string.byte("expand 32-byte k", 1, -1) }
	for Index, ByteValue in SigmaBytes do
		buffer.writeu8(SIGMA_CONSTANTS, Index - 1, ByteValue)
	end
end

local TAU_CONSTANTS = buffer.create(16) do
	local TauBytes = { string.byte("expand 16-byte k", 1, -1) }
	for Index, ByteValue in TauBytes do
		buffer.writeu8(TAU_CONSTANTS, Index - 1, ByteValue)
	end
end

local function ProcessBlock(InitialState: buffer, Rounds: number)
	local S0: number, S1: number, S2: number, S3: number, S4: number, S5: number, S6: number, S7: number, S8: number, S9: number, S10: number, S11: number, S12: number, S13: number, S14: number, S15: number =
		buffer.readu32(InitialState, 0), buffer.readu32(InitialState, 4),
		buffer.readu32(InitialState, 8), buffer.readu32(InitialState, 12),
		buffer.readu32(InitialState, 16), buffer.readu32(InitialState, 20),
		buffer.readu32(InitialState, 24), buffer.readu32(InitialState, 28),
		buffer.readu32(InitialState, 32), buffer.readu32(InitialState, 36),
		buffer.readu32(InitialState, 40), buffer.readu32(InitialState, 44),
		buffer.readu32(InitialState, 48), buffer.readu32(InitialState, 52),
		buffer.readu32(InitialState, 56), buffer.readu32(InitialState, 60)

	for Round = 1, Rounds do
		local IsOddRound = Round % 2 == 1

		if IsOddRound then
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 16)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 12)
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 8)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 7)

			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 16)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 12)
			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 8)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 7)

			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 16)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 12)
			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 8)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 7)

			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 16)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 12)
			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 8)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 7)
		else
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 16)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 12)
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 8)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 7)

			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 16)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 12)
			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 8)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 7)

			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 16)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 12)
			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 8)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 7)

			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 16)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 12)
			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 8)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 7)
		end
	end

	buffer.writeu32(InitialState, 0, buffer.readu32(InitialState, 0) + S0)
	buffer.writeu32(InitialState, 4, buffer.readu32(InitialState, 4) + S1)
	buffer.writeu32(InitialState, 8, buffer.readu32(InitialState, 8) + S2)
	buffer.writeu32(InitialState, 12, buffer.readu32(InitialState, 12) + S3)
	buffer.writeu32(InitialState, 16, buffer.readu32(InitialState, 16) + S4)
	buffer.writeu32(InitialState, 20, buffer.readu32(InitialState, 20) + S5)
	buffer.writeu32(InitialState, 24, buffer.readu32(InitialState, 24) + S6)
	buffer.writeu32(InitialState, 28, buffer.readu32(InitialState, 28) + S7)
	buffer.writeu32(InitialState, 32, buffer.readu32(InitialState, 32) + S8)
	buffer.writeu32(InitialState, 36, buffer.readu32(InitialState, 36) + S9)
	buffer.writeu32(InitialState, 40, buffer.readu32(InitialState, 40) + S10)
	buffer.writeu32(InitialState, 44, buffer.readu32(InitialState, 44) + S11)
	buffer.writeu32(InitialState, 48, buffer.readu32(InitialState, 48) + S12)
	buffer.writeu32(InitialState, 52, buffer.readu32(InitialState, 52) + S13)
	buffer.writeu32(InitialState, 56, buffer.readu32(InitialState, 56) + S14)
	buffer.writeu32(InitialState, 60, buffer.readu32(InitialState, 60) + S15)
end

local function InitializeState(Key: buffer, Nonce: buffer, Counter: number): buffer
	local KeyLength = buffer.len(Key)
	local State = buffer.create(STATE_SIZE * DWORD)

	local Constants = KeyLength == 32 and SIGMA_CONSTANTS or TAU_CONSTANTS

	buffer.copy(State, 0, Constants, 0, 16)

	buffer.copy(State, 16, Key, 0, math.min(KeyLength, 16))
	if KeyLength == 32 then
		buffer.copy(State, 32, Key, 16, 16)
	else
		buffer.copy(State, 32, Key, 0, 16)
	end

	buffer.writeu32(State, 48, Counter)
	buffer.copy(State, 52, Nonce, 0, 12)

	return State
end

local function ChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?): buffer
	if Data == nil then
		error("Data cannot be nil", 2)
	end

	if typeof(Data) ~= "buffer" then
		error(`Data must be a buffer, got {typeof(Data)}`, 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE_16 and KeyLength ~= CHACHA20_KEY_SIZE_32 then
		error(`Key must be {CHACHA20_KEY_SIZE_16} or {CHACHA20_KEY_SIZE_32} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	if NonceLength ~= CHACHA20_NONCE_SIZE then
		error(`Nonce must be exactly {CHACHA20_NONCE_SIZE} bytes long, got {NonceLength} bytes`, 2)
	end

	if Counter then
		if typeof(Counter) ~= "number" then
			error(`Counter must be a number, got {typeof(Counter)}`, 2)
		end

		if Counter < 0 then
			error(`Counter cannot be negative, got {Counter}`, 2)
		end

		if Counter ~= math.floor(Counter) then
			error(`Counter must be an integer, got {Counter}`, 2)
		end

		if Counter >= 2^32 then
			error(`Counter must be less than 2^32, got {Counter}`, 2)
		end
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds ~= math.floor(Rounds) then
			error(`Rounds must be an integer, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockCounter = Counter or 1
	local BlockRounds = Rounds or 20

	local DataLength = buffer.len(Data)
	if DataLength == 0 then
		return buffer.create(0)
	end

	local Output = buffer.create(DataLength)

	local DataOffset = 0

	local State = InitializeState(Key, Nonce, BlockCounter)
	local StateBackup = buffer.create(64)
	buffer.copy(StateBackup, 0, State, 0)

	while DataOffset < DataLength do
		ProcessBlock(State, BlockRounds)

		local BytesToProcess = math.min(BLOCK_SIZE, DataLength - DataOffset)

		for Index = 0, BytesToProcess - 1 do
			local DataByte = buffer.readu8(Data, DataOffset + Index)
			local KeystreamByte = buffer.readu8(State, Index)
			buffer.writeu8(Output, DataOffset + Index, bit32.bxor(DataByte, KeystreamByte))
		end

		DataOffset += BytesToProcess
		BlockCounter += 1
		buffer.copy(State, 0, StateBackup, 0)
		buffer.writeu32(State, 48, BlockCounter)
	end

	return Output
end

return ChaCha20]]></ProtectedString>
									<string name="ScriptGuid">{7FDE48A3-5367-454F-B017-E90CC781A1F5}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ChaCha20</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE88F6BCC40DD4AFCBAA282F656E00101">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Conversions
	
	Return type: string / buffer
	Example Usage:
		local HexString = Conversions.ToHex(buffer.fromstring("Hello World"))
		local OriginalBuffer = Conversions.FromHex("48656c6c6f20576f726c64")
--]=]

--!strict
--!optimize 2
--!native

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local DECODE_LOOKUP = buffer.create(65536 * 2) do
	for High = 0, 255 do
		for Low = 0, 255 do
			local HighNibble = 0
			local LowNibble = 0

			if High >= 48 and High <= 57 then
				HighNibble = High - 48
			elseif High >= 65 and High <= 70 then
				HighNibble = High - 55
			elseif High >= 97 and High <= 102 then
				HighNibble = High - 87
			else
				HighNibble = 0
			end

			if Low >= 48 and Low <= 57 then
				LowNibble = Low - 48
			elseif Low >= 65 and Low <= 70 then
				LowNibble = Low - 55
			elseif Low >= 97 and Low <= 102 then
				LowNibble = Low - 87
			else
				LowNibble = 0
			end

			local Combined = bit32.lshift(HighNibble, 4) + LowNibble
			local Index = bit32.lshift(Low, 8) + High
			buffer.writeu16(DECODE_LOOKUP, Index * 2, Combined)
		end
	end
end

local Conversions = {}

function Conversions.ToHex(Buffer: buffer): string
	local Length = buffer.len(Buffer)
	local Hex = buffer.create(Length * 2)

	local Lookup = ENCODE_LOOKUP

	local Leftover = Length % 8
	local HexCursor = 0

	for Index = 0, Length - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = Length - Leftover, Length - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex)
end

function Conversions.FromHex(Hex: string | buffer): buffer
	local BufferHex = if type(Hex) == "string" then buffer.fromstring(Hex) else Hex
	local Length = buffer.len(BufferHex)
	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`)
	end

	local Buffer = buffer.create(bit32.rshift(Length, 1))
	local Leftover = Length % 16
	local BufferCursor = 0
	local Lookup = DECODE_LOOKUP

	for Index = 0, Length - Leftover - 1, 16 do
		local Pair1 = buffer.readu16(BufferHex, Index)
		local Pair2 = buffer.readu16(BufferHex, Index + 2)
		local Pair3 = buffer.readu16(BufferHex, Index + 4)
		local Pair4 = buffer.readu16(BufferHex, Index + 6)
		local Pair5 = buffer.readu16(BufferHex, Index + 8)
		local Pair6 = buffer.readu16(BufferHex, Index + 10)
		local Pair7 = buffer.readu16(BufferHex, Index + 12)
		local Pair8 = buffer.readu16(BufferHex, Index + 14)

		local Byte1 = buffer.readu16(Lookup, Pair1 * 2)
		local Byte2 = buffer.readu16(Lookup, Pair2 * 2)
		local Byte3 = buffer.readu16(Lookup, Pair3 * 2)
		local Byte4 = buffer.readu16(Lookup, Pair4 * 2)
		local Byte5 = buffer.readu16(Lookup, Pair5 * 2)
		local Byte6 = buffer.readu16(Lookup, Pair6 * 2)
		local Byte7 = buffer.readu16(Lookup, Pair7 * 2)
		local Byte8 = buffer.readu16(Lookup, Pair8 * 2)

		local Chunk1 = bit32.lshift(Byte4, 24) + bit32.lshift(Byte3, 16) + 
			bit32.lshift(Byte2, 8) + Byte1
		local Chunk2 = bit32.lshift(Byte8, 24) + bit32.lshift(Byte7, 16) + 
			bit32.lshift(Byte6, 8) + Byte5

		buffer.writeu32(Buffer, BufferCursor, Chunk1)
		buffer.writeu32(Buffer, BufferCursor + 4, Chunk2)
		BufferCursor += 8
	end

	for Index = Length - Leftover, Length - 1, 2 do
		local Pair = buffer.readu16(BufferHex, Index)
		local Byte = buffer.readu16(Lookup, Pair * 2)
		buffer.writeu8(Buffer, BufferCursor, Byte)
		BufferCursor += 1
	end

	return Buffer
end

return Conversions]]></ProtectedString>
									<string name="ScriptGuid">{F914FA8F-75FE-47C6-A0D9-E0B7A40CC7A2}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Conversions</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXE9A5ACF851794D738740ED7DCBD95AE0">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Curve25519 Montgomery

	Return type: varies by function
	Example usage:
		local Curve25519 = require("Curve25519")
		local FieldQuadratic = require("FieldQuadratic")

		--------Usage Case 1: Point multiplication--------
		local BasePoint = Curve25519.G
		local SomeScalar = FieldQuadratic.Decode(ScalarBytes)
		local ScalarBits, BitCount = FieldQuadratic.Bits(SomeScalar)
		local Result = Curve25519.Ladder8(BasePoint, ScalarBits, BitCount)

		--------Usage Case 2: Encode/decode points--------
		local EncodedPoint = Curve25519.Encode(Curve25519.Scale(Result))
		local DecodedPoint = Curve25519.Decode(EncodedPoint)
--]=]

--!strict
--!optimize 2
--!native

local FieldPrime = require("./FieldPrime")
local CSPRNG = require("./CSPRNG")

local MONTGOMERY_POINT_SIZE = 208
local COORD_SIZE = 104

local function GetMontgomeryCoord(Point: buffer, Index: number): buffer
	local Coord = buffer.create(COORD_SIZE)
	buffer.copy(Coord, 0, Point, Index * COORD_SIZE, COORD_SIZE)

	return Coord
end

local function Double(PointToDouble: buffer): buffer
	local CoordX = GetMontgomeryCoord(PointToDouble, 0)
	local CoordZ = GetMontgomeryCoord(PointToDouble, 1)

	local SumXZ = FieldPrime.Add(CoordX, CoordZ)
	local SumSquared = FieldPrime.Square(SumXZ)
	local DiffXZ = FieldPrime.Sub(CoordX, CoordZ)
	local DiffSquared = FieldPrime.Square(DiffXZ)
	local Difference = FieldPrime.Sub(SumSquared, DiffSquared)
	local NewX = FieldPrime.Mul(SumSquared, DiffSquared)
	local NewZ = FieldPrime.Mul(Difference, FieldPrime.Add(DiffSquared, FieldPrime.KMul(Difference, 121666)))

	local Point = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(Point, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Point, 1 * COORD_SIZE, NewZ, 0, COORD_SIZE)

	return Point
end

local function LadderStep(DifferencePoint: buffer, Point1: buffer, Point2: buffer): (buffer, buffer)
	local DiffX = GetMontgomeryCoord(DifferencePoint, 0)
	local DiffZ = GetMontgomeryCoord(DifferencePoint, 1)
	local X1 = GetMontgomeryCoord(Point1, 0)
	local Z1 = GetMontgomeryCoord(Point1, 1)
	local X2 = GetMontgomeryCoord(Point2, 0)
	local Z2 = GetMontgomeryCoord(Point2, 1)

	local SumA = FieldPrime.Add(X1, Z1)
	local SumSquaredAA = FieldPrime.Square(SumA)
	local DiffB = FieldPrime.Sub(X1, Z1)
	local DiffSquaredBB = FieldPrime.Square(DiffB)

	local DifferenceE = FieldPrime.Sub(SumSquaredAA, DiffSquaredBB)
	local DiffD = FieldPrime.Sub(X2, Z2)
	local CrossDA = FieldPrime.Mul(DiffD, SumA)
	local SumC = FieldPrime.Add(X2, Z2)
	local CrossCB = FieldPrime.Mul(SumC, DiffB)

	local NewX4 = FieldPrime.Mul(DiffZ, FieldPrime.Square(FieldPrime.Add(CrossDA, CrossCB)))
	local NewZ4 = FieldPrime.Mul(DiffX, FieldPrime.Square(FieldPrime.Sub(CrossDA, CrossCB)))
	local NewX3 = FieldPrime.Mul(SumSquaredAA, DiffSquaredBB)
	local NewZ3 = FieldPrime.Mul(DifferenceE, FieldPrime.Add(DiffSquaredBB, FieldPrime.KMul(DifferenceE, 121666)))

	local Point = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(Point, 0 * COORD_SIZE, NewX3, 0, COORD_SIZE)
	buffer.copy(Point, 1 * COORD_SIZE, NewZ3, 0, COORD_SIZE)

	local SecondPoint = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(SecondPoint, 0 * COORD_SIZE, NewX4, 0, COORD_SIZE)
	buffer.copy(SecondPoint, 1 * COORD_SIZE, NewZ4, 0, COORD_SIZE)

	return Point, SecondPoint
end

local function Ladder(DifferencePoint: buffer, ScalarBits: buffer, ScalarBitCount: number): buffer
	local CurrentP = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(CurrentP, 0 * COORD_SIZE, FieldPrime.Num(1), 0, COORD_SIZE)
	buffer.copy(CurrentP, 1 * COORD_SIZE, FieldPrime.Num(0), 0, COORD_SIZE)

	local CurrentQ = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(CurrentQ, 0, DifferencePoint, 0, MONTGOMERY_POINT_SIZE)

	local LadderStep = LadderStep

	for BitIndex = ScalarBitCount, 1, -1 do
		local BitValue = buffer.readf64(ScalarBits, (BitIndex - 1) * 8)
		if BitValue == 0 then
			CurrentP, CurrentQ = LadderStep(DifferencePoint, CurrentP, CurrentQ)
		else
			CurrentQ, CurrentP = LadderStep(DifferencePoint, CurrentQ, CurrentP)
		end
	end

	return CurrentP
end

local Curve25519 = {}

function Curve25519.DifferentialAdd(DifferencePoint: buffer, Point1: buffer, Point2: buffer): buffer
	local DiffX = GetMontgomeryCoord(DifferencePoint, 0)
	local DiffZ = GetMontgomeryCoord(DifferencePoint, 1)
	local X1 = GetMontgomeryCoord(Point1, 0)
	local Z1 = GetMontgomeryCoord(Point1, 1)
	local X2 = GetMontgomeryCoord(Point2, 0)
	local Z2 = GetMontgomeryCoord(Point2, 1)

	local SumA = FieldPrime.Add(X1, Z1)
	local DiffB = FieldPrime.Sub(X1, Z1)
	local SumC = FieldPrime.Add(X2, Z2)
	local DiffD = FieldPrime.Sub(X2, Z2)
	local CrossDA = FieldPrime.Mul(DiffD, SumA)
	local CrossCB = FieldPrime.Mul(SumC, DiffB)

	local NewX = FieldPrime.Mul(DiffZ, FieldPrime.Square(FieldPrime.Add(CrossDA, CrossCB)))
	local NewZ = FieldPrime.Mul(DiffX, FieldPrime.Square(FieldPrime.Sub(CrossDA, CrossCB)))

	local Point = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(Point, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Point, 1 * COORD_SIZE, NewZ, 0, COORD_SIZE)

	return Point
end

function Curve25519.Decode(EncodedBuffer: buffer): buffer
	local Point = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(Point, 0 * COORD_SIZE, FieldPrime.Decode(EncodedBuffer), 0, COORD_SIZE)
	buffer.copy(Point, 1 * COORD_SIZE, FieldPrime.Num(1), 0, COORD_SIZE)

	return Point
end

function Curve25519.Prac(BasePoint: buffer, PracRuleset: {any}): (buffer?, buffer?, buffer?)
	local DifferentialAdd = Curve25519.DifferentialAdd
	local RandomBuffer = CSPRNG.Ed25519Random()
	local RandomFactor = FieldPrime.Decode(RandomBuffer)

	local BaseX = GetMontgomeryCoord(BasePoint, 0)
	local BaseZ = GetMontgomeryCoord(BasePoint, 1)
	local RandomizedA = buffer.create(MONTGOMERY_POINT_SIZE)
	buffer.copy(RandomizedA, 0 * COORD_SIZE, FieldPrime.Mul(BaseX, RandomFactor), 0, COORD_SIZE)
	buffer.copy(RandomizedA, 1 * COORD_SIZE, FieldPrime.Mul(BaseZ, RandomFactor), 0, COORD_SIZE)

	RandomizedA = Double(Double(Double(RandomizedA)))

	local AZ = GetMontgomeryCoord(RandomizedA, 1)
	if FieldPrime.Eqz(AZ) then
		return nil, nil, nil
	end

	RandomizedA = Ladder(RandomizedA, PracRuleset[1], PracRuleset[2])

	local Rules: buffer = PracRuleset[3]
	local RuleCount: number = PracRuleset[4]
	if RuleCount == 0 then
		return RandomizedA, nil, nil
	end

	local CurrentB, CurrentC
	local FirstRule = buffer.readf64(Rules, (RuleCount - 1) * 8)
	if FirstRule == 2 then
		local DoubledA = Double(RandomizedA)
		RandomizedA, CurrentB, CurrentC = DifferentialAdd(RandomizedA, DoubledA, RandomizedA), RandomizedA, DoubledA
	elseif FirstRule == 3 or FirstRule == 5 then
		RandomizedA, CurrentB, CurrentC = Double(RandomizedA), RandomizedA, RandomizedA
	elseif FirstRule == 6 then
		local DoubledA = Double(RandomizedA)
		local TripledA = DifferentialAdd(RandomizedA, DoubledA, RandomizedA)
		RandomizedA, CurrentB, CurrentC = Double(TripledA), RandomizedA, DifferentialAdd(RandomizedA, TripledA, DoubledA)
	elseif FirstRule == 7 then
		local DoubledA = Double(RandomizedA)
		local TripledA = DifferentialAdd(RandomizedA, DoubledA, RandomizedA)
		local QuadrupleA = Double(DoubledA)
		RandomizedA, CurrentB, CurrentC = DifferentialAdd(TripledA, QuadrupleA, RandomizedA), RandomizedA, QuadrupleA
	elseif FirstRule == 8 then
		local DoubledA = Double(RandomizedA)
		local TripledA = DifferentialAdd(RandomizedA, DoubledA, RandomizedA)
		RandomizedA, CurrentB, CurrentC = Double(DoubledA), RandomizedA, TripledA
	else
		RandomizedA, CurrentB, CurrentC = RandomizedA, Double(RandomizedA), RandomizedA
	end

	if not CurrentC then
		return nil, nil, nil
	end

	for RuleIndex = RuleCount - 1, 1, -1 do
		local CurrentRule = buffer.readf64(Rules, (RuleIndex - 1) * 8)
		if CurrentRule == 0 then
			RandomizedA, CurrentB = CurrentB, RandomizedA
		elseif CurrentRule == 1 then
			local SumAB = DifferentialAdd(CurrentC, RandomizedA, CurrentB)
			RandomizedA, CurrentB = DifferentialAdd(CurrentB, SumAB, RandomizedA), DifferentialAdd(RandomizedA, SumAB, CurrentB)
		elseif CurrentRule == 2 then
			RandomizedA, CurrentC = DifferentialAdd(CurrentB, DifferentialAdd(CurrentC, RandomizedA, CurrentB), RandomizedA), Double(RandomizedA)
		elseif CurrentRule == 3 then
			RandomizedA, CurrentC = DifferentialAdd(CurrentC, RandomizedA, CurrentB), RandomizedA
		elseif CurrentRule == 5 then
			RandomizedA, CurrentC = Double(RandomizedA), DifferentialAdd(CurrentB, RandomizedA, CurrentC)
		elseif CurrentRule == 6 then
			local SumAB = DifferentialAdd(CurrentC, RandomizedA, CurrentB)
			local DoubledSumAABB = Double(SumAB)
			RandomizedA, CurrentC = DifferentialAdd(SumAB, DoubledSumAABB, SumAB), DifferentialAdd(DifferentialAdd(RandomizedA, SumAB, CurrentB), DoubledSumAABB, RandomizedA)
		elseif CurrentRule == 7 then
			local SumAB = DifferentialAdd(CurrentC, RandomizedA, CurrentB)
			local DoubleAAB = DifferentialAdd(CurrentB, SumAB, RandomizedA)
			RandomizedA, CurrentC = DifferentialAdd(RandomizedA, DoubleAAB, SumAB), DifferentialAdd(SumAB, DoubleAAB, RandomizedA)
		elseif CurrentRule == 8 then
			local DoubledA = Double(RandomizedA)
			RandomizedA, CurrentC = DifferentialAdd(CurrentC, DoubledA, DifferentialAdd(CurrentC, RandomizedA, CurrentB)), DifferentialAdd(RandomizedA, DoubledA, RandomizedA)
		else
			CurrentB, CurrentC = Double(CurrentB), DifferentialAdd(RandomizedA, CurrentC, CurrentB)
		end
	end

	return RandomizedA, CurrentB, CurrentC
end

local Point = buffer.create(MONTGOMERY_POINT_SIZE)
buffer.copy(Point, 0 * COORD_SIZE, FieldPrime.Num(9), 0, COORD_SIZE)
buffer.copy(Point, 1 * COORD_SIZE, FieldPrime.Num(1), 0, COORD_SIZE)
Curve25519.G = Point

return Curve25519]]></ProtectedString>
								<string name="ScriptGuid">{6371FA58-D639-4539-B317-0C9F23E57268}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Curve25519</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDC268C32CC1C44CC823ECF6B8258D12C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Edwards25519

	Return type: varies by function
	Example usage:
		local Edwards = require("Edwards25519")
		local FieldQuadratic = require("FieldQuadratic")

		--------Usage Case 1: Point addition--------
		local Point1 = Edwards.Decode(SomeEncodedBuffer)
		local Point2 = Edwards.Decode(AnotherEncodedBuffer)
		local NielsPoint2 = Edwards.Niels(Point2)
		local Sum = Edwards.Add(Point1, NielsPoint2)

		--------Usage Case 2: Scalar multiplication with buffer-based bits--------
		local SomeScalar = FieldQuadratic.Decode(ScalarBytes)
		local ScalarBits, BitCount = FieldQuadratic.Bits(SomeScalar)
		local Result = Edwards.MulG(ScalarBits, BitCount)
		local EncodedResult = Edwards.Encode(Result)
--]=]

--!strict
--!optimize 2
--!native

local FieldPrime = require("./FieldPrime")

local POINT_SIZE = 416
local COORD_SIZE = 104
local AFFINE_NIELS_SIZE = 312
local BASE_RADIX_WIDTH = 6
local BASE_POINT_ROW = 2 ^ BASE_RADIX_WIDTH / 2

local CURVE_D = FieldPrime.Mul(FieldPrime.Num(-121665), FieldPrime.Invert(FieldPrime.Num(121666)))
local CURVE_K = FieldPrime.KMul(CURVE_D, 2)

local IDENTITY_O = buffer.create(POINT_SIZE) do
	buffer.copy(IDENTITY_O, 0, FieldPrime.Num(0), 0, COORD_SIZE)
	buffer.copy(IDENTITY_O, COORD_SIZE, FieldPrime.Num(1), 0, COORD_SIZE)
	buffer.copy(IDENTITY_O, 2 * COORD_SIZE, FieldPrime.Num(1), 0, COORD_SIZE)
	buffer.copy(IDENTITY_O, 3 * COORD_SIZE, FieldPrime.Num(0), 0, COORD_SIZE)
end

local COORD_BUFFER_0 = buffer.create(COORD_SIZE)
local COORD_BUFFER_1 = buffer.create(COORD_SIZE)
local COORD_BUFFER_2 = buffer.create(COORD_SIZE)
local COORD_BUFFER_3 = buffer.create(COORD_SIZE)
local COORD_BUFFER_4 = buffer.create(COORD_SIZE)
local COORD_BUFFER_5 = buffer.create(COORD_SIZE)
local COORD_BUFFER_6 = buffer.create(COORD_SIZE)
local COORD_BUFFER_7 = buffer.create(COORD_SIZE)

local MUL_RESULT_POINT = buffer.create(POINT_SIZE)
local MUL_NIELS_POINT = buffer.create(POINT_SIZE)
local MUL_DOUBLE_X = buffer.create(COORD_SIZE)
local MUL_DOUBLE_Y = buffer.create(COORD_SIZE)
local MUL_DOUBLE_Z = buffer.create(COORD_SIZE)
local MUL_DOUBLE_A = buffer.create(COORD_SIZE)
local MUL_DOUBLE_B = buffer.create(COORD_SIZE)
local MUL_DOUBLE_E = buffer.create(COORD_SIZE)
local MUL_DOUBLE_G = buffer.create(COORD_SIZE)
local MUL_P1X = buffer.create(COORD_SIZE)
local MUL_P1Y = buffer.create(COORD_SIZE)
local MUL_P1Z = buffer.create(COORD_SIZE)
local MUL_P1T = buffer.create(COORD_SIZE)
local MUL_N2P = buffer.create(COORD_SIZE)
local MUL_N2M = buffer.create(COORD_SIZE)
local MUL_N2Z = buffer.create(COORD_SIZE)
local MUL_N2T = buffer.create(COORD_SIZE)
local MUL_TMP = buffer.create(COORD_SIZE)

local MULG_RESULT_POINT = buffer.create(POINT_SIZE)
local MULG_AFFINE_NIELS = buffer.create(AFFINE_NIELS_SIZE)
local MULG_DUMMY_POINT = buffer.create(POINT_SIZE)
local MULG_P1X = buffer.create(COORD_SIZE)
local MULG_P1Y = buffer.create(COORD_SIZE)
local MULG_P1Z = buffer.create(COORD_SIZE)
local MULG_P1T = buffer.create(COORD_SIZE)
local MULG_N2P = buffer.create(COORD_SIZE)
local MULG_N2M = buffer.create(COORD_SIZE)
local MULG_N2T = buffer.create(COORD_SIZE)
local MULG_TMP = buffer.create(COORD_SIZE)

local NAF_TABLE_DOUBLED = buffer.create(POINT_SIZE)
local NAF_TABLE_P1X = buffer.create(COORD_SIZE)
local NAF_TABLE_P1Y = buffer.create(COORD_SIZE)
local NAF_TABLE_P1Z = buffer.create(COORD_SIZE)
local NAF_TABLE_P1T = buffer.create(COORD_SIZE)
local NAF_TABLE_N2P = buffer.create(COORD_SIZE)
local NAF_TABLE_N2M = buffer.create(COORD_SIZE)
local NAF_TABLE_N2Z = buffer.create(COORD_SIZE)
local NAF_TABLE_N2T = buffer.create(COORD_SIZE)
local NAF_TABLE_TMP = buffer.create(COORD_SIZE)
local NAF_TABLE_DBL_P = buffer.create(COORD_SIZE)
local NAF_TABLE_DBL_M = buffer.create(COORD_SIZE)
local NAF_TABLE_DBL_Z = buffer.create(COORD_SIZE)
local NAF_TABLE_DBL_T = buffer.create(COORD_SIZE)

local NAF_OUTPUT = buffer.create(512 * 8)
local RADIX_OUTPUT = buffer.create(272 * 8)

local BASEPONT_G: buffer? = nil
local AFFINE_BASEPOINT_TABLE: buffer? = nil

local function GetCoord(Point: buffer, Index: number, Storage: buffer?): buffer
	local Coord = Storage or buffer.create(COORD_SIZE)
	buffer.copy(Coord, 0, Point, Index * COORD_SIZE, COORD_SIZE)
	return Coord
end

local Edwards25519 = {}

function Edwards25519.Double(Point1: buffer, Storage: buffer?): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1Z = GetCoord(Point1, 2, COORD_BUFFER_2)

	local SquaredA = FieldPrime.Square(Point1X)
	local SquaredB = FieldPrime.Square(Point1Y)
	FieldPrime.Square(Point1Z, Point1Z)
	FieldPrime.Add(Point1Z, Point1Z, Point1Z)
	local DoubledD = Point1Z
	local SumE = FieldPrime.Add(SquaredA, SquaredB)
	FieldPrime.Add(Point1X, Point1Y, Point1X)
	local SumF = Point1X
	local SquaredG = FieldPrime.Square(SumF)
	FieldPrime.Sub(SquaredG, SumE, SquaredG)
	FieldPrime.Carry(SquaredG, SquaredG)
	local DiffH = SquaredG
	FieldPrime.Sub(SquaredB, SquaredA, SquaredB)
	local DiffI = SquaredB
	FieldPrime.Sub(DoubledD, DiffI, DoubledD)
	FieldPrime.Carry(DoubledD, DoubledD)
	local DiffJ = DoubledD

	local NewX = FieldPrime.Mul(DiffH, DiffJ)
	local NewY = FieldPrime.Mul(DiffI, SumE)
	FieldPrime.Mul(DiffJ, DiffI, DiffJ)
	local NewZ = DiffJ
	FieldPrime.Mul(DiffH, SumE, DiffH)
	local NewT = DiffH

	local Result = Storage or buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, NewY, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, NewZ, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, NewT, 0, COORD_SIZE)

	return Result
end

function Edwards25519.Add(Point1: buffer, NielsPoint2: buffer, Storage: buffer?): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1Z = GetCoord(Point1, 2, COORD_BUFFER_2)
	local Point1T = GetCoord(Point1, 3, COORD_BUFFER_3)

	local Niels1Plus = GetCoord(NielsPoint2, 0, COORD_BUFFER_4)
	local Niels1Minus = GetCoord(NielsPoint2, 1, COORD_BUFFER_5)
	local Niels1Z = GetCoord(NielsPoint2, 2, COORD_BUFFER_6)
	local Niels1T = GetCoord(NielsPoint2, 3, COORD_BUFFER_7)

	local DiffA = FieldPrime.Sub(Point1Y, Point1X)
	FieldPrime.Mul(DiffA, Niels1Minus, DiffA)
	local ProductB = DiffA

	local SumC = FieldPrime.Add(Point1Y, Point1X)
	FieldPrime.Mul(SumC, Niels1Plus, SumC)
	local ProductD = SumC

	FieldPrime.Mul(Point1T, Niels1T, Point1T)
	local ProductE = Point1T

	FieldPrime.Mul(Point1Z, Niels1Z, Point1Z)
	local ProductF = Point1Z

	local DiffG = FieldPrime.Sub(ProductD, ProductB)
	local DiffH = FieldPrime.Sub(ProductF, ProductE)

	FieldPrime.Add(ProductF, ProductE, ProductF)
	local SumI = ProductF

	FieldPrime.Add(ProductD, ProductB, ProductD)
	local SumJ = ProductD

	local NewX = FieldPrime.Mul(DiffG, DiffH)
	local NewY = FieldPrime.Mul(SumI, SumJ)
	FieldPrime.Mul(DiffH, SumI, DiffH)
	local NewZ = DiffH
	FieldPrime.Mul(DiffG, SumJ, DiffG)
	local NewT = DiffG

	local Result = Storage or buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, NewY, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, NewZ, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, NewT, 0, COORD_SIZE)

	return Result
end

function Edwards25519.Sub(Point1: buffer, NielsPoint2: buffer, Storage: buffer?): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1Z = GetCoord(Point1, 2, COORD_BUFFER_2)
	local Point1T = GetCoord(Point1, 3, COORD_BUFFER_3)

	local Niels1Plus = GetCoord(NielsPoint2, 0, COORD_BUFFER_4)
	local Niels1Minus = GetCoord(NielsPoint2, 1, COORD_BUFFER_5)
	local Niels1Z = GetCoord(NielsPoint2, 2, COORD_BUFFER_6)
	local Niels1T = GetCoord(NielsPoint2, 3, COORD_BUFFER_7)

	local DiffA = FieldPrime.Sub(Point1Y, Point1X)
	FieldPrime.Mul(DiffA, Niels1Plus, DiffA)
	local ProductB = DiffA
	FieldPrime.Add(Point1Y, Point1X, Point1Y)
	local SumC = Point1Y
	FieldPrime.Mul(SumC, Niels1Minus, SumC)
	local ProductD = SumC
	FieldPrime.Mul(Point1T, Niels1T, Point1T)
	local ProductE = Point1T
	FieldPrime.Mul(Point1Z, Niels1Z, Point1Z)
	local ProductF = Point1Z
	local DiffG = FieldPrime.Sub(ProductD, ProductB)
	local SumH = FieldPrime.Add(ProductF, ProductE)
	local DiffI = FieldPrime.Sub(ProductF, ProductE)
	FieldPrime.Add(ProductD, ProductB, ProductD)
	local SumJ = ProductD

	local NewX = FieldPrime.Mul(DiffG, SumH)
	local NewY = FieldPrime.Mul(DiffI, SumJ)
	FieldPrime.Mul(SumH, DiffI, SumH)
	local NewZ = SumH
	FieldPrime.Mul(DiffG, SumJ, DiffG)
	local NewT = DiffG

	local Result = Storage or buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, NewY, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, NewZ, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, NewT, 0, COORD_SIZE)

	return Result
end

function Edwards25519.Niels(Point1: buffer, Storage: buffer?): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1Z = GetCoord(Point1, 2, COORD_BUFFER_2)
	local Point1T = GetCoord(Point1, 3, COORD_BUFFER_3)

	local PlusN3 = FieldPrime.Add(Point1Y, Point1X)
	local MinusN3 = FieldPrime.Sub(Point1Y, Point1X)
	FieldPrime.Add(Point1Z, Point1Z, Point1Z)
	local DoubledN3Z = Point1Z
	FieldPrime.Mul(Point1T, CURVE_K, Point1T)
	local ScaledN3T = Point1T

	local Result = Storage or buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, PlusN3, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, MinusN3, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, DoubledN3Z, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, ScaledN3T, 0, COORD_SIZE)

	return Result
end

function Edwards25519.AffineNiels(Point1: buffer, Storage: buffer?): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1T = GetCoord(Point1, 3, COORD_BUFFER_3)

	local YPlusX = FieldPrime.Add(Point1Y, Point1X)
	local YMinusX = FieldPrime.Sub(Point1Y, Point1X)
	FieldPrime.Mul(Point1T, CURVE_K, Point1T)
	local T2d = Point1T

	local Result = Storage or buffer.create(AFFINE_NIELS_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, YPlusX, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, YMinusX, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, T2d, 0, COORD_SIZE)

	return Result
end

function Edwards25519.AddAffine(Point1: buffer, AffineNiels2: buffer, Storage: buffer?): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1Z = GetCoord(Point1, 2, COORD_BUFFER_2)
	local Point1T = GetCoord(Point1, 3, COORD_BUFFER_3)

	local Niels2YPlusX = GetCoord(AffineNiels2, 0, COORD_BUFFER_4)
	local Niels2YMinusX = GetCoord(AffineNiels2, 1, COORD_BUFFER_5)
	local Niels2T2d = GetCoord(AffineNiels2, 2, COORD_BUFFER_6)

	local DiffA = FieldPrime.Sub(Point1Y, Point1X)
	FieldPrime.Mul(DiffA, Niels2YMinusX, DiffA)
	local ProductB = DiffA

	local SumC = FieldPrime.Add(Point1Y, Point1X)
	FieldPrime.Mul(SumC, Niels2YPlusX, SumC)
	local ProductD = SumC

	FieldPrime.Mul(Point1T, Niels2T2d, Point1T)
	local ProductE = Point1T

	FieldPrime.Add(Point1Z, Point1Z, Point1Z)
	local ProductF = Point1Z

	local DiffG = FieldPrime.Sub(ProductD, ProductB)
	local DiffH = FieldPrime.Sub(ProductF, ProductE)

	FieldPrime.Add(ProductF, ProductE, ProductF)
	local SumI = ProductF

	FieldPrime.Add(ProductD, ProductB, ProductD)
	local SumJ = ProductD

	local NewX = FieldPrime.Mul(DiffG, DiffH)
	local NewY = FieldPrime.Mul(SumI, SumJ)
	FieldPrime.Mul(DiffH, SumI, DiffH)
	local NewZ = DiffH
	FieldPrime.Mul(DiffG, SumJ, DiffG)
	local NewT = DiffG

	local Result = Storage or buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, NewY, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, NewZ, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, NewT, 0, COORD_SIZE)

	return Result
end

function Edwards25519.SubAffine(Point1: buffer, AffineNiels2: buffer, Storage: buffer?): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1Z = GetCoord(Point1, 2, COORD_BUFFER_2)
	local Point1T = GetCoord(Point1, 3, COORD_BUFFER_3)

	local Niels2YPlusX = GetCoord(AffineNiels2, 0, COORD_BUFFER_4)
	local Niels2YMinusX = GetCoord(AffineNiels2, 1, COORD_BUFFER_5)
	local Niels2T2d = GetCoord(AffineNiels2, 2, COORD_BUFFER_6)

	local DiffA = FieldPrime.Sub(Point1Y, Point1X)
	FieldPrime.Mul(DiffA, Niels2YPlusX, DiffA)
	local ProductB = DiffA

	FieldPrime.Add(Point1Y, Point1X, Point1Y)
	local SumC = Point1Y
	FieldPrime.Mul(SumC, Niels2YMinusX, SumC)
	local ProductD = SumC

	FieldPrime.Mul(Point1T, Niels2T2d, Point1T)
	local ProductE = Point1T

	FieldPrime.Add(Point1Z, Point1Z, Point1Z)
	local ProductF = Point1Z

	local DiffG = FieldPrime.Sub(ProductD, ProductB)
	local SumH = FieldPrime.Add(ProductF, ProductE)
	local DiffI = FieldPrime.Sub(ProductF, ProductE)
	FieldPrime.Add(ProductD, ProductB, ProductD)
	local SumJ = ProductD

	local NewX = FieldPrime.Mul(DiffG, SumH)
	local NewY = FieldPrime.Mul(DiffI, SumJ)
	FieldPrime.Mul(SumH, DiffI, SumH)
	local NewZ = SumH
	FieldPrime.Mul(DiffG, SumJ, DiffG)
	local NewT = DiffG

	local Result = Storage or buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, NewY, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, NewZ, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, NewT, 0, COORD_SIZE)

	return Result
end

function Edwards25519.Scale(Point1: buffer): buffer
	local Point1X = GetCoord(Point1, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(Point1, 1, COORD_BUFFER_1)
	local Point1Z = GetCoord(Point1, 2, COORD_BUFFER_2)

	FieldPrime.Invert(Point1Z, Point1Z)
	local ZInverse = Point1Z
	FieldPrime.Mul(Point1X, ZInverse, Point1X)
	local NewX = Point1X
	FieldPrime.Mul(Point1Y, ZInverse, Point1Y)
	local NewY = Point1Y
	local NewZ = FieldPrime.Num(1)
	local NewT = FieldPrime.Mul(NewX, NewY)

	local Result = buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, NewX, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, NewY, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, NewZ, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, NewT, 0, COORD_SIZE)

	return Result
end

function Edwards25519.Encode(Point1: buffer): buffer
	local ScaledPoint = Edwards25519.Scale(Point1)
	local Point1X = GetCoord(ScaledPoint, 0, COORD_BUFFER_0)
	local Point1Y = GetCoord(ScaledPoint, 1, COORD_BUFFER_1)

	local EncodedY = FieldPrime.Encode(Point1Y)
	local CanonicalX = FieldPrime.Canonicalize(Point1X)
	local XSignBit = buffer.readf64(CanonicalX, 0) % 2

	local ResultBuffer = buffer.create(32)
	buffer.copy(ResultBuffer, 0, EncodedY, 0, 32)

	local LastByte = buffer.readu8(ResultBuffer, 31)
	buffer.writeu8(ResultBuffer, 31, LastByte + XSignBit * 128)

	return ResultBuffer
end

function Edwards25519.Decode(EncodedBuffer: buffer): buffer?
	local WorkingBuffer = buffer.create(32)
	buffer.copy(WorkingBuffer, 0, EncodedBuffer, 0, 32)

	local LastByte = buffer.readu8(WorkingBuffer, 31)
	local SignBit = bit32.extract(LastByte, 7)
	buffer.writeu8(WorkingBuffer, 31, bit32.band(LastByte, 0x7F))

	local YCoord = FieldPrime.Decode(WorkingBuffer)
	local YSquared = FieldPrime.Square(YCoord)
	local Numerator = FieldPrime.Sub(YSquared, FieldPrime.Num(1))
	local Denominator = FieldPrime.Mul(YSquared, CURVE_D)
	local DenomPlusOne = FieldPrime.Add(Denominator, FieldPrime.Num(1))

	local XCoord = FieldPrime.SqrtDiv(Numerator, DenomPlusOne)
	if not XCoord then
		return nil
	end

	local CanonicalX = FieldPrime.Canonicalize(XCoord)
	local XSignBit = buffer.readf64(CanonicalX, 0) % 2

	if XSignBit ~= SignBit then
		XCoord = FieldPrime.Carry(FieldPrime.Neg(XCoord))
	end

	local ZCoord = FieldPrime.Num(1)
	local TCoord = FieldPrime.Mul(XCoord, YCoord)

	local Result = buffer.create(POINT_SIZE)
	buffer.copy(Result, 0 * COORD_SIZE, XCoord, 0, COORD_SIZE)
	buffer.copy(Result, 1 * COORD_SIZE, YCoord, 0, COORD_SIZE)
	buffer.copy(Result, 2 * COORD_SIZE, ZCoord, 0, COORD_SIZE)
	buffer.copy(Result, 3 * COORD_SIZE, TCoord, 0, COORD_SIZE)

	return Result
end

local BASEPOINT_BYTES = buffer.create(32) do
	local BasePointHex = {
		0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
		0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
	}

	for Index = 1, 32 do
		buffer.writeu8(BASEPOINT_BYTES, Index - 1, BasePointHex[Index])
	end

	BASEPONT_G = Edwards25519.Decode(BASEPOINT_BYTES)
end

function Edwards25519.AffineRadixWTable(BasePoint: buffer, RadixWidth: number): buffer
	if RadixWidth <= 0 or RadixWidth > 8 then
		error("Invalid Radix width", 2)
	end

	if buffer.len(BasePoint) ~= POINT_SIZE then
		error("Invalid Basepoint", 2)
	end

	local MaxWindows = math.ceil(256 / RadixWidth)
	local MaxRowSize = 2 ^ RadixWidth / 2

	local TableData = buffer.create(MaxWindows * MaxRowSize * AFFINE_NIELS_SIZE)

	local CurrentBasePoint = buffer.create(POINT_SIZE)
	buffer.copy(CurrentBasePoint, 0, BasePoint, 0, POINT_SIZE)

	local AffineNiels = Edwards25519.AffineNiels
	local Add = Edwards25519.Add
	local Double = Edwards25519.Double
	local Scale = Edwards25519.Scale
	local Niels = Edwards25519.Niels
	local NielsSize = AFFINE_NIELS_SIZE

	for WindowIndex = 1, MaxWindows do
		local BaseOffset = ((WindowIndex - 1) * MaxRowSize * NielsSize)
		local WorkingPoint = buffer.create(POINT_SIZE)
		buffer.copy(WorkingPoint, 0, CurrentBasePoint, 0, POINT_SIZE)

		local ScaledPoint = Scale(WorkingPoint)
		local FirstAffineNiels = AffineNiels(ScaledPoint)
		buffer.copy(TableData, BaseOffset, FirstAffineNiels, 0, NielsSize)

		local FirstNiels = Niels(ScaledPoint)

		for Multiple = 2, MaxRowSize do
			Add(WorkingPoint, FirstNiels, WorkingPoint)
			local Scaled = Scale(WorkingPoint)
			local AffineNielsBuffer = AffineNiels(Scaled)

			local Offset = BaseOffset + ((Multiple - 1) * NielsSize)
			buffer.copy(TableData, Offset, AffineNielsBuffer, 0, NielsSize)
		end

		for _ = 1, RadixWidth do
			CurrentBasePoint = Double(CurrentBasePoint)
		end
	end

	return TableData
end

do
	if BASEPONT_G then
		AFFINE_BASEPOINT_TABLE = Edwards25519.AffineRadixWTable(BASEPONT_G, BASE_RADIX_WIDTH)
	end
end

function Edwards25519.GetAffineBasePointTableEntry(WindowIndex: number, Multiple: number, Storage: buffer?): buffer
	if not AFFINE_BASEPOINT_TABLE then
		return buffer.create(0)
	end

	local BaseOffset = ((WindowIndex - 1) * BASE_POINT_ROW * AFFINE_NIELS_SIZE)
	local Offset = BaseOffset + ((Multiple - 1) * AFFINE_NIELS_SIZE)

	local AffineNielsPoint = Storage or buffer.create(AFFINE_NIELS_SIZE)
	buffer.copy(AffineNielsPoint, 0, AFFINE_BASEPOINT_TABLE, Offset, AFFINE_NIELS_SIZE)

	return AffineNielsPoint
end

function Edwards25519.SignedRadixW(ScalarBits: buffer, ScalarBitCount: number, RadixWidth: number): (buffer, number)
	if ScalarBitCount <= 0 or ScalarBitCount > 256 then
		error("Invalid scalar bit count", 2)
	end

	if RadixWidth <= 0 or RadixWidth > 8 then
		error("Invalid Radix width", 2)
	end

	local RadixValue = 2 ^ RadixWidth
	local HalfRadix = RadixValue / 2
	local MaxOutputLength = 272
	local OutputDigits = RADIX_OUTPUT
	local OutputLength, Accumulator = 0, 0
	local Multiplier = 1

	for BitIndex = 1, ScalarBitCount do
		if BitIndex > ScalarBitCount then
			break
		end

		local BitValue = buffer.readf64(ScalarBits, (BitIndex - 1) * 8)
		Accumulator += BitValue * Multiplier
		Multiplier *= 2

		while BitIndex == ScalarBitCount and Accumulator > 0 or Multiplier > RadixValue do
			if OutputLength >= MaxOutputLength then
				error("Output overflow in SignedRadixW")
			end

			local Remainder = Accumulator % RadixValue
			if Remainder >= HalfRadix then
				Remainder -= RadixValue
			end
			Accumulator = (Accumulator - Remainder) / RadixValue
			Multiplier /= RadixValue
			buffer.writef64(OutputDigits, OutputLength * 8, Remainder)
			OutputLength += 1
		end
	end

	return OutputDigits, OutputLength
end

function Edwards25519.WindowedNAF(ScalarBits: buffer, ScalarBitCount: number, WindowWidth: number): (buffer, number)
	local WindowValue = 2 ^ WindowWidth
	local HalfWindow = WindowValue / 2
	local OutputNAF = NAF_OUTPUT
	local OutputLength = 0
	local Accumulator = 0
	local Multiplier = 1

	for BitIndex = 1, ScalarBitCount do
		local BitValue = buffer.readf64(ScalarBits, (BitIndex - 1) * 8)
		Accumulator += BitValue * Multiplier
		Multiplier *= 2

		while BitIndex == ScalarBitCount and Accumulator > 0 or Multiplier > WindowValue do
			if Accumulator % 2 == 0 then
				Accumulator /= 2
				Multiplier /= 2
				buffer.writef64(OutputNAF, OutputLength * 8, 0)
				OutputLength += 1
			else
				local Remainder = Accumulator % WindowValue
				if Remainder >= HalfWindow then
					Remainder -= WindowValue
				end
				Accumulator -= Remainder
				buffer.writef64(OutputNAF, OutputLength * 8, Remainder)
				OutputLength += 1
			end
		end
	end

	while OutputLength > 0 and buffer.readf64(OutputNAF, (OutputLength - 1) * 8) == 0 do
		OutputLength -= 1
	end

	return OutputNAF, OutputLength
end

function Edwards25519.WindowedNAFTable(BasePoint: buffer, WindowWidth: number): buffer
	local PointSize = POINT_SIZE
	local CoordSize = COORD_SIZE
	local CurveK = CURVE_K
	local MaxOddMultiples = 2 ^ WindowWidth

	Edwards25519.Double(BasePoint, NAF_TABLE_DOUBLED)

	local TableData = buffer.create(MaxOddMultiples * PointSize)

	local FAdd = FieldPrime.Add
	local FSub = FieldPrime.Sub
	local FMul = FieldPrime.Mul

	local P1X = NAF_TABLE_P1X
	local P1Y = NAF_TABLE_P1Y
	local P1Z = NAF_TABLE_P1Z
	local P1T = NAF_TABLE_P1T
	local N2P = NAF_TABLE_N2P
	local N2M = NAF_TABLE_N2M
	local N2Z = NAF_TABLE_N2Z
	local N2T = NAF_TABLE_N2T
	local TMP = NAF_TABLE_TMP
	local DBLP = NAF_TABLE_DBL_P
	local DBLM = NAF_TABLE_DBL_M
	local DBLZ = NAF_TABLE_DBL_Z
	local DBLT = NAF_TABLE_DBL_T
	local Doubled = NAF_TABLE_DOUBLED

	buffer.copy(P1X, 0, Doubled, 0, CoordSize)
	buffer.copy(P1Y, 0, Doubled, CoordSize, CoordSize)
	buffer.copy(P1Z, 0, Doubled, 2 * CoordSize, CoordSize)
	buffer.copy(P1T, 0, Doubled, 3 * CoordSize, CoordSize)

	FAdd(P1Y, P1X, DBLP)
	FSub(P1Y, P1X, DBLM)
	FAdd(P1Z, P1Z, DBLZ)
	FMul(P1T, CurveK, DBLT)

	buffer.copy(P1X, 0, BasePoint, 0, CoordSize)
	buffer.copy(P1Y, 0, BasePoint, CoordSize, CoordSize)
	buffer.copy(P1Z, 0, BasePoint, 2 * CoordSize, CoordSize)
	buffer.copy(P1T, 0, BasePoint, 3 * CoordSize, CoordSize)

	FAdd(P1Y, P1X, N2P)
	FSub(P1Y, P1X, N2M)
	FAdd(P1Z, P1Z, N2Z)
	FMul(P1T, CurveK, N2T)

	buffer.copy(TableData, 0, N2P, 0, CoordSize)
	buffer.copy(TableData, CoordSize, N2M, 0, CoordSize)
	buffer.copy(TableData, 2 * CoordSize, N2Z, 0, CoordSize)
	buffer.copy(TableData, 3 * CoordSize, N2T, 0, CoordSize)

	buffer.copy(P1X, 0, BasePoint, 0, CoordSize)
	buffer.copy(P1Y, 0, BasePoint, CoordSize, CoordSize)
	buffer.copy(P1Z, 0, BasePoint, 2 * CoordSize, CoordSize)
	buffer.copy(P1T, 0, BasePoint, 3 * CoordSize, CoordSize)

	for OddMultiple = 3, MaxOddMultiples, 2 do
		local CurrentOffset = ((OddMultiple - 1) * PointSize)

		FSub(P1Y, P1X, TMP)
		FMul(TMP, DBLM, TMP)
		FAdd(P1Y, P1X, N2P)
		FMul(N2P, DBLP, N2P)
		FMul(P1T, DBLT, P1T)
		FMul(P1Z, DBLZ, P1Z)

		FSub(N2P, TMP, N2M)
		FSub(P1Z, P1T, N2Z)
		FAdd(P1Z, P1T, P1Z)
		FAdd(N2P, TMP, N2P)

		FMul(N2M, N2Z, P1X)
		FMul(P1Z, N2P, P1Y)
		FMul(N2Z, P1Z, P1Z)
		FMul(N2M, N2P, P1T)

		FAdd(P1Y, P1X, N2P)
		FSub(P1Y, P1X, N2M)
		FAdd(P1Z, P1Z, N2Z)
		FMul(P1T, CurveK, N2T)

		buffer.copy(TableData, CurrentOffset, N2P, 0, CoordSize)
		buffer.copy(TableData, CurrentOffset + CoordSize, N2M, 0, CoordSize)
		buffer.copy(TableData, CurrentOffset + 2 * CoordSize, N2Z, 0, CoordSize)
		buffer.copy(TableData, CurrentOffset + 3 * CoordSize, N2T, 0, CoordSize)
	end

	return TableData
end

function Edwards25519.MulG(ScalarBits: buffer, ScalarBitCount: number): buffer
	local PointSize = POINT_SIZE
	local CoordSize = COORD_SIZE
	local AffineNielsSize = AFFINE_NIELS_SIZE
	local IdentityO = IDENTITY_O
	local BaseRadixWidth = BASE_RADIX_WIDTH
	local BasePointRow = BASE_POINT_ROW
	local AffineTable = AFFINE_BASEPOINT_TABLE :: buffer

	local SignedWindows, WindowCount = Edwards25519.SignedRadixW(ScalarBits, ScalarBitCount, BaseRadixWidth)

	local ResultPoint = MULG_RESULT_POINT
	buffer.copy(ResultPoint, 0, IdentityO, 0, PointSize)

	local AffineNielsPoint = MULG_AFFINE_NIELS
	local DummyPoint = MULG_DUMMY_POINT
	buffer.copy(DummyPoint, 0, IdentityO, 0, PointSize)

	local FAdd = FieldPrime.Add
	local FSub = FieldPrime.Sub
	local FMul = FieldPrime.Mul

	local P1X = MULG_P1X
	local P1Y = MULG_P1Y
	local P1Z = MULG_P1Z
	local P1T = MULG_P1T
	local N2P = MULG_N2P
	local N2M = MULG_N2M
	local N2T = MULG_N2T
	local TMP = MULG_TMP

	for WindowIndex = 1, WindowCount do
		local WindowValue = buffer.readf64(SignedWindows, (WindowIndex - 1) * 8)

		if WindowValue > 0 then
			local BaseOffset = ((WindowIndex - 1) * BasePointRow * AffineNielsSize)
			local Offset = BaseOffset + ((WindowValue - 1) * AffineNielsSize)
			buffer.copy(AffineNielsPoint, 0, AffineTable, Offset, AffineNielsSize)

			buffer.copy(P1X, 0, ResultPoint, 0, CoordSize)
			buffer.copy(P1Y, 0, ResultPoint, CoordSize, CoordSize)
			buffer.copy(P1Z, 0, ResultPoint, 2 * CoordSize, CoordSize)
			buffer.copy(P1T, 0, ResultPoint, 3 * CoordSize, CoordSize)
			buffer.copy(N2P, 0, AffineNielsPoint, 0, CoordSize)
			buffer.copy(N2M, 0, AffineNielsPoint, CoordSize, CoordSize)
			buffer.copy(N2T, 0, AffineNielsPoint, 2 * CoordSize, CoordSize)

			FSub(P1Y, P1X, TMP)
			FMul(TMP, N2M, TMP)
			FAdd(P1Y, P1X, P1X)
			FMul(P1X, N2P, P1X)
			FMul(P1T, N2T, P1T)
			FAdd(P1Z, P1Z, P1Z)

			FSub(P1X, TMP, P1Y)
			FSub(P1Z, P1T, N2P)
			FAdd(P1Z, P1T, P1Z)
			FAdd(P1X, TMP, P1X)

			FMul(P1Y, N2P, TMP)
			FMul(P1Z, P1X, P1T)
			FMul(N2P, P1Z, P1Z)
			FMul(P1Y, P1X, P1X)

			buffer.copy(ResultPoint, 0, TMP, 0, CoordSize)
			buffer.copy(ResultPoint, CoordSize, P1T, 0, CoordSize)
			buffer.copy(ResultPoint, 2 * CoordSize, P1Z, 0, CoordSize)
			buffer.copy(ResultPoint, 3 * CoordSize, P1X, 0, CoordSize)

		elseif WindowValue < 0 then
			local BaseOffset = ((WindowIndex - 1) * BasePointRow * AffineNielsSize)
			local Offset = BaseOffset + (((-WindowValue) - 1) * AffineNielsSize)
			buffer.copy(AffineNielsPoint, 0, AffineTable, Offset, AffineNielsSize)

			buffer.copy(P1X, 0, ResultPoint, 0, CoordSize)
			buffer.copy(P1Y, 0, ResultPoint, CoordSize, CoordSize)
			buffer.copy(P1Z, 0, ResultPoint, 2 * CoordSize, CoordSize)
			buffer.copy(P1T, 0, ResultPoint, 3 * CoordSize, CoordSize)
			buffer.copy(N2P, 0, AffineNielsPoint, 0, CoordSize)
			buffer.copy(N2M, 0, AffineNielsPoint, CoordSize, CoordSize)
			buffer.copy(N2T, 0, AffineNielsPoint, 2 * CoordSize, CoordSize)

			FSub(P1Y, P1X, TMP)
			FMul(TMP, N2P, TMP)
			FAdd(P1Y, P1X, P1X)
			FMul(P1X, N2M, P1X)
			FMul(P1T, N2T, P1T)
			FAdd(P1Z, P1Z, P1Z)

			FSub(P1X, TMP, P1Y)
			FAdd(P1Z, P1T, N2P)
			FSub(P1Z, P1T, P1Z)
			FAdd(P1X, TMP, P1X)

			FMul(P1Y, N2P, TMP)
			FMul(P1Z, P1X, P1T)
			FMul(N2P, P1Z, P1Z)
			FMul(P1Y, P1X, P1X)

			buffer.copy(ResultPoint, 0, TMP, 0, CoordSize)
			buffer.copy(ResultPoint, CoordSize, P1T, 0, CoordSize)
			buffer.copy(ResultPoint, 2 * CoordSize, P1Z, 0, CoordSize)
			buffer.copy(ResultPoint, 3 * CoordSize, P1X, 0, CoordSize)

		else
			local BaseOffset = ((WindowIndex - 1) * BasePointRow * AffineNielsSize)
			buffer.copy(AffineNielsPoint, 0, AffineTable, BaseOffset, AffineNielsSize)

			buffer.copy(P1X, 0, DummyPoint, 0, CoordSize)
			buffer.copy(P1Y, 0, DummyPoint, CoordSize, CoordSize)
			buffer.copy(P1Z, 0, DummyPoint, 2 * CoordSize, CoordSize)
			buffer.copy(P1T, 0, DummyPoint, 3 * CoordSize, CoordSize)
			buffer.copy(N2P, 0, AffineNielsPoint, 0, CoordSize)
			buffer.copy(N2M, 0, AffineNielsPoint, CoordSize, CoordSize)
			buffer.copy(N2T, 0, AffineNielsPoint, 2 * CoordSize, CoordSize)

			FSub(P1Y, P1X, TMP)
			FMul(TMP, N2M, TMP)
			FAdd(P1Y, P1X, P1X)
			FMul(P1X, N2P, P1X)
			FMul(P1T, N2T, P1T)
			FAdd(P1Z, P1Z, P1Z)

			FSub(P1X, TMP, P1Y)
			FSub(P1Z, P1T, N2P)
			FAdd(P1Z, P1T, P1Z)
			FAdd(P1X, TMP, P1X)

			FMul(P1Y, N2P, TMP)
			FMul(P1Z, P1X, P1T)
			FMul(N2P, P1Z, P1Z)
			FMul(P1Y, P1X, P1X)

			buffer.copy(DummyPoint, 0, TMP, 0, CoordSize)
			buffer.copy(DummyPoint, CoordSize, P1T, 0, CoordSize)
			buffer.copy(DummyPoint, 2 * CoordSize, P1Z, 0, CoordSize)
			buffer.copy(DummyPoint, 3 * CoordSize, P1X, 0, CoordSize)
		end
	end

	local Output = buffer.create(PointSize)
	buffer.copy(Output, 0, ResultPoint, 0, PointSize)
	return Output
end

function Edwards25519.Mul(BasePoint: buffer, ScalarBits: buffer, ScalarBitCount: number): buffer
	local PointSize = POINT_SIZE
	local CoordSize = COORD_SIZE
	local IdentityO = IDENTITY_O

	local NAFForm, NAFLength = Edwards25519.WindowedNAF(ScalarBits, ScalarBitCount, 5)
	local MultipleTable = Edwards25519.WindowedNAFTable(BasePoint, 5)

	local ResultPoint = MUL_RESULT_POINT
	buffer.copy(ResultPoint, 0, IdentityO, 0, PointSize)

	local NielsPoint = MUL_NIELS_POINT

	local Square = FieldPrime.Square
	local FAdd = FieldPrime.Add
	local FSub = FieldPrime.Sub
	local FMul = FieldPrime.Mul
	local Carry = FieldPrime.Carry

	local DoubleX = MUL_DOUBLE_X
	local DoubleY = MUL_DOUBLE_Y
	local DoubleZ = MUL_DOUBLE_Z
	local DoubleA = MUL_DOUBLE_A
	local DoubleB = MUL_DOUBLE_B
	local DoubleE = MUL_DOUBLE_E
	local DoubleG = MUL_DOUBLE_G

	local P1X = MUL_P1X
	local P1Y = MUL_P1Y
	local P1Z = MUL_P1Z
	local P1T = MUL_P1T
	local N2P = MUL_N2P
	local N2M = MUL_N2M
	local N2Z = MUL_N2Z
	local N2T = MUL_N2T
	local TMP = MUL_TMP

	for NAFIndex = NAFLength, 1, -1 do
		local NAFDigit = buffer.readf64(NAFForm, (NAFIndex - 1) * 8)

		if NAFDigit == 0 then
			buffer.copy(DoubleX, 0, ResultPoint, 0, CoordSize)
			buffer.copy(DoubleY, 0, ResultPoint, CoordSize, CoordSize)
			buffer.copy(DoubleZ, 0, ResultPoint, 2 * CoordSize, CoordSize)

			Square(DoubleX, DoubleA)
			Square(DoubleY, DoubleB)
			Square(DoubleZ, DoubleZ)
			FAdd(DoubleZ, DoubleZ, DoubleZ)
			FAdd(DoubleA, DoubleB, DoubleE)
			FAdd(DoubleX, DoubleY, DoubleX)
			Square(DoubleX, DoubleG)
			FSub(DoubleG, DoubleE, DoubleG)
			Carry(DoubleG, DoubleG)
			FSub(DoubleB, DoubleA, DoubleB)
			FSub(DoubleZ, DoubleB, DoubleZ)
			Carry(DoubleZ, DoubleZ)

			FMul(DoubleG, DoubleZ, DoubleX)
			FMul(DoubleB, DoubleE, DoubleY)
			FMul(DoubleZ, DoubleB, DoubleZ)
			FMul(DoubleG, DoubleE, DoubleE)

			buffer.copy(ResultPoint, 0, DoubleX, 0, CoordSize)
			buffer.copy(ResultPoint, CoordSize, DoubleY, 0, CoordSize)
			buffer.copy(ResultPoint, 2 * CoordSize, DoubleZ, 0, CoordSize)
			buffer.copy(ResultPoint, 3 * CoordSize, DoubleE, 0, CoordSize)

		elseif NAFDigit > 0 then
			buffer.copy(NielsPoint, 0, MultipleTable, ((NAFDigit - 1) * PointSize), PointSize)

			buffer.copy(P1X, 0, ResultPoint, 0, CoordSize)
			buffer.copy(P1Y, 0, ResultPoint, CoordSize, CoordSize)
			buffer.copy(P1Z, 0, ResultPoint, 2 * CoordSize, CoordSize)
			buffer.copy(P1T, 0, ResultPoint, 3 * CoordSize, CoordSize)
			buffer.copy(N2P, 0, NielsPoint, 0, CoordSize)
			buffer.copy(N2M, 0, NielsPoint, CoordSize, CoordSize)
			buffer.copy(N2Z, 0, NielsPoint, 2 * CoordSize, CoordSize)
			buffer.copy(N2T, 0, NielsPoint, 3 * CoordSize, CoordSize)

			FSub(P1Y, P1X, TMP)
			FMul(TMP, N2M, TMP)
			FAdd(P1Y, P1X, P1X)
			FMul(P1X, N2P, P1X)
			FMul(P1T, N2T, P1T)
			FMul(P1Z, N2Z, P1Z)

			FSub(P1X, TMP, P1Y)
			FSub(P1Z, P1T, N2P)
			FAdd(P1Z, P1T, P1Z)
			FAdd(P1X, TMP, P1X)

			FMul(P1Y, N2P, TMP)
			FMul(P1Z, P1X, P1T)
			FMul(N2P, P1Z, P1Z)
			FMul(P1Y, P1X, P1X)

			buffer.copy(ResultPoint, 0, TMP, 0, CoordSize)
			buffer.copy(ResultPoint, CoordSize, P1T, 0, CoordSize)
			buffer.copy(ResultPoint, 2 * CoordSize, P1Z, 0, CoordSize)
			buffer.copy(ResultPoint, 3 * CoordSize, P1X, 0, CoordSize)

		else
			buffer.copy(NielsPoint, 0, MultipleTable, (((-NAFDigit) - 1) * PointSize), PointSize)

			buffer.copy(P1X, 0, ResultPoint, 0, CoordSize)
			buffer.copy(P1Y, 0, ResultPoint, CoordSize, CoordSize)
			buffer.copy(P1Z, 0, ResultPoint, 2 * CoordSize, CoordSize)
			buffer.copy(P1T, 0, ResultPoint, 3 * CoordSize, CoordSize)
			buffer.copy(N2P, 0, NielsPoint, 0, CoordSize)
			buffer.copy(N2M, 0, NielsPoint, CoordSize, CoordSize)
			buffer.copy(N2Z, 0, NielsPoint, 2 * CoordSize, CoordSize)
			buffer.copy(N2T, 0, NielsPoint, 3 * CoordSize, CoordSize)

			FSub(P1Y, P1X, TMP)
			FMul(TMP, N2P, TMP)
			FAdd(P1Y, P1X, P1X)
			FMul(P1X, N2M, P1X)
			FMul(P1T, N2T, P1T)
			FMul(P1Z, N2Z, P1Z)

			FSub(P1X, TMP, P1Y)
			FAdd(P1Z, P1T, N2P)
			FSub(P1Z, P1T, P1Z)
			FAdd(P1X, TMP, P1X)

			FMul(P1Y, N2P, TMP)
			FMul(P1Z, P1X, P1T)
			FMul(N2P, P1Z, P1Z)
			FMul(P1Y, P1X, P1X)

			buffer.copy(ResultPoint, 0, TMP, 0, CoordSize)
			buffer.copy(ResultPoint, CoordSize, P1T, 0, CoordSize)
			buffer.copy(ResultPoint, 2 * CoordSize, P1Z, 0, CoordSize)
			buffer.copy(ResultPoint, 3 * CoordSize, P1X, 0, CoordSize)
		end
	end

	local Output = buffer.create(PointSize)
	buffer.copy(Output, 0, ResultPoint, 0, PointSize)
	return Output
end

return Edwards25519]]></ProtectedString>
								<string name="ScriptGuid">{1417AC64-9298-4296-8810-1A3D53F119E4}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Edwards25519</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD068DAE13C4E48CCB9F45DD8019A22C3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Field Prime (Curve25519 Base Field)

	Return type: varies by function
	Example usage:
		local FieldPrime = require("FieldPrime")

		--------Usage Case 1: Basic arithmetic--------
		local ElementA = FieldPrime.Num(42)
		local ElementB = FieldPrime.Num(17)
		local Sum = FieldPrime.Add(ElementA, ElementB)
		local Product = FieldPrime.Mul(ElementA, ElementB)

		--------Usage Case 2: Encoding/decoding--------
		local Encoded = FieldPrime.Encode(ElementA)
		local Decoded = FieldPrime.Decode(Encoded)
--]=]

--!strict
--!optimize 2
--!native

local SIZE = 104
local COMPOUND_V = (19 / 2 ^ 255)
local SQUARES = buffer.create(SIZE) do
	local Tbl = {
		0958640 * 2 ^ 0,
		0826664 * 2 ^ 22,
		1613251 * 2 ^ 43,
		1041528 * 2 ^ 64,
		0013673 * 2 ^ 85,
		0387171 * 2 ^ 107,
		1824679 * 2 ^ 128,
		0313839 * 2 ^ 149,
		0709440 * 2 ^ 170,
		0122635 * 2 ^ 192,
		0262782 * 2 ^ 213,
		0712905 * 2 ^ 234,
	}

	for Index = 1, 12 do
		buffer.writef64(SQUARES, (Index - 1) * 8, Tbl[Index])
	end
end

local FieldPrime = {}

function FieldPrime.Num(Number: number): buffer
	local Buf = buffer.create(SIZE)
	buffer.writef64(Buf, 0, Number)

	return Buf
end

function FieldPrime.Neg(ElementA: buffer): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local Buf = buffer.create(SIZE)

	buffer.writef64(Buf, 0, -A00)
	buffer.writef64(Buf, 8, -A01)
	buffer.writef64(Buf, 16, -A02)
	buffer.writef64(Buf, 24, -A03)
	buffer.writef64(Buf, 32, -A04)
	buffer.writef64(Buf, 40, -A05)
	buffer.writef64(Buf, 48, -A06)
	buffer.writef64(Buf, 56, -A07)
	buffer.writef64(Buf, 64, -A08)
	buffer.writef64(Buf, 72, -A09)
	buffer.writef64(Buf, 80, -A10)
	buffer.writef64(Buf, 88, -A11)

	return Buf
end

function FieldPrime.Add(ElementA: buffer, ElementB: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local B00, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11 =
		buffer.readf64(ElementB, 0), buffer.readf64(ElementB, 8),
		buffer.readf64(ElementB, 16), buffer.readf64(ElementB, 24),
		buffer.readf64(ElementB, 32), buffer.readf64(ElementB, 40),
		buffer.readf64(ElementB, 48), buffer.readf64(ElementB, 56),
		buffer.readf64(ElementB, 64), buffer.readf64(ElementB, 72),
		buffer.readf64(ElementB, 80), buffer.readf64(ElementB, 88)

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 + B00)
	buffer.writef64(Buf, 8, A01 + B01)
	buffer.writef64(Buf, 16, A02 + B02)
	buffer.writef64(Buf, 24, A03 + B03)
	buffer.writef64(Buf, 32, A04 + B04)
	buffer.writef64(Buf, 40, A05 + B05)
	buffer.writef64(Buf, 48, A06 + B06)
	buffer.writef64(Buf, 56, A07 + B07)
	buffer.writef64(Buf, 64, A08 + B08)
	buffer.writef64(Buf, 72, A09 + B09)
	buffer.writef64(Buf, 80, A10 + B10)
	buffer.writef64(Buf, 88, A11 + B11)

	return Buf
end

function FieldPrime.Sub(ElementA: buffer, ElementB: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local B00, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11 =
		buffer.readf64(ElementB, 0), buffer.readf64(ElementB, 8),
		buffer.readf64(ElementB, 16), buffer.readf64(ElementB, 24),
		buffer.readf64(ElementB, 32), buffer.readf64(ElementB, 40),
		buffer.readf64(ElementB, 48), buffer.readf64(ElementB, 56),
		buffer.readf64(ElementB, 64), buffer.readf64(ElementB, 72),
		buffer.readf64(ElementB, 80), buffer.readf64(ElementB, 88)

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 - B00)
	buffer.writef64(Buf, 8, A01 - B01)
	buffer.writef64(Buf, 16, A02 - B02)
	buffer.writef64(Buf, 24, A03 - B03)
	buffer.writef64(Buf, 32, A04 - B04)
	buffer.writef64(Buf, 40, A05 - B05)
	buffer.writef64(Buf, 48, A06 - B06)
	buffer.writef64(Buf, 56, A07 - B07)
	buffer.writef64(Buf, 64, A08 - B08)
	buffer.writef64(Buf, 72, A09 - B09)
	buffer.writef64(Buf, 80, A10 - B10)
	buffer.writef64(Buf, 88, A11 - B11)

	return Buf
end

function FieldPrime.Carry(ElementA: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local C00, C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11

	C11 = A11 + 3 * 2 ^ 306 - 3 * 2 ^ 306
	A00 += 19 / 2 ^ 255 * C11

	C00 = A00 + 3 * 2 ^ 73 - 3 * 2 ^ 73
	A01 += C00
	C01 = A01 + 3 * 2 ^ 94 - 3 * 2 ^ 94
	A02 += C01
	C02 = A02 + 3 * 2 ^ 115 - 3 * 2 ^ 115
	A03 += C02
	C03 = A03 + 3 * 2 ^ 136 - 3 * 2 ^ 136
	A04 += C03
	C04 = A04 + 3 * 2 ^ 158 - 3 * 2 ^ 158
	A05 += C04
	C05 = A05 + 3 * 2 ^ 179 - 3 * 2 ^ 179
	A06 += C05
	C06 = A06 + 3 * 2 ^ 200 - 3 * 2 ^ 200
	A07 += C06
	C07 = A07 + 3 * 2 ^ 221 - 3 * 2 ^ 221
	A08 += C07
	C08 = A08 + 3 * 2 ^ 243 - 3 * 2 ^ 243
	A09 += C08
	C09 = A09 + 3 * 2 ^ 264 - 3 * 2 ^ 264
	A10 += C09
	C10 = A10 + 3 * 2 ^ 285 - 3 * 2 ^ 285
	A11 = A11 - C11 + C10

	C11 = A11 + 3 * 2 ^ 306 - 3 * 2 ^ 306

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 - C00 + 19 / 2 ^ 255 * C11)
	buffer.writef64(Buf, 8, A01 - C01)
	buffer.writef64(Buf, 16, A02 - C02)
	buffer.writef64(Buf, 24, A03 - C03)
	buffer.writef64(Buf, 32, A04 - C04)
	buffer.writef64(Buf, 40, A05 - C05)
	buffer.writef64(Buf, 48, A06 - C06)
	buffer.writef64(Buf, 56, A07 - C07)
	buffer.writef64(Buf, 64, A08 - C08)
	buffer.writef64(Buf, 72, A09 - C09)
	buffer.writef64(Buf, 80, A10 - C10)
	buffer.writef64(Buf, 88, A11 - C11)

	return Buf
end

function FieldPrime.Canonicalize(ElementA: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local C00, C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11

	C00 = A00 % 2 ^ 22
	A01 += A00 - C00
	C01 = A01 % 2 ^ 43
	A02 += A01 - C01
	C02 = A02 % 2 ^ 64
	A03 += A02 - C02
	C03 = A03 % 2 ^ 85
	A04 += A03 - C03
	C04 = A04 % 2 ^ 107
	A05 += A04 - C04
	C05 = A05 % 2 ^ 128
	A06 += A05 - C05
	C06 = A06 % 2 ^ 149
	A07 += A06 - C06
	C07 = A07 % 2 ^ 170
	A08 += A07 - C07
	C08 = A08 % 2 ^ 192
	A09 += A08 - C08
	C09 = A09 % 2 ^ 213
	A10 += A09 - C09
	C10 = A10 % 2 ^ 234
	A11 += A10 - C10
	C11 = A11 % 2 ^ 255
	C00 += 19 / 2 ^ 255 * (A11 - C11)

	local Buf = Storage or buffer.create(SIZE)
	if C11 / 2 ^ 234 == 2 ^ 21 - 1
		and C10 / 2 ^ 213 == 2 ^ 21 - 1
		and C09 / 2 ^ 192 == 2 ^ 21 - 1
		and C08 / 2 ^ 170 == 2 ^ 22 - 1
		and C07 / 2 ^ 149 == 2 ^ 21 - 1
		and C06 / 2 ^ 128 == 2 ^ 21 - 1
		and C05 / 2 ^ 107 == 2 ^ 21 - 1
		and C04 / 2 ^ 85 == 2 ^ 22 - 1
		and C03 / 2 ^ 64 == 2 ^ 21 - 1
		and C02 / 2 ^ 43 == 2 ^ 21 - 1
		and C01 / 2 ^ 22 == 2 ^ 21 - 1
		and C00 >= 2 ^ 22 - 19
	then
		buffer.writef64(Buf, 0, 19 - 2 ^ 22 + C00)
		for Index = 8, 88, 8 do
			buffer.writef64(Buf, Index, 0)
		end
	else
		buffer.writef64(Buf, 0, C00)
		buffer.writef64(Buf, 8, C01)
		buffer.writef64(Buf, 16, C02)
		buffer.writef64(Buf, 24, C03)
		buffer.writef64(Buf, 32, C04)
		buffer.writef64(Buf, 40, C05)
		buffer.writef64(Buf, 48, C06)
		buffer.writef64(Buf, 56, C07)
		buffer.writef64(Buf, 64, C08)
		buffer.writef64(Buf, 72, C09)
		buffer.writef64(Buf, 80, C10)
		buffer.writef64(Buf, 88, C11)
	end

	return Buf
end

function FieldPrime.Eq(ElementA: buffer, ElementB: buffer): boolean
	local Difference = FieldPrime.Canonicalize(FieldPrime.Sub(ElementA, ElementB))
	local DifferenceAccumulator = 0
	for LimbIndex = 0, 88, 8 do
		local LimbLow = buffer.readu32(Difference, LimbIndex)
		local LimbHigh = buffer.readu32(Difference, LimbIndex + 4)
		DifferenceAccumulator = bit32.bor(DifferenceAccumulator, LimbLow, LimbHigh)
	end

	return DifferenceAccumulator == 0
end

local A00: number, A01: number, A02: number, A03: number, A04: number, A05: number, A06: number,
A07: number, A08: number, A09: number, A10: number, A11: number
local B00: number, B01: number, B02: number, B03: number, B04: number, B05: number, B06: number,
B07: number, B08: number, B09: number, B10: number, B11: number

function FieldPrime.Mul(ElementA: buffer, ElementB: buffer, Storage: buffer?): buffer
	local CompoundV = COMPOUND_V
	A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	B00, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11 =
		buffer.readf64(ElementB, 0), buffer.readf64(ElementB, 8),
		buffer.readf64(ElementB, 16), buffer.readf64(ElementB, 24),
		buffer.readf64(ElementB, 32), buffer.readf64(ElementB, 40),
		buffer.readf64(ElementB, 48), buffer.readf64(ElementB, 56),
		buffer.readf64(ElementB, 64), buffer.readf64(ElementB, 72),
		buffer.readf64(ElementB, 80), buffer.readf64(ElementB, 88)

	local T00: number, T01: number, T02: number, T03: number, T04: number, T05: number, T06: number,
	T07: number, T08: number, T09: number, T10: number, T11: number =
		A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11

	local U00: number, U01: number, U02: number, U03: number, U04: number, U05: number, U06: number,
	U07: number, U08: number, U09: number, U10: number, U11: number =
		B00, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11

	local C00 = T11 * U01
		+ T10 * U02
		+ T09 * U03
		+ T08 * U04
		+ T07 * U05
		+ T06 * U06
		+ T05 * U07
		+ T04 * U08
		+ T03 * U09
		+ T02 * U10
		+ T01 * U11

	local C01 = T11 * U02
		+ T10 * U03
		+ T09 * U04
		+ T08 * U05
		+ T07 * U06
		+ T06 * U07
		+ T05 * U08
		+ T04 * U09
		+ T03 * U10
		+ T02 * U11

	local C02 = T11 * U03
		+ T10 * U04
		+ T09 * U05
		+ T08 * U06
		+ T07 * U07
		+ T06 * U08
		+ T05 * U09
		+ T04 * U10
		+ T03 * U11

	local C03 = T11 * U04
		+ T10 * U05
		+ T09 * U06
		+ T08 * U07
		+ T07 * U08
		+ T06 * U09
		+ T05 * U10
		+ T04 * U11

	local C04 = T11 * U05
		+ T10 * U06
		+ T09 * U07
		+ T08 * U08
		+ T07 * U09
		+ T06 * U10
		+ T05 * U11

	local C05 = T11 * U06
		+ T10 * U07
		+ T09 * U08
		+ T08 * U09
		+ T07 * U10
		+ T06 * U11

	local C06 = T11 * U07
		+ T10 * U08
		+ T09 * U09
		+ T08 * U10
		+ T07 * U11

	local C07 = T11 * U08
		+ T10 * U09
		+ T09 * U10
		+ T08 * U11

	local C08 = T11 * U09
		+ T10 * U10
		+ T09 * U11

	local C09 = T11 * U10 + T10 * U11
	local C10 = T11 * U11

	C00 *= CompoundV
	C00 += T00 * U00

	C01 *= CompoundV
	C01 += T01 * U00
		+ T00 * U01

	C02 *= CompoundV
	C02 += T02 * U00
		+ T01 * U01
		+ T00 * U02

	C03 *= CompoundV
	C03 += T03 * U00
		+ T02 * U01
		+ T01 * U02
		+ T00 * U03

	C04 *= CompoundV
	C04 += T04 * U00
		+ T03 * U01
		+ T02 * U02
		+ T01 * U03
		+ T00 * U04

	C05 *= CompoundV
	C05 += T05 * U00
		+ T04 * U01
		+ T03 * U02
		+ T02 * U03
		+ T01 * U04
		+ T00 * U05

	C06 *= CompoundV
	C06 += T06 * U00
		+ T05 * U01
		+ T04 * U02
		+ T03 * U03
		+ T02 * U04
		+ T01 * U05
		+ T00 * U06

	C07 *= CompoundV
	C07 += T07 * U00
		+ T06 * U01
		+ T05 * U02
		+ T04 * U03
		+ T03 * U04
		+ T02 * U05
		+ T01 * U06
		+ T00 * U07

	C08 *= CompoundV
	C08 += T08 * U00
		+ T07 * U01
		+ T06 * U02
		+ T05 * U03
		+ T04 * U04
		+ T03 * U05
		+ T02 * U06
		+ T01 * U07
		+ T00 * U08

	C09 *= CompoundV
	C09 += T09 * U00
		+ T08 * U01
		+ T07 * U02
		+ T06 * U03
		+ T05 * U04
		+ T04 * U05
		+ T03 * U06
		+ T02 * U07
		+ T01 * U08
		+ T00 * U09

	C10 *= CompoundV
	C10 += T10 * U00
		+ T09 * U01
		+ T08 * U02
		+ T07 * U03
		+ T06 * U04
		+ T05 * U05
		+ T04 * U06
		+ T03 * U07
		+ T02 * U08
		+ T01 * U09
		+ T00 * U10

	local C11 = T11 * U00
		+ T10 * U01
		+ T09 * U02
		+ T08 * U03
		+ T07 * U04
		+ T06 * U05
		+ T05 * U06
		+ T04 * U07
		+ T03 * U08
		+ T02 * U09
		+ T01 * U10
		+ T00 * U11

	T10 = C10 + 3 * 2 ^ 285 - 3 * 2 ^ 285
	C11 += T10
	T11 = C11 + 3 * 2 ^ 306 - 3 * 2 ^ 306
	C00 += CompoundV * T11

	T00 = C00 + 3 * 2 ^ 73 - 3 * 2 ^ 73
	C01 += T00
	T01 = C01 + 3 * 2 ^ 94 - 3 * 2 ^ 94
	C02 += T01
	T02 = C02 + 3 * 2 ^ 115 - 3 * 2 ^ 115
	C03 += T02
	T03 = C03 + 3 * 2 ^ 136 - 3 * 2 ^ 136
	C04 += T03
	T04 = C04 + 3 * 2 ^ 158 - 3 * 2 ^ 158
	C05 += T04
	T05 = C05 + 3 * 2 ^ 179 - 3 * 2 ^ 179
	C06 += T05
	T06 = C06 + 3 * 2 ^ 200 - 3 * 2 ^ 200
	C07 += T06
	T07 = C07 + 3 * 2 ^ 221 - 3 * 2 ^ 221
	C08 += T07
	T08 = C08 + 3 * 2 ^ 243 - 3 * 2 ^ 243
	C09 += T08
	T09 = C09 + 3 * 2 ^ 264 - 3 * 2 ^ 264
	C10 = C10 - T10 + T09
	T10 = C10 + 3 * 2 ^ 285 - 3 * 2 ^ 285
	C11 = C11 - T11 + T10

	T11 = C11 + 3 * 2 ^ 306 - 3 * 2 ^ 306

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, C00 - T00 + CompoundV * T11)
	buffer.writef64(Buf, 8, C01 - T01)
	buffer.writef64(Buf, 16, C02 - T02)
	buffer.writef64(Buf, 24, C03 - T03)
	buffer.writef64(Buf, 32, C04 - T04)
	buffer.writef64(Buf, 40, C05 - T05)
	buffer.writef64(Buf, 48, C06 - T06)
	buffer.writef64(Buf, 56, C07 - T07)
	buffer.writef64(Buf, 64, C08 - T08)
	buffer.writef64(Buf, 72, C09 - T09)
	buffer.writef64(Buf, 80, C10 - T10)
	buffer.writef64(Buf, 88, C11 - T11)

	return Buf
end

function FieldPrime.Square(ElementA: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local D00 = A00 * 2
	local D01 = A01 * 2
	local D02 = A02 * 2
	local D03 = A03 * 2
	local D04 = A04 * 2
	local D05 = A05 * 2
	local D06 = A06 * 2
	local D07 = A07 * 2
	local D08 = A08 * 2
	local D09 = A09 * 2
	local D10 = A10 * 2

	local ReductionFactor = 19 / 2 ^ 255

	local H00 = A11 * D01 + A10 * D02 + A09 * D03 + A08 * D04 + A07 * D05 + A06 * A06
	local H01 = A11 * D02 + A10 * D03 + A09 * D04 + A08 * D05 + A07 * D06
	local H02 = A11 * D03 + A10 * D04 + A09 * D05 + A08 * D06 + A07 * A07
	local H03 = A11 * D04 + A10 * D05 + A09 * D06 + A08 * D07
	local H04 = A11 * D05 + A10 * D06 + A09 * D07 + A08 * A08
	local H05 = A11 * D06 + A10 * D07 + A09 * D08
	local H06 = A11 * D07 + A10 * D08 + A09 * A09
	local H07 = A11 * D08 + A10 * D09
	local H08 = A11 * D09 + A10 * A10
	local H09 = A11 * D10
	local H10 = A11 * A11

	local L00 = A00 * A00
	local L01 = A01 * D00
	local L02 = A02 * D00 + A01 * A01
	local L03 = A03 * D00 + A02 * D01
	local L04 = A04 * D00 + A03 * D01 + A02 * A02
	local L05 = A05 * D00 + A04 * D01 + A03 * D02
	local L06 = A06 * D00 + A05 * D01 + A04 * D02 + A03 * A03
	local L07 = A07 * D00 + A06 * D01 + A05 * D02 + A04 * D03
	local L08 = A08 * D00 + A07 * D01 + A06 * D02 + A05 * D03 + A04 * A04
	local L09 = A09 * D00 + A08 * D01 + A07 * D02 + A06 * D03 + A05 * D04
	local L10 = A10 * D00 + A09 * D01 + A08 * D02 + A07 * D03 + A06 * D04 + A05 * A05
	local L11 = A11 * D00 + A10 * D01 + A09 * D02 + A08 * D03 + A07 * D04 + A06 * D05

	local Result = Storage or buffer.create(SIZE)
	buffer.writef64(Result, 0, H00 * ReductionFactor + L00)
	buffer.writef64(Result, 8, H01 * ReductionFactor + L01)
	buffer.writef64(Result, 16, H02 * ReductionFactor + L02)
	buffer.writef64(Result, 24, H03 * ReductionFactor + L03)
	buffer.writef64(Result, 32, H04 * ReductionFactor + L04)
	buffer.writef64(Result, 40, H05 * ReductionFactor + L05)
	buffer.writef64(Result, 48, H06 * ReductionFactor + L06)
	buffer.writef64(Result, 56, H07 * ReductionFactor + L07)
	buffer.writef64(Result, 64, H08 * ReductionFactor + L08)
	buffer.writef64(Result, 72, H09 * ReductionFactor + L09)
	buffer.writef64(Result, 80, H10 * ReductionFactor + L10)
	buffer.writef64(Result, 88, L11)

	return FieldPrime.Carry(Result, Result)
end

function FieldPrime.KMul(ElementA: buffer, SmallK: number, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local C00, C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11

	A00 *= SmallK
	A01 *= SmallK
	A02 *= SmallK
	A03 *= SmallK
	A04 *= SmallK
	A05 *= SmallK
	A06 *= SmallK
	A07 *= SmallK
	A08 *= SmallK
	A09 *= SmallK
	A10 *= SmallK
	A11 *= SmallK

	C11 = A11 + 3 * 2 ^ 306 - 3 * 2 ^ 306
	A00 += 19 / 2 ^ 255 * C11

	C00 = A00 + 3 * 2 ^ 73 - 3 * 2 ^ 73
	A01 += C00
	C01 = A01 + 3 * 2 ^ 94 - 3 * 2 ^ 94
	A02 += C01
	C02 = A02 + 3 * 2 ^ 115 - 3 * 2 ^ 115
	A03 += C02
	C03 = A03 + 3 * 2 ^ 136 - 3 * 2 ^ 136
	A04 += C03
	C04 = A04 + 3 * 2 ^ 158 - 3 * 2 ^ 158
	A05 += C04
	C05 = A05 + 3 * 2 ^ 179 - 3 * 2 ^ 179
	A06 += C05
	C06 = A06 + 3 * 2 ^ 200 - 3 * 2 ^ 200
	A07 += C06
	C07 = A07 + 3 * 2 ^ 221 - 3 * 2 ^ 221
	A08 += C07
	C08 = A08 + 3 * 2 ^ 243 - 3 * 2 ^ 243
	A09 += C08
	C09 = A09 + 3 * 2 ^ 264 - 3 * 2 ^ 264
	A10 += C09
	C10 = A10 + 3 * 2 ^ 285 - 3 * 2 ^ 285
	A11 = A11 - C11 + C10

	C11 = A11 + 3 * 2 ^ 306 - 3 * 2 ^ 306

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 - C00 + 19 / 2 ^ 255 * C11)
	buffer.writef64(Buf, 8, A01 - C01)
	buffer.writef64(Buf, 16, A02 - C02)
	buffer.writef64(Buf, 24, A03 - C03)
	buffer.writef64(Buf, 32, A04 - C04)
	buffer.writef64(Buf, 40, A05 - C05)
	buffer.writef64(Buf, 48, A06 - C06)
	buffer.writef64(Buf, 56, A07 - C07)
	buffer.writef64(Buf, 64, A08 - C08)
	buffer.writef64(Buf, 72, A09 - C09)
	buffer.writef64(Buf, 80, A10 - C10)
	buffer.writef64(Buf, 88, A11 - C11)

	return Buf
end

function FieldPrime.NSquare(ElementA: buffer, SquareCount: number, StoreInBuffer: boolean?): buffer
	local Square = FieldPrime.Square
	if StoreInBuffer then
		for _ = 1, SquareCount do
			Square(ElementA, ElementA)
		end

		return ElementA
	else
		for _ = 1, SquareCount do
			ElementA = Square(ElementA)
		end

		return ElementA
	end
end

function FieldPrime.Invert(ElementA: buffer, Storage: buffer?): buffer
	local Mul = FieldPrime.Mul

	local A2 = FieldPrime.Square(ElementA)
	local A9 = Mul(ElementA, FieldPrime.NSquare(A2, 2))
	local A11 = Mul(A9, A2)

	local X5 = Mul(FieldPrime.Square(A11), A9)
	local X10 = Mul(FieldPrime.NSquare(X5, 5), X5)
	local X20 = Mul(FieldPrime.NSquare(X10, 10), X10)
	local X40 = Mul(FieldPrime.NSquare(X20, 20), X20)
	local X50 = Mul(FieldPrime.NSquare(X40, 10), X10)
	local X100 = Mul(FieldPrime.NSquare(X50, 50), X50)
	local X200 = Mul(FieldPrime.NSquare(X100, 100), X100)
	local X250 = Mul(FieldPrime.NSquare(X200, 50), X50)

	return Mul(FieldPrime.NSquare(X250, 5), A11, Storage)
end

function FieldPrime.SqrtDiv(ElementU: buffer, ElementV: buffer): buffer?
	local Mul = FieldPrime.Mul
	local Square = FieldPrime.Square
	local Carry = FieldPrime.Carry

	Carry(ElementU, ElementU)

	local V2 = Square(ElementV)
	local V3 = Mul(ElementV, V2)
	local UV3 = Mul(ElementU, V3)
	local V4 = Square(V2)
	local UV7 = Mul(UV3, V4)

	local X2 = Mul(Square(UV7), UV7)
	local X4 = Mul(FieldPrime.NSquare(X2, 2), X2)
	local X8 = Mul(FieldPrime.NSquare(X4, 4), X4)
	local X16 = Mul(FieldPrime.NSquare(X8, 8), X8)
	local X18 = Mul(FieldPrime.NSquare(X16, 2), X2)
	local X32 = Mul(FieldPrime.NSquare(X16, 16), X16)
	local X50 = Mul(FieldPrime.NSquare(X32, 18), X18)
	local X100 = Mul(FieldPrime.NSquare(X50, 50), X50)
	local X200 = Mul(FieldPrime.NSquare(X100, 100), X100)
	local X250 = Mul(FieldPrime.NSquare(X200, 50), X50)
	local PowerResult = Mul(FieldPrime.NSquare(X250, 2), UV7)

	local CandidateB = Mul(UV3, PowerResult)
	local B2 = Square(CandidateB)
	local VB2 = Mul(ElementV, B2)

	if not FieldPrime.Eq(VB2, ElementU) then
		CandidateB = Mul(CandidateB, SQUARES)
		B2 = Square(CandidateB)
		VB2 = Mul(ElementV, B2)
	end

	if FieldPrime.Eq(VB2, ElementU) then
		return CandidateB
	else
		return nil
	end
end

function FieldPrime.Encode(ElementA: buffer): buffer
	ElementA = FieldPrime.Canonicalize(ElementA)
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11 =
		buffer.readf64(ElementA, 0), buffer.readf64(ElementA, 8),
		buffer.readf64(ElementA, 16), buffer.readf64(ElementA, 24),
		buffer.readf64(ElementA, 32), buffer.readf64(ElementA, 40),
		buffer.readf64(ElementA, 48), buffer.readf64(ElementA, 56),
		buffer.readf64(ElementA, 64), buffer.readf64(ElementA, 72),
		buffer.readf64(ElementA, 80), buffer.readf64(ElementA, 88)

	local Buf = buffer.create(32)
	local ByteIndex = 0
	local Accumulator = A00

	local Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	local Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Accumulator += A01 / 2 ^ 16

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	local Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)
	Accumulator = (Accumulator - Byte2) / 256
	ByteIndex += 1

	Accumulator += A02 / 2 ^ 40

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)
	Accumulator = (Accumulator - Byte2) / 256
	ByteIndex += 1

	Accumulator += A03 / 2 ^ 64

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Accumulator += A04 / 2 ^ 80

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)
	Accumulator = (Accumulator - Byte2) / 256
	ByteIndex += 1

	Accumulator += A05 / 2 ^ 104

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)
	Accumulator = (Accumulator - Byte2) / 256
	ByteIndex += 1

	Accumulator += A06 / 2 ^ 128

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Accumulator += A07 / 2 ^ 144

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)
	Accumulator = (Accumulator - Byte2) / 256
	ByteIndex += 1

	Accumulator += A08 / 2 ^ 168

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)
	Accumulator = (Accumulator - Byte2) / 256
	ByteIndex += 1

	Accumulator += A09 / 2 ^ 192

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Accumulator += A10 / 2 ^ 208

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)
	Accumulator = (Accumulator - Byte2) / 256
	ByteIndex += 1

	Accumulator += A11 / 2 ^ 232

	Byte0 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte0)
	Accumulator = (Accumulator - Byte0) / 256
	ByteIndex += 1

	Byte1 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte1)
	Accumulator = (Accumulator - Byte1) / 256
	ByteIndex += 1

	Byte2 = Accumulator % 256
	buffer.writeu8(Buf, ByteIndex, Byte2)

	return Buf
end

function FieldPrime.Decode(EncodedBytes: buffer): buffer
	local B0, B1, B2 = buffer.readu8(EncodedBytes, 0), buffer.readu8(EncodedBytes, 1), buffer.readu8(EncodedBytes, 2)
	local W00 = B0 + B1 * 256 + B2 * 65536

	B0, B1, B2 = buffer.readu8(EncodedBytes, 3), buffer.readu8(EncodedBytes, 4), buffer.readu8(EncodedBytes, 5)
	local W01 = B0 + B1 * 256 + B2 * 65536

	local W02 = buffer.readu16(EncodedBytes, 6)

	B0, B1, B2 = buffer.readu8(EncodedBytes, 8), buffer.readu8(EncodedBytes, 9), buffer.readu8(EncodedBytes, 10)
	local W03 = B0 + B1 * 256 + B2 * 65536

	B0, B1, B2 = buffer.readu8(EncodedBytes, 11), buffer.readu8(EncodedBytes, 12), buffer.readu8(EncodedBytes, 13)
	local W04 = B0 + B1 * 256 + B2 * 65536

	local W05 = buffer.readu16(EncodedBytes, 14)

	B0, B1, B2 = buffer.readu8(EncodedBytes, 16), buffer.readu8(EncodedBytes, 17), buffer.readu8(EncodedBytes, 18)
	local W06 = B0 + B1 * 256 + B2 * 65536

	B0, B1, B2 = buffer.readu8(EncodedBytes, 19), buffer.readu8(EncodedBytes, 20), buffer.readu8(EncodedBytes, 21)
	local W07 = B0 + B1 * 256 + B2 * 65536

	local W08 = buffer.readu16(EncodedBytes, 22)

	B0, B1, B2 = buffer.readu8(EncodedBytes, 24), buffer.readu8(EncodedBytes, 25), buffer.readu8(EncodedBytes, 26)
	local W09 = B0 + B1 * 256 + B2 * 65536

	B0, B1, B2 = buffer.readu8(EncodedBytes, 27), buffer.readu8(EncodedBytes, 28), buffer.readu8(EncodedBytes, 29)
	local W10 = B0 + B1 * 256 + B2 * 65536

	local W11 = buffer.readu16(EncodedBytes, 30) % 32768

	local Buf = buffer.create(SIZE)

	buffer.writef64(Buf, 0, W00)
	buffer.writef64(Buf, 8, W01 * 2 ^ 24)
	buffer.writef64(Buf, 16, W02 * 2 ^ 48)
	buffer.writef64(Buf, 24, W03 * 2 ^ 64)
	buffer.writef64(Buf, 32, W04 * 2 ^ 88)
	buffer.writef64(Buf, 40, W05 * 2 ^ 112)
	buffer.writef64(Buf, 48, W06 * 2 ^ 128)
	buffer.writef64(Buf, 56, W07 * 2 ^ 152)
	buffer.writef64(Buf, 64, W08 * 2 ^ 176)
	buffer.writef64(Buf, 72, W09 * 2 ^ 192)
	buffer.writef64(Buf, 80, W10 * 2 ^ 216)
	buffer.writef64(Buf, 88, W11 * 2 ^ 240)

	return FieldPrime.Carry(Buf, Buf)
end

function FieldPrime.Eqz(ElementA: buffer): boolean
	local Canonical = FieldPrime.Canonicalize(ElementA)
	local C00, C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11 =
		buffer.readf64(Canonical, 0), buffer.readf64(Canonical, 8),
		buffer.readf64(Canonical, 16), buffer.readf64(Canonical, 24),
		buffer.readf64(Canonical, 32), buffer.readf64(Canonical, 40),
		buffer.readf64(Canonical, 48), buffer.readf64(Canonical, 56),
		buffer.readf64(Canonical, 64), buffer.readf64(Canonical, 72),
		buffer.readf64(Canonical, 80), buffer.readf64(Canonical, 88)

	return C00 + C01 + C02 + C03 + C04 + C05 + C06 + C07 + C08 + C09 + C10 + C11 == 0
end

return FieldPrime]]></ProtectedString>
								<string name="ScriptGuid">{5760A7D6-0F01-4298-A5E9-B2C9E3B61A63}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">FieldPrime</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX94BEDC86C81B4EBBBC3B9B3197A2F54A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Field Quadratic (Curve25519 Scalar Field)

	Return type: varies by function
	Example usage:
		local FieldQuadratic = require("FieldQuadratic")

		--------Usage Case 1: Basic scalar arithmetic--------
		local ScalarA = FieldQuadratic.Decode(SomeBytes)
		local ScalarB = FieldQuadratic.Decode(OtherBytes)
		local Sum = FieldQuadratic.Add(ScalarA, ScalarB)
		local Product = FieldQuadratic.Mul(ScalarA, ScalarB)

		--------Usage Case 2: Convert to bits for scalar multiplication--------
		local ScalarBits = FieldQuadratic.Bits(ScalarA)
		local EncodedResult = FieldQuadratic.Encode(Product)
--]=]

--!strict
--!optimize 2
--!native

local MultiPrecision = require("./MultiPrecision")

local CONSTANT_ZERO = MultiPrecision.Num(0)

local OUTPUT_BUFFER = buffer.create(8192)
local RULE_BUFFER = buffer.create(8192)
local DECODE_WIDE_LOW = buffer.create(96)
local DECODE_WIDE_HIGH = buffer.create(96)
local DECODE_BUFFER = buffer.create(96)
local CLAMPED_BUFFER = buffer.create(32)

local FIELD_ORDER_BYTES = buffer.create(32) do
	local Bytes = {
		0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
		0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10
	}
	for Index = 1, 32 do
		buffer.writeu8(FIELD_ORDER_BYTES, Index - 1, Bytes[Index])
	end
end

local FIELD_ORDER = buffer.create(96) do
	local ByteIndex = 0

	for LimbIndex = 0, 9 do
		local Value = buffer.readu8(FIELD_ORDER_BYTES, ByteIndex)
			+ buffer.readu8(FIELD_ORDER_BYTES, ByteIndex + 1) * 256
			+ buffer.readu8(FIELD_ORDER_BYTES, ByteIndex + 2) * 65536

		buffer.writef64(FIELD_ORDER, LimbIndex * 8, Value)
		ByteIndex += 3
	end

	local LastValue = buffer.readu8(FIELD_ORDER_BYTES, 30)
		+ buffer.readu8(FIELD_ORDER_BYTES, 31) * 256
	buffer.writef64(FIELD_ORDER, 10 * 8, LastValue)
end

local MONTGOMERY_T0 = buffer.create(96) do
	local Values = {
		05537307, 01942290, 16765621, 16628356, 10618610,
		07072433, 03735459, 01369940, 15276086, 13038191,
		13409718
	}
	for Index = 1, 11 do
		buffer.writef64(MONTGOMERY_T0, (Index - 1) * 8, Values[Index])
	end
end

local MONTGOMERY_T1 = buffer.create(96) do
	local Values = {
		11711996, 01747860, 08326961, 03814718, 01859974,
		13327461, 16105061, 07590423, 04050668, 08138906,
		00000283
	}
	for Index = 1, 11 do
		buffer.writef64(MONTGOMERY_T1, (Index - 1) * 8, Values[Index])
	end
end

local DIVIDE_8 = buffer.create(96) do
	local Values = {
		5110253, 3039345, 2503500, 11779568, 15416472,
		16766550, 16777215, 16777215, 16777215, 16777215,
		4095
	}
	for Index = 1, 11 do
		buffer.writef64(DIVIDE_8, (Index - 1) * 8, Values[Index])
	end
end

local function Reduce(LargeNumber: buffer): buffer
	local Difference = MultiPrecision.Sub(LargeNumber, FIELD_ORDER)

	if MultiPrecision.Approx(Difference) < 0 then
		return MultiPrecision.Carry(LargeNumber)
	end

	return MultiPrecision.Carry(Difference)
end

local function Demontgomery(MontgomeryScalar: buffer): buffer
	local ReductionLow, ReductionHigh = MultiPrecision.Mul(MultiPrecision.LMul(MontgomeryScalar, MONTGOMERY_T0), FIELD_ORDER)
	local _, ResultHigh = MultiPrecision.DWAdd(MontgomeryScalar, CONSTANT_ZERO, ReductionLow, ReductionHigh)

	return Reduce(ResultHigh)
end

local function RebaseLE(InputBuffer: buffer, InputLength: number, FromBase: number, ToBase: number): (buffer, number)
	local OutputLength = 0
	local Accumulator = 0
	local Multiplier = 1

	for Index = 0, InputLength - 1 do
		Accumulator += buffer.readf64(InputBuffer, Index * 8) * Multiplier
		Multiplier *= FromBase
		while Multiplier >= ToBase do
			local Remainder = Accumulator % ToBase
			Accumulator = (Accumulator - Remainder) / ToBase
			Multiplier /= ToBase
			buffer.writef64(OUTPUT_BUFFER, OutputLength * 8, Remainder)
			OutputLength += 1
		end
	end

	if Multiplier > 0 then
		buffer.writef64(OUTPUT_BUFFER, OutputLength * 8, Accumulator)
		OutputLength += 1
	end

	return OUTPUT_BUFFER, OutputLength
end

local FieldQuadratic = {}

function FieldQuadratic.IsValidScalar(ScalarBytes: buffer): boolean
	local FieldOrder = FIELD_ORDER_BYTES
	local Borrow = 0

	for Index = 0, 31 do
		local ScalarByte = buffer.readu8(ScalarBytes, Index)
		local OrderByte = buffer.readu8(FieldOrder, Index)
		local Diff = ScalarByte - OrderByte - Borrow
		Borrow = 1 - bit32.rshift(Diff + 256, 8)
	end

	return Borrow == 1
end

function FieldQuadratic.Montgomery(RegularScalar: buffer): buffer
	return FieldQuadratic.Mul(RegularScalar, MONTGOMERY_T1)
end

function FieldQuadratic.Add(ScalarA: buffer, ScalarB: buffer): buffer
	return Reduce(MultiPrecision.Add(ScalarA, ScalarB))
end

function FieldQuadratic.Neg(ScalarA: buffer): buffer
	return Reduce(MultiPrecision.Sub(FIELD_ORDER, ScalarA))
end

function FieldQuadratic.Sub(ScalarA: buffer, ScalarB: buffer): buffer
	return FieldQuadratic.Add(ScalarA, FieldQuadratic.Neg(ScalarB))
end

function FieldQuadratic.Mul(ScalarA: buffer, ScalarB: buffer): buffer
	local ProductLow, ProductHigh = MultiPrecision.Mul(ScalarA, ScalarB)
	local ReductionLow, ReductionHigh = MultiPrecision.Mul(MultiPrecision.LMul(ProductLow, MONTGOMERY_T0), FIELD_ORDER)
	local _, ResultHigh = MultiPrecision.DWAdd(ProductLow, ProductHigh, ReductionLow, ReductionHigh)

	return Reduce(ResultHigh)
end

function FieldQuadratic.Encode(MontgomeryScalar: buffer): buffer
	local DemontResult = Demontgomery(MontgomeryScalar)
	local EncodedBuffer = buffer.create(32)
	local ByteIndex = 0
	for LimbIndex = 0, 9 do
		local Value = buffer.readf64(DemontResult, LimbIndex * 8)
		buffer.writeu8(EncodedBuffer, ByteIndex, Value % 256)
		Value = Value // 256
		buffer.writeu8(EncodedBuffer, ByteIndex + 1, Value % 256)
		Value = Value // 256
		buffer.writeu8(EncodedBuffer, ByteIndex + 2, Value % 256)
		ByteIndex += 3
	end

	local LastValue = buffer.readf64(DemontResult, 10 * 8)
	buffer.writeu8(EncodedBuffer, 30, LastValue % 256)
	LastValue = LastValue // 256
	buffer.writeu8(EncodedBuffer, 31, LastValue % 256)

	return EncodedBuffer
end

function FieldQuadratic.Decode(EncodedBuffer: buffer): buffer
	local DecodedBuffer = DECODE_BUFFER
	local ByteIndex = 0

	for LimbIndex = 0, 9 do
		local Value = buffer.readu8(EncodedBuffer, ByteIndex)
			+ buffer.readu8(EncodedBuffer, ByteIndex + 1) * 256
			+ buffer.readu8(EncodedBuffer, ByteIndex + 2) * 65536

		buffer.writef64(DecodedBuffer, LimbIndex * 8, Value)
		ByteIndex += 3
	end

	local LastValue = buffer.readu8(EncodedBuffer, 30)
		+ buffer.readu8(EncodedBuffer, 31) * 256
	buffer.writef64(DecodedBuffer, 10 * 8, LastValue)

	return FieldQuadratic.Montgomery(DecodedBuffer)
end

function FieldQuadratic.DecodeWide(WideBuffer: buffer): buffer
	local LowPart = DECODE_WIDE_LOW
	local HighPart = DECODE_WIDE_HIGH

	for LimbIndex = 0, 10 do
		local ByteIndex = LimbIndex * 3
		local Value = buffer.readu8(WideBuffer, ByteIndex)
			+ buffer.readu8(WideBuffer, ByteIndex + 1) * 256
			+ buffer.readu8(WideBuffer, ByteIndex + 2) * 65536
		buffer.writef64(LowPart, LimbIndex * 8, Value)
	end

	for LimbIndex = 0, 9 do
		local ByteIndex = 33 + LimbIndex * 3
		local Value = buffer.readu8(WideBuffer, ByteIndex)
			+ buffer.readu8(WideBuffer, ByteIndex + 1) * 256
			+ buffer.readu8(WideBuffer, ByteIndex + 2) * 65536
		buffer.writef64(HighPart, LimbIndex * 8, Value)
	end
	buffer.writef64(HighPart, 10 * 8, buffer.readu8(WideBuffer, 63))

	local MontLow = FieldQuadratic.Montgomery(LowPart)
	local MontHigh = FieldQuadratic.Montgomery(HighPart)
	local MontMontHigh = FieldQuadratic.Montgomery(MontHigh)

	return FieldQuadratic.Add(MontLow, MontMontHigh)
end

function FieldQuadratic.DecodeClamped(ClampedBuffer: buffer): buffer
	local ClampedCopy = CLAMPED_BUFFER
	buffer.copy(ClampedCopy, 0, ClampedBuffer, 0, 32)

	local FirstByte = buffer.readu8(ClampedCopy, 0)
	buffer.writeu8(ClampedCopy, 0, bit32.band(FirstByte, 0xF8))

	local LastByte = buffer.readu8(ClampedCopy, 31)
	buffer.writeu8(ClampedCopy, 31, bit32.bor(bit32.band(LastByte, 0x7F), 0x40))

	return FieldQuadratic.Decode(ClampedCopy)
end

function FieldQuadratic.Eighth(MontgomeryScalar: buffer): buffer
	return FieldQuadratic.Mul(MontgomeryScalar, DIVIDE_8)
end

function FieldQuadratic.Bits(MontgomeryScalar: buffer): (buffer, number)
	local DemontResult = Demontgomery(MontgomeryScalar)
	local BitOutput, BitCount = RebaseLE(DemontResult, 11, 2 ^ 24, 2)

	if BitCount > 253 then
		BitCount = 253
	end

	return BitOutput, BitCount
end

function FieldQuadratic.MakeRuleset(ScalarA: buffer, ScalarB: buffer): (buffer, number, buffer, number)
	local DTable = Demontgomery(ScalarA)
	local ETable = Demontgomery(ScalarB)
	local FTable = MultiPrecision.Sub(DTable, ETable)

	local DMod2 = MultiPrecision.Mod2(DTable)
	local EMod2 = MultiPrecision.Mod2(ETable)

	local DMod3 = MultiPrecision.Mod3(DTable)
	local EMod3 = MultiPrecision.Mod3(ETable)

	local EFloat = MultiPrecision.Approx(ETable)
	local FFloat = MultiPrecision.Approx(FTable)

	local Mod3Lut = {[0] = 0, 2, 1}

	local RuleBuffer = RULE_BUFFER
	local RuleCount = 0

	while FFloat ~= 0 do
		local Rule = -1

		if FFloat < 0 then
			Rule = 0
			DTable, ETable = ETable, DTable
			DMod2, EMod2 = EMod2, DMod2
			DMod3, EMod3 = EMod3, DMod3
			EFloat = MultiPrecision.Approx(ETable)
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = -FFloat
		elseif 4 * FFloat < EFloat and DMod3 == Mod3Lut[EMod3] then
			Rule = 1
			DTable, ETable = MultiPrecision.Third(MultiPrecision.Add(DTable, FTable)), MultiPrecision.Third(MultiPrecision.Sub(ETable, FTable)) :: buffer
			DMod2, EMod2 = EMod2, DMod2
			DMod3, EMod3 = MultiPrecision.Mod3(DTable), MultiPrecision.Mod3(ETable)
			EFloat = MultiPrecision.Approx(ETable)
		elseif 4 * FFloat < EFloat and DMod2 == EMod2 and DMod3 == EMod3 then
			Rule = 2
			DTable = MultiPrecision.Half(FTable)
			DMod2 = MultiPrecision.Mod2(DTable)
			DMod3 = Mod3Lut[(DMod3 - EMod3) % 3]
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		elseif FFloat < 3 * EFloat then
			Rule = 3
			DTable = MultiPrecision.CarryWeak(FTable)
			DMod2 = (DMod2 - EMod2) % 2
			DMod3 = (DMod3 - EMod3) % 3
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		elseif DMod2 == EMod2 then
			Rule = 2
			DTable = MultiPrecision.Half(FTable)
			DMod2 = MultiPrecision.Mod2(DTable)
			DMod3 = Mod3Lut[(DMod3 - EMod3) % 3]
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		elseif DMod2 == 0 then
			Rule = 5
			DTable = MultiPrecision.Half(DTable)
			DMod2 = MultiPrecision.Mod2(DTable)
			DMod3 = Mod3Lut[DMod3]
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		elseif DMod3 == 0 then
			Rule = 6
			DTable = MultiPrecision.CarryWeak(MultiPrecision.Sub(MultiPrecision.Third(DTable), ETable))
			DMod2 = (DMod2 - EMod2) % 2
			DMod3 = MultiPrecision.Mod3(DTable)
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		elseif DMod3 == Mod3Lut[EMod3] then
			Rule = 7
			DTable = MultiPrecision.Third(MultiPrecision.Sub(FTable, ETable))
			DMod3 = MultiPrecision.Mod3(DTable)
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		elseif DMod3 == EMod3 then
			Rule = 8
			DTable = MultiPrecision.Third(FTable)
			DMod2 = (DMod2 - EMod2) % 2
			DMod3 = MultiPrecision.Mod3(DTable)
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		else
			Rule = 9
			ETable = MultiPrecision.Half(ETable)
			EMod2 = MultiPrecision.Mod2(ETable)
			EMod3 = Mod3Lut[EMod3]
			EFloat = MultiPrecision.Approx(ETable)
			FTable = MultiPrecision.Sub(DTable, ETable)
			FFloat = MultiPrecision.Approx(FTable)
		end

		buffer.writef64(RuleBuffer, RuleCount * 8, Rule)
		RuleCount += 1
	end

	local FinalBits, FinalBitCount = RebaseLE(DTable, 11, 2 ^ 24, 2)
	while FinalBitCount > 0 and buffer.readf64(FinalBits, (FinalBitCount - 1) * 8) == 0 do
		FinalBitCount -= 1
	end

	return FinalBits, FinalBitCount, RuleBuffer, RuleCount
end

return FieldQuadratic]]></ProtectedString>
								<string name="ScriptGuid">{99C1ECAA-13C3-4CB7-AD40-A43BC0AE68CF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">FieldQuadratic</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFC8998BB6E7B4982BAF24BD4A2C89C3E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Multi-Precision Arithmetic (264-bit integers)

	Return type: varies by function
	Example usage:
		local MultiPrecision = require("MultiPrecision")

		--------Usage Case 1: Basic arithmetic--------
		local NumberA = MultiPrecision.Num(42)
		local NumberB = MultiPrecision.Num(17)
		local Sum = MultiPrecision.Add(NumberA, NumberB)
		local Product = MultiPrecision.Mul(NumberA, NumberB)

		--------Usage Case 2: Carry operations--------
		local LargeSum = MultiPrecision.Add(Sum, Product)
		local Normalized = MultiPrecision.Carry(LargeSum)
--]=]

--!strict
--!optimize 2
--!native

local CARRY = 88
local SIZE = 96

local MultiPrecision = {}

function MultiPrecision.CarryWeak(LargeNumber: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(LargeNumber, 0), buffer.readf64(LargeNumber, 8),
		buffer.readf64(LargeNumber, 16), buffer.readf64(LargeNumber, 24),
		buffer.readf64(LargeNumber, 32), buffer.readf64(LargeNumber, 40),
		buffer.readf64(LargeNumber, 48), buffer.readf64(LargeNumber, 56),
		buffer.readf64(LargeNumber, 64), buffer.readf64(LargeNumber, 72),
		buffer.readf64(LargeNumber, 80)

	local Carry00 = A00 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A01 += Carry00 * 2 ^ -24
	local Carry01 = A01 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A02 += Carry01 * 2 ^ -24
	local Carry02 = A02 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A03 += Carry02 * 2 ^ -24
	local Carry03 = A03 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A04 += Carry03 * 2 ^ -24
	local Carry04 = A04 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A05 += Carry04 * 2 ^ -24
	local Carry05 = A05 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A06 += Carry05 * 2 ^ -24
	local Carry06 = A06 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A07 += Carry06 * 2 ^ -24
	local Carry07 = A07 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A08 += Carry07 * 2 ^ -24
	local Carry08 = A08 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A09 += Carry08 * 2 ^ -24
	local Carry09 = A09 + 3 * 2 ^ 75 - 3 * 2 ^ 75; A10 += Carry09 * 2 ^ -24
	local Carry10 = A10 + 3 * 2 ^ 75 - 3 * 2 ^ 75

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 - Carry00)
	buffer.writef64(Buf, 8, A01 - Carry01)
	buffer.writef64(Buf, 16, A02 - Carry02)
	buffer.writef64(Buf, 24, A03 - Carry03)
	buffer.writef64(Buf, 32, A04 - Carry04)
	buffer.writef64(Buf, 40, A05 - Carry05)
	buffer.writef64(Buf, 48, A06 - Carry06)
	buffer.writef64(Buf, 56, A07 - Carry07)
	buffer.writef64(Buf, 64, A08 - Carry08)
	buffer.writef64(Buf, 72, A09 - Carry09)
	buffer.writef64(Buf, 80, A10 - Carry10)
	buffer.writef64(Buf, 88, Carry10 * 2 ^ -24)

	return Buf
end

function MultiPrecision.Carry(LargeNumber: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(LargeNumber, 0), buffer.readf64(LargeNumber, 8),
		buffer.readf64(LargeNumber, 16), buffer.readf64(LargeNumber, 24),
		buffer.readf64(LargeNumber, 32), buffer.readf64(LargeNumber, 40),
		buffer.readf64(LargeNumber, 48), buffer.readf64(LargeNumber, 56),
		buffer.readf64(LargeNumber, 64), buffer.readf64(LargeNumber, 72),
		buffer.readf64(LargeNumber, 80)

	local Low00 = A00 % 2 ^ 24; A01 += (A00 - Low00) * 2 ^ -24
	local Low01 = A01 % 2 ^ 24; A02 += (A01 - Low01) * 2 ^ -24
	local Low02 = A02 % 2 ^ 24; A03 += (A02 - Low02) * 2 ^ -24
	local Low03 = A03 % 2 ^ 24; A04 += (A03 - Low03) * 2 ^ -24
	local Low04 = A04 % 2 ^ 24; A05 += (A04 - Low04) * 2 ^ -24
	local Low05 = A05 % 2 ^ 24; A06 += (A05 - Low05) * 2 ^ -24
	local Low06 = A06 % 2 ^ 24; A07 += (A06 - Low06) * 2 ^ -24
	local Low07 = A07 % 2 ^ 24; A08 += (A07 - Low07) * 2 ^ -24
	local Low08 = A08 % 2 ^ 24; A09 += (A08 - Low08) * 2 ^ -24
	local Low09 = A09 % 2 ^ 24; A10 += (A09 - Low09) * 2 ^ -24
	local Low10 = A10 % 2 ^ 24

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, Low00)
	buffer.writef64(Buf, 8, Low01)
	buffer.writef64(Buf, 16, Low02)
	buffer.writef64(Buf, 24, Low03)
	buffer.writef64(Buf, 32, Low04)
	buffer.writef64(Buf, 40, Low05)
	buffer.writef64(Buf, 48, Low06)
	buffer.writef64(Buf, 56, Low07)
	buffer.writef64(Buf, 64, Low08)
	buffer.writef64(Buf, 72, Low09)
	buffer.writef64(Buf, 80, Low10)
	buffer.writef64(Buf, 88, (A10 - Low10) * 2 ^ -24)

	return Buf
end

function MultiPrecision.Add(NumberA: buffer, NumberB: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(NumberA, 0), buffer.readf64(NumberA, 8),
		buffer.readf64(NumberA, 16), buffer.readf64(NumberA, 24),
		buffer.readf64(NumberA, 32), buffer.readf64(NumberA, 40),
		buffer.readf64(NumberA, 48), buffer.readf64(NumberA, 56),
		buffer.readf64(NumberA, 64), buffer.readf64(NumberA, 72),
		buffer.readf64(NumberA, 80)

	local B00, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10 =
		buffer.readf64(NumberB, 0), buffer.readf64(NumberB, 8),
		buffer.readf64(NumberB, 16), buffer.readf64(NumberB, 24),
		buffer.readf64(NumberB, 32), buffer.readf64(NumberB, 40),
		buffer.readf64(NumberB, 48), buffer.readf64(NumberB, 56),
		buffer.readf64(NumberB, 64), buffer.readf64(NumberB, 72),
		buffer.readf64(NumberB, 80)

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 + B00)
	buffer.writef64(Buf, 8, A01 + B01)
	buffer.writef64(Buf, 16, A02 + B02)
	buffer.writef64(Buf, 24, A03 + B03)
	buffer.writef64(Buf, 32, A04 + B04)
	buffer.writef64(Buf, 40, A05 + B05)
	buffer.writef64(Buf, 48, A06 + B06)
	buffer.writef64(Buf, 56, A07 + B07)
	buffer.writef64(Buf, 64, A08 + B08)
	buffer.writef64(Buf, 72, A09 + B09)
	buffer.writef64(Buf, 80, A10 + B10)

	return Buf
end

function MultiPrecision.Sub(NumberA: buffer, NumberB: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(NumberA, 0), buffer.readf64(NumberA, 8),
		buffer.readf64(NumberA, 16), buffer.readf64(NumberA, 24),
		buffer.readf64(NumberA, 32), buffer.readf64(NumberA, 40),
		buffer.readf64(NumberA, 48), buffer.readf64(NumberA, 56),
		buffer.readf64(NumberA, 64), buffer.readf64(NumberA, 72),
		buffer.readf64(NumberA, 80)

	local B00, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10 =
		buffer.readf64(NumberB, 0), buffer.readf64(NumberB, 8),
		buffer.readf64(NumberB, 16), buffer.readf64(NumberB, 24),
		buffer.readf64(NumberB, 32), buffer.readf64(NumberB, 40),
		buffer.readf64(NumberB, 48), buffer.readf64(NumberB, 56),
		buffer.readf64(NumberB, 64), buffer.readf64(NumberB, 72),
		buffer.readf64(NumberB, 80)

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 - B00)
	buffer.writef64(Buf, 8, A01 - B01)
	buffer.writef64(Buf, 16, A02 - B02)
	buffer.writef64(Buf, 24, A03 - B03)
	buffer.writef64(Buf, 32, A04 - B04)
	buffer.writef64(Buf, 40, A05 - B05)
	buffer.writef64(Buf, 48, A06 - B06)
	buffer.writef64(Buf, 56, A07 - B07)
	buffer.writef64(Buf, 64, A08 - B08)
	buffer.writef64(Buf, 72, A09 - B09)
	buffer.writef64(Buf, 80, A10 - B10)

	return Buf
end

function MultiPrecision.LMul(NumberA: buffer, NumberB: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(NumberA, 0), buffer.readf64(NumberA, 8),
		buffer.readf64(NumberA, 16), buffer.readf64(NumberA, 24),
		buffer.readf64(NumberA, 32), buffer.readf64(NumberA, 40),
		buffer.readf64(NumberA, 48), buffer.readf64(NumberA, 56),
		buffer.readf64(NumberA, 64), buffer.readf64(NumberA, 72),
		buffer.readf64(NumberA, 80)

	local B00, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10 =
		buffer.readf64(NumberB, 0), buffer.readf64(NumberB, 8),
		buffer.readf64(NumberB, 16), buffer.readf64(NumberB, 24),
		buffer.readf64(NumberB, 32), buffer.readf64(NumberB, 40),
		buffer.readf64(NumberB, 48), buffer.readf64(NumberB, 56),
		buffer.readf64(NumberB, 64), buffer.readf64(NumberB, 72),
		buffer.readf64(NumberB, 80)

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 * B00)
	buffer.writef64(Buf, 8, A01 * B00 + A00 * B01)
	buffer.writef64(Buf, 16, A02 * B00 + A01 * B01 + A00 * B02)
	buffer.writef64(Buf, 24, A03 * B00 + A02 * B01 + A01 * B02 + A00 * B03)
	buffer.writef64(Buf, 32, A04 * B00 + A03 * B01 + A02 * B02 + A01 * B03 + A00 * B04)
	buffer.writef64(Buf, 40, A05 * B00 + A04 * B01 + A03 * B02 + A02 * B03 + A01 * B04 + A00 * B05)
	buffer.writef64(Buf, 48, A06 * B00 + A05 * B01 + A04 * B02 + A03 * B03 + A02 * B04 + A01 * B05 + A00 * B06)
	buffer.writef64(Buf, 56, A07 * B00 + A06 * B01 + A05 * B02 + A04 * B03 + A03 * B04 + A02 * B05 + A01 * B06 + A00 * B07)
	buffer.writef64(Buf, 64, A08 * B00 + A07 * B01 + A06 * B02 + A05 * B03 + A04 * B04 + A03 * B05 + A02 * B06 + A01 * B07 + A00 * B08)
	buffer.writef64(Buf, 72, A09 * B00 + A08 * B01 + A07 * B02 + A06 * B03 + A05 * B04 + A04 * B05 + A03 * B06 + A02 * B07 + A01 * B08 + A00 * B09)
	buffer.writef64(Buf, 80, A10 * B00 + A09 * B01 + A08 * B02 + A07 * B03 + A06 * B04 + A05 * B05 + A04 * B06 + A03 * B07 + A02 * B08 + A01 * B09 + A00 * B10)

	return MultiPrecision.Carry(Buf, Buf)
end

function MultiPrecision.Mul(NumberA: buffer, NumberB: buffer, LowStorage: buffer?, HighStorage: buffer?): (buffer, buffer)
	local LowResult = MultiPrecision.LMul(NumberA, NumberB, LowStorage)
	local Overflow = buffer.readf64(LowResult, CARRY)

	local A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(NumberA, 8), buffer.readf64(NumberA, 16),
		buffer.readf64(NumberA, 24), buffer.readf64(NumberA, 32),
		buffer.readf64(NumberA, 40), buffer.readf64(NumberA, 48),
		buffer.readf64(NumberA, 56), buffer.readf64(NumberA, 64),
		buffer.readf64(NumberA, 72), buffer.readf64(NumberA, 80)

	local B01, B02, B03, B04, B05, B06, B07, B08, B09, B10 =
		buffer.readf64(NumberB, 8), buffer.readf64(NumberB, 16),
		buffer.readf64(NumberB, 24), buffer.readf64(NumberB, 32),
		buffer.readf64(NumberB, 40), buffer.readf64(NumberB, 48),
		buffer.readf64(NumberB, 56), buffer.readf64(NumberB, 64),
		buffer.readf64(NumberB, 72), buffer.readf64(NumberB, 80)

	local Buf = HighStorage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, Overflow + A10 * B01 + A09 * B02 + A08 * B03 + A07 * B04 + A06 * B05 + A05 * B06 + A04 * B07 + A03 * B08 + A02 * B09 + A01 * B10)
	buffer.writef64(Buf, 8, A10 * B02 + A09 * B03 + A08 * B04 + A07 * B05 + A06 * B06 + A05 * B07 + A04 * B08 + A03 * B09 + A02 * B10)
	buffer.writef64(Buf, 16, A10 * B03 + A09 * B04 + A08 * B05 + A07 * B06 + A06 * B07 + A05 * B08 + A04 * B09 + A03 * B10)
	buffer.writef64(Buf, 24, A10 * B04 + A09 * B05 + A08 * B06 + A07 * B07 + A06 * B08 + A05 * B09 + A04 * B10)
	buffer.writef64(Buf, 32, A10 * B05 + A09 * B06 + A08 * B07 + A07 * B08 + A06 * B09 + A05 * B10)
	buffer.writef64(Buf, 40, A10 * B06 + A09 * B07 + A08 * B08 + A07 * B09 + A06 * B10)
	buffer.writef64(Buf, 48, A10 * B07 + A09 * B08 + A08 * B09 + A07 * B10)
	buffer.writef64(Buf, 56, A10 * B08 + A09 * B09 + A08 * B10)
	buffer.writef64(Buf, 64, A10 * B09 + A09 * B10)
	buffer.writef64(Buf, 72, A10 * B10)
	buffer.writef64(Buf, 80, 0)

	return LowResult, MultiPrecision.Carry(Buf, Buf)
end

function MultiPrecision.DWAdd(NumberA0: buffer, NumberA1: buffer, NumberB0: buffer, NumberB1: buffer, LowStorage: buffer?, HighStorage: buffer?): (buffer, buffer, number)
	local LowSum = MultiPrecision.Carry(MultiPrecision.Add(NumberA0, NumberB0, LowStorage), LowStorage)
	local CarryOut = buffer.readf64(LowSum, CARRY)

	local HighSum = MultiPrecision.Add(NumberA1, NumberB1, HighStorage)
	buffer.writef64(HighSum, 0, buffer.readf64(HighSum, 0) + CarryOut)
	local Carried = MultiPrecision.Carry(HighSum, HighSum)

	return LowSum, Carried, buffer.readf64(Carried, CARRY)
end

function MultiPrecision.Half(NumberA: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(NumberA, 0),
		buffer.readf64(NumberA, 8),
		buffer.readf64(NumberA, 16),
		buffer.readf64(NumberA, 24),
		buffer.readf64(NumberA, 32),
		buffer.readf64(NumberA, 40),
		buffer.readf64(NumberA, 48),
		buffer.readf64(NumberA, 56),
		buffer.readf64(NumberA, 64),
		buffer.readf64(NumberA, 72),
		buffer.readf64(NumberA, 80)

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 * 0.5 + A01 * 2 ^ 23)
	buffer.writef64(Buf, 8, A02 * 2 ^ 23)
	buffer.writef64(Buf, 16, A03 * 2 ^ 23)
	buffer.writef64(Buf, 24, A04 * 2 ^ 23)
	buffer.writef64(Buf, 32, A05 * 2 ^ 23)
	buffer.writef64(Buf, 40, A06 * 2 ^ 23)
	buffer.writef64(Buf, 48, A07 * 2 ^ 23)
	buffer.writef64(Buf, 56, A08 * 2 ^ 23)
	buffer.writef64(Buf, 64, A09 * 2 ^ 23)
	buffer.writef64(Buf, 72, A10 * 2 ^ 23)
	buffer.writef64(Buf, 80, 0)

	return MultiPrecision.CarryWeak(Buf, Buf)
end

function MultiPrecision.Third(NumberA: buffer, Storage: buffer?): buffer
	local A00, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10 =
		buffer.readf64(NumberA, 0),
		buffer.readf64(NumberA, 8),
		buffer.readf64(NumberA, 16),
		buffer.readf64(NumberA, 24),
		buffer.readf64(NumberA, 32),
		buffer.readf64(NumberA, 40),
		buffer.readf64(NumberA, 48),
		buffer.readf64(NumberA, 56),
		buffer.readf64(NumberA, 64),
		buffer.readf64(NumberA, 72),
		buffer.readf64(NumberA, 80)

	local Division00 = A00 * 0xaaaaaa
	local Division01 = A01 * 0xaaaaaa + Division00
	local Division02 = A02 * 0xaaaaaa + Division01
	local Division03 = A03 * 0xaaaaaa + Division02
	local Division04 = A04 * 0xaaaaaa + Division03
	local Division05 = A05 * 0xaaaaaa + Division04
	local Division06 = A06 * 0xaaaaaa + Division05
	local Division07 = A07 * 0xaaaaaa + Division06
	local Division08 = A08 * 0xaaaaaa + Division07
	local Division09 = A09 * 0xaaaaaa + Division08
	local Division10 = A10 * 0xaaaaaa + Division09

	local Buf = Storage or buffer.create(SIZE)

	buffer.writef64(Buf, 0, A00 + Division00)
	buffer.writef64(Buf, 8, A01 + Division01)
	buffer.writef64(Buf, 16, A02 + Division02)
	buffer.writef64(Buf, 24, A03 + Division03)
	buffer.writef64(Buf, 32, A04 + Division04)
	buffer.writef64(Buf, 40, A05 + Division05)
	buffer.writef64(Buf, 48, A06 + Division06)
	buffer.writef64(Buf, 56, A07 + Division07)
	buffer.writef64(Buf, 64, A08 + Division08)
	buffer.writef64(Buf, 72, A09 + Division09)
	buffer.writef64(Buf, 80, A10 + Division10)

	return MultiPrecision.CarryWeak(Buf, Buf)
end

function MultiPrecision.Mod2(NumberA: buffer): number
	return buffer.readf64(NumberA, 0) % 2
end

function MultiPrecision.Mod3(NumberA: buffer): number
	return (
		buffer.readf64(NumberA, 0) +
			buffer.readf64(NumberA, 8) +
			buffer.readf64(NumberA, 16) +
			buffer.readf64(NumberA, 24) +
			buffer.readf64(NumberA, 32) +
			buffer.readf64(NumberA, 40) +
			buffer.readf64(NumberA, 48) +
			buffer.readf64(NumberA, 56) +
			buffer.readf64(NumberA, 64) +
			buffer.readf64(NumberA, 72) +
			buffer.readf64(NumberA, 80)
	) % 3
end

function MultiPrecision.Approx(NumberA: buffer): number
	return buffer.readf64(NumberA, 0)
		+ buffer.readf64(NumberA, 8) * 2 ^ 24
		+ buffer.readf64(NumberA, 16) * 2 ^ 48
		+ buffer.readf64(NumberA, 24) * 2 ^ 72
		+ buffer.readf64(NumberA, 32) * 2 ^ 96
		+ buffer.readf64(NumberA, 40) * 2 ^ 120
		+ buffer.readf64(NumberA, 48) * 2 ^ 144
		+ buffer.readf64(NumberA, 56) * 2 ^ 168
		+ buffer.readf64(NumberA, 64) * 2 ^ 192
		+ buffer.readf64(NumberA, 72) * 2 ^ 216
		+ buffer.readf64(NumberA, 80) * 2 ^ 240
end

function MultiPrecision.Cmp(NumberA: buffer, NumberB: buffer): number
	return MultiPrecision.Approx(MultiPrecision.Sub(NumberA, NumberB))
end

function MultiPrecision.Num(RegularNumber: number): buffer
	local Buf = buffer.create(SIZE)
	buffer.writef64(Buf, 0, RegularNumber)

	return Buf
end

return MultiPrecision
]]></ProtectedString>
								<string name="ScriptGuid">{8AB9B8B6-D542-420A-8D84-947F9E9EE13B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">MultiPrecision</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1AA21A939BAB4DE49CAAD08980E25C15">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2
--!native

local K_HI = {
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
	0xca273ece, 0xd186b8c7, 0xeada7dd6, 0xf57d4f7f, 0x06f067aa, 0x0a637dc5, 0x113f9804, 0x1b710b35,
	0x28db77f5, 0x32caab7b, 0x3c9ebe0a, 0x431d67c4, 0x4cc5d4be, 0x597f299c, 0x5fcb6fab, 0x6c44198c,
}

local K_LO = {
	0xd728ae22, 0x23ef65cd, 0xec4d3b2f, 0x8189dbbc, 0xf348b538, 0xb605d019, 0xaf194f9b, 0xda6d8118,
	0xa3030242, 0x45706fbe, 0x4ee4b28c, 0xd5ffb4e2, 0xf27b896f, 0x3b1696b1, 0x25c71235, 0xcf692694,
	0x9ef14ad2, 0x384f25e3, 0x8b8cd5b5, 0x77ac9c65, 0x592b0275, 0x6ea6e483, 0xbd41fbd4, 0x831153b5,
	0xee66dfab, 0x2db43210, 0x98fb213f, 0xbeef0ee4, 0x3da88fc2, 0x930aa725, 0xe003826f, 0x0a0e6e70,
	0x46d22ffc, 0x5c26c926, 0x5ac42aed, 0x9d95b3df, 0x8baf63de, 0x3c77b2a8, 0x47edaee6, 0x1482353b,
	0x4cf10364, 0xbc423001, 0xd0f89791, 0x0654be30, 0xd6ef5218, 0x5565a910, 0x5771202a, 0x32bbd1b8,
	0xb8d2d0c8, 0x5141ab53, 0xdf8eeb99, 0xe19b48a8, 0xc5c95a63, 0xe3418acb, 0x7763e373, 0xd6b2b8a3,
	0x5defb2fc, 0x43172f60, 0xa1f0ab72, 0x1a6439ec, 0x23631e28, 0xde82bde9, 0xb2c67915, 0xe372532b,
	0xea26619c, 0x21c0c207, 0xcde0eb1e, 0xee6ed178, 0x72176fba, 0xa2c898a6, 0xbef90dae, 0x131c471b,
	0x23047d84, 0x40c72493, 0x15c9bebc, 0x9c100d4c, 0xcb3e42b6, 0xfc657e2a, 0x3ad6faec, 0x4a475817,
}

local W_HI = table.create(80) :: {number}
local W_LO = table.create(80) :: {number}
local RESULT_BUFFER = buffer.create(64)

local function PreProcess(Contents: buffer): (buffer, number)
	local ContentLength = buffer.len(Contents)
	local Padding = (128 - ((ContentLength + 17) % 128)) % 128
	local NewLength = ContentLength + 1 + Padding + 16

	local Result = buffer.create(NewLength)
	buffer.copy(Result, 0, Contents)
	buffer.writeu8(Result, ContentLength, 0x80)
	buffer.fill(Result, ContentLength + 1, 0, Padding + 8)

	local BitLength = ContentLength * 8
	local LengthOffset = ContentLength + 1 + Padding + 8

	for Index = 7, 0, -1 do
		buffer.writeu8(Result, LengthOffset + Index, BitLength % 256)
		BitLength = BitLength // 256
	end

	return Result, NewLength
end

local function SHA512(Message: buffer): buffer
	local Blocks, Length = PreProcess(Message)

	local Hi, Lo = W_HI, W_LO
	local KHi, KLo = K_HI, K_LO

	local H1Hi, H2Hi, H3Hi, H4Hi = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a
	local H5Hi, H6Hi, H7Hi, H8Hi = 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	local H1Lo, H2Lo, H3Lo, H4Lo = 0xf3bcc908, 0x84caa73b, 0xfe94f82b, 0x5f1d36f1
	local H5Lo, H6Lo, H7Lo, H8Lo = 0xade682d1, 0x2b3e6c1f, 0xfb41bd6b, 0x137e2179

	for Offset = 0, Length - 1, 128 do
		for T = 1, 16 do
			local ByteOffset = Offset + (T - 1) * 8
			Hi[T] = bit32.byteswap(buffer.readu32(Blocks, ByteOffset))
			Lo[T] = bit32.byteswap(buffer.readu32(Blocks, ByteOffset + 4))
		end

		for T = 17, 80 do
			local P15Hi, P15Lo = Hi[T - 15], Lo[T - 15]
			local P2Hi, P2Lo = Hi[T - 2], Lo[T - 2]

			local S0Lo = bit32.bxor(bit32.rshift(P15Lo, 1) + bit32.lshift(P15Hi, 31), bit32.rshift(P15Lo, 8) + bit32.lshift(P15Hi, 24), bit32.rshift(P15Lo, 7) + bit32.lshift(P15Hi, 25))
			local S1Lo = bit32.bxor(bit32.rshift(P2Lo, 19) + bit32.lshift(P2Hi, 13), bit32.lshift(P2Lo, 3) + bit32.rshift(P2Hi, 29), bit32.rshift(P2Lo, 6) + bit32.lshift(P2Hi, 26))

			local TmpLo = Lo[T - 16] + S0Lo + Lo[T - 7] + S1Lo
			Lo[T] = bit32.bor(TmpLo, 0)
			Hi[T] = bit32.bxor(bit32.rshift(P15Hi, 1) + bit32.lshift(P15Lo, 31), bit32.rshift(P15Hi, 8) + bit32.lshift(P15Lo, 24), bit32.rshift(P15Hi, 7)) +
				bit32.bxor(bit32.rshift(P2Hi, 19) + bit32.lshift(P2Lo, 13), bit32.lshift(P2Hi, 3) + bit32.rshift(P2Lo, 29), bit32.rshift(P2Hi, 6)) +
				Hi[T - 16] + Hi[T - 7] + TmpLo // 0x100000000
		end

		local AHi, ALo = H1Hi, H1Lo
		local BHi, BLo = H2Hi, H2Lo
		local CHi, CLo = H3Hi, H3Lo
		local DHi, DLo = H4Hi, H4Lo
		local EHi, ELo = H5Hi, H5Lo
		local FHi, FLo = H6Hi, H6Lo
		local GHi, GLo = H7Hi, H7Lo
		local HHi, HLo = H8Hi, H8Lo

		for T = 1, 79, 2 do
			local Sigma1Lo = bit32.bxor(bit32.rshift(ELo, 14) + bit32.lshift(EHi, 18), bit32.rshift(ELo, 18) + bit32.lshift(EHi, 14), bit32.lshift(ELo, 23) + bit32.rshift(EHi, 9))
			local Sigma1Hi = bit32.bxor(bit32.rshift(EHi, 14) + bit32.lshift(ELo, 18), bit32.rshift(EHi, 18) + bit32.lshift(ELo, 14), bit32.lshift(EHi, 23) + bit32.rshift(ELo, 9))
			local Sigma0Lo = bit32.bxor(bit32.rshift(ALo, 28) + bit32.lshift(AHi, 4), bit32.lshift(ALo, 30) + bit32.rshift(AHi, 2), bit32.lshift(ALo, 25) + bit32.rshift(AHi, 7))
			local Sigma0Hi = bit32.bxor(bit32.rshift(AHi, 28) + bit32.lshift(ALo, 4), bit32.lshift(AHi, 30) + bit32.rshift(ALo, 2), bit32.lshift(AHi, 25) + bit32.rshift(ALo, 7))
			local ChLo = bit32.band(ELo, FLo) + bit32.band(-1 - ELo, GLo)
			local ChHi = bit32.band(EHi, FHi) + bit32.band(-1 - EHi, GHi)
			local MajLo = bit32.band(CLo, BLo) + bit32.band(ALo, bit32.bxor(CLo, BLo))
			local MajHi = bit32.band(CHi, BHi) + bit32.band(AHi, bit32.bxor(CHi, BHi))

			local T1Lo = HLo + Sigma1Lo + ChLo + KLo[T] + Lo[T]
			local T1Hi = HHi + Sigma1Hi + ChHi + KHi[T] + Hi[T] + T1Lo // 0x100000000
			T1Lo = bit32.bor(T1Lo, 0)

			HHi, HLo = GHi, GLo
			GHi, GLo = FHi, FLo
			FHi, FLo = EHi, ELo

			local ELoNew = DLo + T1Lo
			EHi = DHi + T1Hi + ELoNew // 0x100000000
			ELo = bit32.bor(ELoNew, 0)

			DHi, DLo = CHi, CLo
			CHi, CLo = BHi, BLo
			BHi, BLo = AHi, ALo

			local ALoNew = T1Lo + Sigma0Lo + MajLo
			AHi = T1Hi + Sigma0Hi + MajHi + ALoNew // 0x100000000
			ALo = bit32.bor(ALoNew, 0)

			local T2 = T + 1
			Sigma1Lo = bit32.bxor(bit32.rshift(ELo, 14) + bit32.lshift(EHi, 18), bit32.rshift(ELo, 18) + bit32.lshift(EHi, 14), bit32.lshift(ELo, 23) + bit32.rshift(EHi, 9))
			Sigma1Hi = bit32.bxor(bit32.rshift(EHi, 14) + bit32.lshift(ELo, 18), bit32.rshift(EHi, 18) + bit32.lshift(ELo, 14), bit32.lshift(EHi, 23) + bit32.rshift(ELo, 9))
			Sigma0Lo = bit32.bxor(bit32.rshift(ALo, 28) + bit32.lshift(AHi, 4), bit32.lshift(ALo, 30) + bit32.rshift(AHi, 2), bit32.lshift(ALo, 25) + bit32.rshift(AHi, 7))
			Sigma0Hi = bit32.bxor(bit32.rshift(AHi, 28) + bit32.lshift(ALo, 4), bit32.lshift(AHi, 30) + bit32.rshift(ALo, 2), bit32.lshift(AHi, 25) + bit32.rshift(ALo, 7))
			ChLo = bit32.band(ELo, FLo) + bit32.band(-1 - ELo, GLo)
			ChHi = bit32.band(EHi, FHi) + bit32.band(-1 - EHi, GHi)
			MajLo = bit32.band(CLo, BLo) + bit32.band(ALo, bit32.bxor(CLo, BLo))
			MajHi = bit32.band(CHi, BHi) + bit32.band(AHi, bit32.bxor(CHi, BHi))

			T1Lo = HLo + Sigma1Lo + ChLo + KLo[T2] + Lo[T2]
			T1Hi = HHi + Sigma1Hi + ChHi + KHi[T2] + Hi[T2] + T1Lo // 0x100000000
			T1Lo = bit32.bor(T1Lo, 0)

			HHi, HLo = GHi, GLo
			GHi, GLo = FHi, FLo
			FHi, FLo = EHi, ELo

			ELoNew = DLo + T1Lo
			EHi = DHi + T1Hi + ELoNew // 0x100000000
			ELo = bit32.bor(ELoNew, 0)

			DHi, DLo = CHi, CLo
			CHi, CLo = BHi, BLo
			BHi, BLo = AHi, ALo

			ALoNew = T1Lo + Sigma0Lo + MajLo
			AHi = T1Hi + Sigma0Hi + MajHi + ALoNew // 0x100000000
			ALo = bit32.bor(ALoNew, 0)
		end

		H1Lo = H1Lo + ALo
		H1Hi = bit32.bor(H1Hi + AHi + H1Lo // 0x100000000, 0)
		H1Lo = bit32.bor(H1Lo, 0)

		H2Lo = H2Lo + BLo
		H2Hi = bit32.bor(H2Hi + BHi + H2Lo // 0x100000000, 0)
		H2Lo = bit32.bor(H2Lo, 0)

		H3Lo = H3Lo + CLo
		H3Hi = bit32.bor(H3Hi + CHi + H3Lo // 0x100000000, 0)
		H3Lo = bit32.bor(H3Lo, 0)

		H4Lo = H4Lo + DLo
		H4Hi = bit32.bor(H4Hi + DHi + H4Lo // 0x100000000, 0)
		H4Lo = bit32.bor(H4Lo, 0)

		H5Lo = H5Lo + ELo
		H5Hi = bit32.bor(H5Hi + EHi + H5Lo // 0x100000000, 0)
		H5Lo = bit32.bor(H5Lo, 0)

		H6Lo = H6Lo + FLo
		H6Hi = bit32.bor(H6Hi + FHi + H6Lo // 0x100000000, 0)
		H6Lo = bit32.bor(H6Lo, 0)

		H7Lo = H7Lo + GLo
		H7Hi = bit32.bor(H7Hi + GHi + H7Lo // 0x100000000, 0)
		H7Lo = bit32.bor(H7Lo, 0)

		H8Lo = H8Lo + HLo
		H8Hi = bit32.bor(H8Hi + HHi + H8Lo // 0x100000000, 0)
		H8Lo = bit32.bor(H8Lo, 0)
	end

	buffer.writeu32(RESULT_BUFFER, 0, bit32.byteswap(H1Hi))
	buffer.writeu32(RESULT_BUFFER, 4, bit32.byteswap(H1Lo))
	buffer.writeu32(RESULT_BUFFER, 8, bit32.byteswap(H2Hi))
	buffer.writeu32(RESULT_BUFFER, 12, bit32.byteswap(H2Lo))
	buffer.writeu32(RESULT_BUFFER, 16, bit32.byteswap(H3Hi))
	buffer.writeu32(RESULT_BUFFER, 20, bit32.byteswap(H3Lo))
	buffer.writeu32(RESULT_BUFFER, 24, bit32.byteswap(H4Hi))
	buffer.writeu32(RESULT_BUFFER, 28, bit32.byteswap(H4Lo))
	buffer.writeu32(RESULT_BUFFER, 32, bit32.byteswap(H5Hi))
	buffer.writeu32(RESULT_BUFFER, 36, bit32.byteswap(H5Lo))
	buffer.writeu32(RESULT_BUFFER, 40, bit32.byteswap(H6Hi))
	buffer.writeu32(RESULT_BUFFER, 44, bit32.byteswap(H6Lo))
	buffer.writeu32(RESULT_BUFFER, 48, bit32.byteswap(H7Hi))
	buffer.writeu32(RESULT_BUFFER, 52, bit32.byteswap(H7Lo))
	buffer.writeu32(RESULT_BUFFER, 56, bit32.byteswap(H8Hi))
	buffer.writeu32(RESULT_BUFFER, 60, bit32.byteswap(H8Lo))

	return RESULT_BUFFER
end

return SHA512]]></ProtectedString>
								<string name="ScriptGuid">{A3A81416-4324-41A7-A7B5-3C02D059AF55}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SHA512</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB7929A92774F4272B1AAE4BAFD90E6F4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: X25519 with cofactor clearing

	Return type: varies by function
	Example usage:
		local AlicePrivate = CSPRNG.Ed25519Random()
		local BobPrivate = CSPRNG.Ed25519Random()

		local AliceMasked = X25519.Mask(AlicePrivate)
		local BobMasked = X25519.Mask(BobPrivate)

		local AlicePublic = X25519.PublicKey(AliceMasked)
		local BobPublic = X25519.PublicKey(BobMasked)

		local AliceSharedPrimary, AliceEphemeralSecret = X25519.Exchange(AliceMasked, BobPublic)
		local BobSharedPrimary, BobEphemeralSecret = X25519.Exchange(BobMasked, AlicePublic)

		Expect(ToHex(AliceSharedPrimary)).ToBe(ToHex(BobSharedPrimary))
		Expect(ToHex(AliceEphemeralSecret)).Never.ToBe(ToHex(BobEphemeralSecret))
--]=]

--!strict
--!optimize 2
--!native

local FieldQuadratic = require("./FieldQuadratic")
local FieldPrime = require("./FieldPrime")
local Curve25519 = require("./Curve25519")
local SHA512 = require("./SHA512")
local CSPRNG = require("./CSPRNG")

local COORD_SIZE = 104

local X25519_SECRET_KEY_SIZE = 32
local X25519_PUBLIC_KEY_SIZE = 32
local X25519_MASKED_KEY_SIZE = 64

local X25519_SIGNATURE_SECRET_KEY_SIZE = 32

local Mask = {}

function Mask.Mask(SecretKey: buffer): buffer
	if SecretKey == nil then
		error("SecretKey cannot be nil", 2)
	end

	if typeof(SecretKey) ~= "buffer" then
		error(`SecretKey must be a buffer, got {typeof(SecretKey)}`, 2)
	end

	local SecretKeyLength = buffer.len(SecretKey)
	if SecretKeyLength ~= X25519_SECRET_KEY_SIZE then
		error(`SecretKey must be exactly {X25519_SECRET_KEY_SIZE} bytes long, got {SecretKeyLength} bytes`, 2)
	end

	local RandomMask = CSPRNG.Ed25519Random()
	local ScalarX = FieldQuadratic.DecodeClamped(SecretKey)
	local ScalarR = FieldQuadratic.DecodeClamped(RandomMask)
	local MaskedScalar = FieldQuadratic.Sub(ScalarX, ScalarR)
	local EncodedMaskedScalar = FieldQuadratic.Encode(MaskedScalar)

	local MaskedKey = buffer.create(64)
	buffer.copy(MaskedKey, 0, EncodedMaskedScalar, 0, 32)
	buffer.copy(MaskedKey, 32, RandomMask, 0, 32)

	return MaskedKey
end

function Mask.MaskSignature(SignatureSecretKey: buffer): buffer
	if SignatureSecretKey == nil then
		error("SignatureSecretKey cannot be nil", 2)
	end

	if typeof(SignatureSecretKey) ~= "buffer" then
		error(`SignatureSecretKey must be a buffer, got {typeof(SignatureSecretKey)}`, 2)
	end

	local SignatureKeyLength = buffer.len(SignatureSecretKey)
	if SignatureKeyLength ~= X25519_SIGNATURE_SECRET_KEY_SIZE then
		error(`SignatureSecretKey must be exactly {X25519_SIGNATURE_SECRET_KEY_SIZE} bytes long, got {SignatureKeyLength} bytes`, 2)
	end

	local HashResult = SHA512(SignatureSecretKey)
	local FirstHalf = buffer.create(32)
	buffer.copy(FirstHalf, 0, HashResult, 0, 32)

	return Mask.Mask(FirstHalf)
end

function Mask.Remask(MaskedKey: buffer): buffer
	if MaskedKey == nil then
		error("MaskedKey cannot be nil", 2)
	end

	if typeof(MaskedKey) ~= "buffer" then
		error(`MaskedKey must be a buffer, got {typeof(MaskedKey)}`, 2)
	end

	local MaskedKeyLength = buffer.len(MaskedKey)
	if MaskedKeyLength ~= X25519_MASKED_KEY_SIZE then
		error(`MaskedKey must be exactly {X25519_MASKED_KEY_SIZE} bytes long, got {MaskedKeyLength} bytes`, 2)
	end

	local NewRandomMask = CSPRNG.Ed25519Random()

	local MaskedScalarBytes = buffer.create(32)
	buffer.copy(MaskedScalarBytes, 0, MaskedKey, 0, 32)
	local MaskedScalar = FieldQuadratic.Decode(MaskedScalarBytes)

	local OldMaskBytes = buffer.create(32)
	buffer.copy(OldMaskBytes, 0, MaskedKey, 32, 32)
	local OldMask = FieldQuadratic.DecodeClamped(OldMaskBytes)

	local NewMask = FieldQuadratic.DecodeClamped(NewRandomMask)
	local RemaskedScalar = FieldQuadratic.Add(MaskedScalar, FieldQuadratic.Sub(OldMask, NewMask))
	local EncodedRemaskedScalar = FieldQuadratic.Encode(RemaskedScalar)

	local RemaskedKey = buffer.create(64)
	buffer.copy(RemaskedKey, 0, EncodedRemaskedScalar, 0, 32)
	buffer.copy(RemaskedKey, 32, NewRandomMask, 0, 32)

	return RemaskedKey
end

function Mask.MaskComponent(MaskedKey: buffer): buffer
	if MaskedKey == nil then
		error("MaskedKey cannot be nil", 2)
	end

	if typeof(MaskedKey) ~= "buffer" then
		error(`MaskedKey must be a buffer, got {typeof(MaskedKey)}`, 2)
	end

	local MaskedKeyLength = buffer.len(MaskedKey)
	if MaskedKeyLength ~= X25519_MASKED_KEY_SIZE then
		error(`MaskedKey must be exactly {X25519_MASKED_KEY_SIZE} bytes long, got {MaskedKeyLength} bytes`, 2)
	end

	local MaskKey = buffer.create(32)
	buffer.copy(MaskKey, 0, MaskedKey, 32, 32)

	return MaskKey
end

local function ExchangeOnPoint(MaskedSecretKey: buffer, CurvePoint: buffer): (buffer, buffer)
	local MaskedScalarBytes = buffer.create(32)
	buffer.copy(MaskedScalarBytes, 0, MaskedSecretKey, 0, 32)
	local MaskedScalar = FieldQuadratic.Decode(MaskedScalarBytes)

	local MaskBytes = buffer.create(32)
	buffer.copy(MaskBytes, 0, MaskedSecretKey, 32, 32)
	local MaskScalar = FieldQuadratic.DecodeClamped(MaskBytes)

	local MaskPoint, MaskedPoint, DifferencePoint = Curve25519.Prac(CurvePoint, {FieldQuadratic.MakeRuleset(FieldQuadratic.Eighth(MaskScalar), FieldQuadratic.Eighth(MaskedScalar))})
	if not MaskPoint then
		error("Invalid public key", 2)
	end

	if not DifferencePoint or not MaskedPoint then
		error("Invalid public key", 2)
	end

	local FullScalarPoint = Curve25519.DifferentialAdd(DifferencePoint, MaskPoint, MaskedPoint)

	local PointX = buffer.create(COORD_SIZE)
	buffer.copy(PointX, 0, CurvePoint, 0 * COORD_SIZE, COORD_SIZE)
	local PointZ = buffer.create(COORD_SIZE)
	buffer.copy(PointZ, 0, CurvePoint, 1 * COORD_SIZE, COORD_SIZE)

	local FullPointX = buffer.create(COORD_SIZE)
	buffer.copy(FullPointX, 0, FullScalarPoint, 0 * COORD_SIZE, COORD_SIZE)
	local FullPointZ = buffer.create(COORD_SIZE)
	buffer.copy(FullPointZ, 0, FullScalarPoint, 1 * COORD_SIZE, COORD_SIZE)

	local MaskPointX = buffer.create(COORD_SIZE)
	buffer.copy(MaskPointX, 0, MaskPoint, 0 * COORD_SIZE, COORD_SIZE)
	local MaskPointZ = buffer.create(COORD_SIZE)
	buffer.copy(MaskPointZ, 0, MaskPoint, 1 * COORD_SIZE, COORD_SIZE)

	PointX, PointZ = FieldPrime.Mul(PointX, PointZ), FieldPrime.Square(PointZ) :: buffer
	FullPointX, FullPointZ = FieldPrime.Mul(FullPointX, FullPointZ), FieldPrime.Square(FullPointZ) :: buffer
	MaskPointX, MaskPointZ = FieldPrime.Mul(MaskPointX, MaskPointZ), FieldPrime.Square(MaskPointZ) :: buffer

	local PointXSquared = FieldPrime.Square(PointX)
	local PointZSquared = FieldPrime.Square(PointZ)
	local PointXZ = FieldPrime.Mul(PointX, PointZ)
	local CurveConstantTerm = FieldPrime.KMul(PointXZ, 486662)
	local RightHandSide = FieldPrime.Mul(PointX, FieldPrime.Add(PointXSquared, FieldPrime.Carry(FieldPrime.Add(CurveConstantTerm, PointZSquared))))

	local SquareRoot = FieldPrime.SqrtDiv(FieldPrime.Num(1), FieldPrime.Mul(FieldPrime.Mul(FullPointZ, MaskPointZ), RightHandSide))
	if not SquareRoot then
		error("Invalid public key", 2)
	end

	local CombinedInverse = FieldPrime.Mul(FieldPrime.Square(SquareRoot), RightHandSide)
	local FullPointZInverse = FieldPrime.Mul(CombinedInverse, MaskPointZ)
	local MaskPointZInverse = FieldPrime.Mul(CombinedInverse, FullPointZ)

	return FieldPrime.Encode(FieldPrime.Mul(FullPointX, FullPointZInverse)), FieldPrime.Encode(FieldPrime.Mul(MaskPointX, MaskPointZInverse))
end

function Mask.PublicKey(MaskedKey: buffer): buffer
	if MaskedKey == nil then
		error("MaskedKey cannot be nil", 2)
	end

	if typeof(MaskedKey) ~= "buffer" then
		error(`MaskedKey must be a buffer, got {typeof(MaskedKey)}`, 2)
	end

	local MaskedKeyLength = buffer.len(MaskedKey)
	if MaskedKeyLength ~= X25519_MASKED_KEY_SIZE then
		error(`MaskedKey must be exactly {X25519_MASKED_KEY_SIZE} bytes long, got {MaskedKeyLength} bytes`, 2)
	end

	return (ExchangeOnPoint(MaskedKey, Curve25519.G))
end

function Mask.Exchange(MaskedSecretKey: buffer, TheirPublicKey: buffer): (buffer, buffer)
	if MaskedSecretKey == nil then
		error("MaskedSecretKey cannot be nil", 2)
	end

	if typeof(MaskedSecretKey) ~= "buffer" then
		error(`MaskedSecretKey must be a buffer, got {typeof(MaskedSecretKey)}`, 2)
	end

	local MaskedSecretKeyLength = buffer.len(MaskedSecretKey)
	if MaskedSecretKeyLength ~= X25519_MASKED_KEY_SIZE then
		error(`MaskedSecretKey must be exactly {X25519_MASKED_KEY_SIZE} bytes long, got {MaskedSecretKeyLength} bytes`, 2)
	end

	if TheirPublicKey == nil then
		error("TheirPublicKey cannot be nil", 2)
	end

	if typeof(TheirPublicKey) ~= "buffer" then
		error(`TheirPublicKey must be a buffer, got {typeof(TheirPublicKey)}`, 2)
	end

	local TheirPublicKeyLength = buffer.len(TheirPublicKey)
	if TheirPublicKeyLength ~= X25519_PUBLIC_KEY_SIZE then
		error(`TheirPublicKey must be exactly {X25519_PUBLIC_KEY_SIZE} bytes long, got {TheirPublicKeyLength} bytes`, 2)
	end

	return ExchangeOnPoint(MaskedSecretKey, Curve25519.Decode(TheirPublicKey))
end

return Mask
]]></ProtectedString>
								<string name="ScriptGuid">{49D89F91-6A6E-4719-9703-72714F0BFE8C}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">X25519</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXE0CF37162FEA49C3BD92BEB53DD9C73E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Main Module (Key Encapsulation Mechanism)
	
	The complete ML-KEM post quantum key encapsulation.
	Key generation, encapsulation, and decapsulation operations with
	CCA security using the Fujisaki Okamoto transform.
	
	Example usage:
		local MlKem = require(script.MlKem)
		local CSPRNG = require(script.CSPRNG)
		
		local D = CSPRNG.RandomBytes(32)
		local Z = CSPRNG.RandomBytes(32)
		local PublicKey, SecretKey = MlKem.MLKEM_1024.KeyGen(D, Z)
		
		local Message = CSPRNG.RandomBytes(32)
		local Success, Ciphertext, SharedSecret = MlKem.MLKEM_1024.Encapsulate(Message, PublicKey)
		
		if Success then
			local RecoveredSecret = MlKem.MLKEM_1024.Decapsulate(Ciphertext, SecretKey)
			-- RecoveredSecret should equal SharedSecret
		end
--]=]

--!strict
--!optimize 2
--!native

local Pke = require("@self/PKE")
local Polyvec = require("@self/PolyVec")
local CSPRNG = require("@self/CSPRNG")
local Params = require("@self/Params")
local Utils = require("@self/Utils")
local SHA3 = require("@self/SHA3")

local DECAP_G_INPUT = buffer.create(64)
local DECAP_K_PRIME = buffer.create(32)
local DECAP_R_PRIME = buffer.create(32)
local DECAP_J_OUTPUT = buffer.create(32)

local ENCAP_G_INPUT = buffer.create(64)
local ENCAP_R = buffer.create(32)

local MlKem = {
	CSPRNG = CSPRNG
}

function MlKem.KeyGen(K: number, Eta1: number, D: buffer, Z: buffer): (buffer, buffer)
	if not Params.CheckKeygenParams(K, Eta1) then
		error("Invalid keygen parameters")
	end

	if buffer.len(D) ~= 32 then
		error("D must be 32 bytes")
	end
	
	if buffer.len(Z) ~= 32 then
		error("Z must be 32 bytes")
	end

	local KpkePublicKey, KpkeSecretKey = Pke.KeyGen(K, Eta1, D)
	local PublicKeyHash = SHA3.SHA3_256(KpkePublicKey)

	local SecretKeyLen = Utils.GetKemSecretKeyLen(K)
	local SecretKey = buffer.create(SecretKeyLen)
	
	local Offset = 0

	local KpkeSecretKeyLen = buffer.len(KpkeSecretKey)
	buffer.copy(SecretKey, Offset, KpkeSecretKey, 0, KpkeSecretKeyLen)
	Offset = Offset + KpkeSecretKeyLen

	local KpkePublicKeyLen = buffer.len(KpkePublicKey)
	buffer.copy(SecretKey, Offset, KpkePublicKey, 0, KpkePublicKeyLen)
	Offset += KpkePublicKeyLen

	buffer.copy(SecretKey, Offset, PublicKeyHash, 0, 32)
	Offset += 32

	buffer.copy(SecretKey, Offset, Z, 0, 32)

	return KpkePublicKey, SecretKey
end

function MlKem.Encapsulate(Message: buffer, K: number, Eta1: number, Eta2: number, Du: number, Dv: number, PublicKey: buffer): (buffer?, buffer?)
	if not Params.CheckEncapParams(K, Eta1, Eta2, Du, Dv) then
		error("Invalid encapsulation parameters")
	end
	
	if buffer.len(PublicKey) ~= Utils.GetKemPublicKeyLen(K) then
		error("Invalid public key length")
	end
	
	if buffer.len(Message) ~= 32 then
		error("Message must be 32 bytes")
	end

	local RhoOffset = K * 12 * 32
	local EncodedTPrime = buffer.create(RhoOffset)
	buffer.copy(EncodedTPrime, 0, PublicKey, 0, RhoOffset)

	local TPrime = Polyvec.VecDecode(EncodedTPrime, K, 12)
	local ReEncodedTPrime = Polyvec.VecEncode(TPrime, K, 12)

	local IsValid = Utils.CtMemcmp(EncodedTPrime, ReEncodedTPrime)
	if IsValid ~= 0xFFFFFFFF then
		error("malformed public key encoding")
	end

	local PublicKeyHash = SHA3.SHA3_256(PublicKey)

	local GInput = ENCAP_G_INPUT
	buffer.copy(GInput, 0, Message, 0, 32)
	buffer.copy(GInput, 32, PublicKeyHash, 0, 32)

	local GOutput = SHA3.SHA3_512(GInput)

	local K_bytes = buffer.create(32)
	local R = ENCAP_R
	buffer.copy(K_bytes, 0, GOutput, 0, 32)
	buffer.copy(R, 0, GOutput, 32, 32)

	local Ciphertext = Pke.Encrypt(K, Eta1, Eta2, Du, Dv, PublicKey, Message, R)

	return Ciphertext, K_bytes
end

function MlKem.Decapsulate(Ciphertext: buffer, K: number, Eta1: number, Eta2: number, Du: number, Dv: number, SecretKey: buffer): buffer
	if not Params.CheckDecapParams(K, Eta1, Eta2, Du, Dv) then
		error("Invalid decapsulation parameters")
	end
	if buffer.len(SecretKey) ~= Utils.GetKemSecretKeyLen(K) then
		error("Invalid secret key length")
	end
	
	if buffer.len(Ciphertext) ~= Utils.GetKemCipherTextLen(K, Du, Dv) then
		error("Invalid ciphertext length")
	end

	local KpkeSecretKeyLen = Utils.GetPkeSecretKeyLen(K)
	local KpkePublicKeyLen = Utils.GetPkePublicKeyLen(K)

	local KpkeSecretKey = buffer.create(KpkeSecretKeyLen)
	local KpkePublicKey = buffer.create(KpkePublicKeyLen)
	local H = buffer.create(32)
	local Z = buffer.create(32)

	local Offset = 0
	buffer.copy(KpkeSecretKey, 0, SecretKey, Offset, KpkeSecretKeyLen)
	Offset += KpkeSecretKeyLen

	buffer.copy(KpkePublicKey, 0, SecretKey, Offset, KpkePublicKeyLen)
	Offset += KpkePublicKeyLen

	buffer.copy(H, 0, SecretKey, Offset, 32)
	Offset += 32

	buffer.copy(Z, 0, SecretKey, Offset, 32)

	local MPrime = Pke.Decrypt(K, Du, Dv, KpkeSecretKey, Ciphertext)

	local GInput = DECAP_G_INPUT
	buffer.copy(GInput, 0, MPrime, 0, 32)
	buffer.copy(GInput, 32, H, 0, 32)

	local GOutput = SHA3.SHA3_512(GInput)

	local KPrime = DECAP_K_PRIME
	local RPrime = DECAP_R_PRIME
	buffer.copy(KPrime, 0, GOutput, 0, 32)
	buffer.copy(RPrime, 0, GOutput, 32, 32)

	local JInput = buffer.create(32 + buffer.len(Ciphertext))
	buffer.copy(JInput, 0, Z, 0, 32)
	buffer.copy(JInput, 32, Ciphertext, 0, buffer.len(Ciphertext))

	local JOutputBuffer = SHA3.SHAKE256(JInput, 32)
	local JOutput = DECAP_J_OUTPUT
	buffer.copy(JOutput, 0, JOutputBuffer, 0, 32)

	local CiphertextPrime = Pke.Encrypt(K, Eta1, Eta2, Du, Dv, KpkePublicKey, MPrime, RPrime)
	local IsValid = Utils.CtMemcmp(Ciphertext, CiphertextPrime)

	local SharedSecret = buffer.create(32)
	Utils.CtCondMemcpy(IsValid, SharedSecret, KPrime, JOutput)

	return SharedSecret
end

function MlKem.SecretsEqual(Secret1: buffer, Secret2: buffer): boolean
	if buffer.len(Secret1) ~= 32 or buffer.len(Secret2) ~= 32 then
		return false
	end

	return Utils.CtMemcmp(Secret1, Secret2) == 0xFFFFFFFF
end

function MlKem.ValidateDecapsulationKey(K: number, SecretKey: buffer): boolean
	local KpkeSecretKeyLen = Utils.GetPkeSecretKeyLen(K)
	local KpkePublicKeyLen = Utils.GetPkePublicKeyLen(K)

	local EkOffset = KpkeSecretKeyLen
	local HOffset = KpkeSecretKeyLen + KpkePublicKeyLen

	local Ek = buffer.create(KpkePublicKeyLen)
	local StoredH = buffer.create(32)
	buffer.copy(Ek, 0, SecretKey, EkOffset, KpkePublicKeyLen)
	buffer.copy(StoredH, 0, SecretKey, HOffset, 32)

	local ComputedH = SHA3.SHA3_256(Ek)
	return Utils.CtMemcmp(StoredH, ComputedH) == 0xFFFFFFFF
end

MlKem.MLKEM_512 = {
	KeyGen = function(D: buffer, Z: buffer): (buffer, buffer)
		return MlKem.KeyGen(2, 3, D, Z)
	end,

	Encapsulate = function(Message: buffer, PublicKey: buffer): (buffer?, buffer?)
		return MlKem.Encapsulate(Message, 2, 3, 2, 10, 4, PublicKey)
	end,

	Decapsulate = function(Ciphertext: buffer, SecretKey: buffer): buffer
		return MlKem.Decapsulate(Ciphertext, 2, 3, 2, 10, 4, SecretKey)
	end,

	GenerateKeys = function(): (buffer, buffer)
		local D = CSPRNG.RandomBytes(32)
		local Z = CSPRNG.RandomBytes(32)

		return MlKem.MLKEM_512.KeyGen(D, Z)
	end,
	
	ValidateDecapsulationKey = function(SecretKey: buffer): boolean
		return MlKem.ValidateDecapsulationKey(2, SecretKey)
	end
}

MlKem.MLKEM_768 = {
	KeyGen = function(D: buffer, Z: buffer): (buffer, buffer)
		return MlKem.KeyGen(3, 2, D, Z)
	end,

	Encapsulate = function(Message: buffer, PublicKey: buffer): (buffer?, buffer?)
		return MlKem.Encapsulate(Message, 3, 2, 2, 10, 4, PublicKey)
	end,

	Decapsulate = function(Ciphertext: buffer, SecretKey: buffer): buffer
		return MlKem.Decapsulate(Ciphertext, 3, 2, 2, 10, 4, SecretKey)
	end,

	GenerateKeys = function(): (buffer, buffer)
		local D = CSPRNG.RandomBytes(32)
		local Z = CSPRNG.RandomBytes(32)

		return MlKem.MLKEM_768.KeyGen(D, Z)
	end,
	
	ValidateDecapsulationKey = function(SecretKey: buffer): boolean
		return MlKem.ValidateDecapsulationKey(3, SecretKey)
	end
}

MlKem.MLKEM_1024 = {
	KeyGen = function(D: buffer, Z: buffer): (buffer, buffer)
		return MlKem.KeyGen(4, 2, D, Z)
	end,

	Encapsulate = function(Message: buffer, PublicKey: buffer): (buffer?, buffer?)
		return MlKem.Encapsulate(Message, 4, 2, 2, 11, 5, PublicKey)
	end,

	Decapsulate = function(Ciphertext: buffer, SecretKey: buffer): buffer
		return MlKem.Decapsulate(Ciphertext, 4, 2, 2, 11, 5, SecretKey)
	end,

	GenerateKeys = function(): (buffer, buffer)
		local D = CSPRNG.RandomBytes(32)
		local Z = CSPRNG.RandomBytes(32)

		return MlKem.MLKEM_1024.KeyGen(D, Z)
	end,
	
	ValidateDecapsulationKey = function(SecretKey: buffer): boolean
		return MlKem.ValidateDecapsulationKey(4, SecretKey)
	end
}

return MlKem]]></ProtectedString>
							<string name="ScriptGuid">{1028F03B-7B73-4C36-9EEC-9E1DC59F79F7}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MlKEM</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX389660CE6A1844B58ABDA6DAA4030073">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Cryptographically Secure RNG
	
	Usage:
		local RandomFloat = CSPRNG.Random()
		local RandomInt = CSPRNG.RandomInt(1, 100)
		local RandomNumber = CSPRNG.RandomNumber(0.5, 10.5)
		local RandomBytes = CSPRNG.RandomBytes(32)
		local RandomHex = CSPRNG.RandomHex(16)
		local FastString = CSPRNG.RandomString(16, false)
		local FastBuffer = CSPRNG.RandomString(32, true)
		
		local Ed25519Clamped = CSPRNG.Ed25519ClampedBytes(SomeBuffer)
		local Ed25519Random = CSPRNG.Ed25519Random()
		
		CSPRNG.AddEntropyProvider(function)
		CSPRNG.RemoveEntropyProvider(function)
		CSPRNG.Reseed()
		
		CSPRNG.BytesLeft
--]=]

--!strict
--!optimize 2
--!native

local Conversions = require("@self/Conversions")
local ChaCha20 = require("@self/ChaCha20")
local Blake3 = require("@self/Blake3")

export type EntropyProvider = (BytesLeft: number) -> buffer?

type CSPRNGModule = {
	BlockExpansion: boolean,

	SizeTarget: number,
	RekeyAfter: number,

	Key: buffer,
	Nonce: buffer,
	Buffer: buffer,

	Counter: number,
	BufferPosition: number,
	BufferSize: number,
	BytesLeft: number,

	EntropyProviders: { EntropyProvider },

	Reseed: (CustomEntropy: buffer?) -> (),
	AddEntropyProvider: (ProviderFunction: EntropyProvider) -> (),
	RemoveEntropyProvider: (ProviderFunction: EntropyProvider) -> (),

	Random: () -> number,
	RandomInt: (Min: number, Max: number?) -> number,
	RandomNumber: (Min: number, Max: number?) -> number,
	RandomBytes: (Count: number) -> buffer,
	RandomString: (Length: number, AsBuffer: boolean?) -> string | buffer,
	RandomHex: (Length: number) -> string,
	Ed25519ClampedBytes: (Input: buffer) -> buffer,
	Ed25519Random: () -> buffer,
}

local BLOCK_SIZE = 64
local KEY_SIZE = 32
local NONCE_SIZE = 12

local CSPRNG: CSPRNGModule = {
	BlockExpansion = true,
	SizeTarget = 2048,
	RekeyAfter = 1024,

	Key = buffer.create(0),
	Nonce = buffer.create(0),
	Buffer = buffer.create(0),

	Counter = 0,
	BufferPosition = 0,
	BufferSize = 0,
	BytesLeft = 0,

	EntropyProviders = {}
} :: CSPRNGModule

local INPUT_BUFFER = buffer.create(BLOCK_SIZE)
local REKEY_THRESHOLD = math.max(math.floor(CSPRNG.RekeyAfter), 2)
local SIZE_TARGET_CLAMPED = math.clamp(math.floor(CSPRNG.SizeTarget), 64, 4294967295)

local function Reset()
	CSPRNG.Key = buffer.create(0)
	CSPRNG.Nonce = buffer.create(0)
	CSPRNG.Buffer = buffer.create(0)

	CSPRNG.Counter = 0
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = 0
end

local function GatherEntropy(CustomEntropy: buffer?): number
	local EntropyBuffers = buffer.create(1024)
	local Offset = 0

	local function WriteToBuffer(Source: buffer)
		local Size = buffer.len(Source)
		buffer.copy(EntropyBuffers, Offset, Source, 0, Size)
		Offset += Size
	end

	local CurrentTime = 1.234
	if tick then
		CurrentTime = tick()
		local TimeBuffer = buffer.create(8)
		buffer.writef64(TimeBuffer, 0, CurrentTime)
		WriteToBuffer(TimeBuffer)
	end

	local ClockTime = os.clock()
	local ClockBuffer = buffer.create(8)
	buffer.writef64(ClockBuffer, 0, ClockTime)
	WriteToBuffer(ClockBuffer)

	local UnixTime = os.time()
	local UnixBuffer = buffer.create(8)
	buffer.writeu32(UnixBuffer, 0, UnixTime % 0x100000000)
	buffer.writeu32(UnixBuffer, 4, math.floor(UnixTime / 0x100000000))
	WriteToBuffer(UnixBuffer)

	local DateTimeMillis = 5.678
	if DateTime then
		DateTimeMillis = DateTime.now().UnixTimestampMillis
		local DateTimeBuffer = buffer.create(8)
		buffer.writef64(DateTimeBuffer, 0, DateTimeMillis)
		WriteToBuffer(DateTimeBuffer)

		local DateTimePrecisionBuffer = buffer.create(16)
		buffer.writef32(DateTimePrecisionBuffer, 0, DateTimeMillis / 1000)
		buffer.writef32(DateTimePrecisionBuffer, 4, (DateTimeMillis % 1000) / 100)
		buffer.writef32(DateTimePrecisionBuffer, 8, DateTimeMillis / 86400000)
		buffer.writef32(DateTimePrecisionBuffer, 12, (DateTimeMillis * 0.001) % 1)
		WriteToBuffer(DateTimePrecisionBuffer)
	else
		WriteToBuffer(buffer.create(24))
	end

	local FracTimeBuffer = buffer.create(16)
	buffer.writef32(FracTimeBuffer, 0, ClockTime / 100)
	buffer.writef32(FracTimeBuffer, 4, CurrentTime / 1000)
	buffer.writef32(FracTimeBuffer, 8, (ClockTime * 12345.6789) % 1)
	buffer.writef32(FracTimeBuffer, 12, (CurrentTime * 98765.4321) % 1)
	WriteToBuffer(FracTimeBuffer)

	local NoiseBuffer = buffer.create(32)
	for Index = 0, 7 do
		local Noise1 = math.noise(ClockTime + Index, UnixTime + Index, ClockTime + UnixTime + Index)
		local Noise2 = math.noise(CurrentTime + Index * 0.1, DateTimeMillis * 0.0001 + Index, ClockTime * 1.5 + Index)
		local Noise3 = math.noise(UnixTime * 0.01 + Index, ClockTime + DateTimeMillis * 0.001, CurrentTime + Index * 2)
		local Noise4 = math.noise(DateTimeMillis * 0.00001 + Index, UnixTime + ClockTime + Index, CurrentTime * 0.1 + Index)

		buffer.writef32(NoiseBuffer, Index * 4, Noise1 + Noise2 + Noise3 + Noise4)
	end
	WriteToBuffer(NoiseBuffer)

	local BenchmarkTimings = buffer.create(32)
	for Index = 0, 7 do
		local StartTime = os.clock()
		local Sum = 0

		local Iterations = 50 + (Index * 25)
		for Iteration = 1, Iterations do
			Sum += Iteration * Iteration + math.sin(Iteration / 10) * math.cos(Iteration / 7)
		end

		local EndTime = os.clock()
		local TimingDelta = EndTime - StartTime
		buffer.writef32(BenchmarkTimings, Index * 4, TimingDelta * 1000000)
	end
	WriteToBuffer(BenchmarkTimings)

	local AllocTimings = buffer.create(24)
	for Index = 0, 5 do
		local AllocStart = os.clock()

		for AllocIndex = 1, 20 do
			local _TempBuf = buffer.create(64 + AllocIndex)
		end

		local AllocEnd = os.clock()
		buffer.writef32(AllocTimings, Index * 4, (AllocEnd - AllocStart) * 10000000)
	end
	WriteToBuffer(AllocTimings)

	local MicroTime = math.floor(CurrentTime * 1000000)
	local MicroTimeBuffer = buffer.create(8)
	buffer.writeu32(MicroTimeBuffer, 0, MicroTime % 0x100000000)
	buffer.writeu32(MicroTimeBuffer, 4, math.floor(MicroTime / 0x100000000))
	WriteToBuffer(MicroTimeBuffer)

	if game then
		if game.JobId and #game.JobId > 0 then
			local JobIdBuffer = buffer.fromstring(game.JobId)
			WriteToBuffer(JobIdBuffer)
		end

		if game.PlaceId then
			local PlaceIdBuffer = buffer.create(8)
			buffer.writeu32(PlaceIdBuffer, 0, game.PlaceId % 0x100000000)
			buffer.writeu32(PlaceIdBuffer, 4, math.floor(game.PlaceId / 0x100000000))
			WriteToBuffer(PlaceIdBuffer)
		end

		if workspace and workspace.DistributedGameTime then
			local DistTimeBuffer = buffer.create(8)
			buffer.writef64(DistTimeBuffer, 0, workspace.DistributedGameTime)
			WriteToBuffer(DistTimeBuffer)

			local DistMicroTime = math.floor(workspace.DistributedGameTime * 1000000)
			local DistMicroBuffer = buffer.create(8)
			buffer.writeu32(DistMicroBuffer, 0, DistMicroTime % 0x100000000)
			buffer.writeu32(DistMicroBuffer, 4, math.floor(DistMicroTime / 0x100000000))
			WriteToBuffer(DistMicroBuffer)
		end
	end

	local AddressEntropy = buffer.create(128)
	for Index = 0, 7 do
		local TempTable = {}
		local TempFunc = function() end
		local TempBuffer = buffer.create(0)
		local TempUserdata = newproxy()

		local TableAddr = string.gsub(tostring(TempTable), "table: ", "")
		local FuncAddr = string.gsub(tostring(TempFunc), "function: ", "")
		local BufferAddr = string.gsub(tostring(TempBuffer), "buffer: ", "")
		local UserdataAddr = string.gsub(tostring(TempUserdata), "userdata: ", "")

		local TableHash = 0
		local ThreadHash = 0
		local FuncHash = 0
		local BufferHash = 0
		local UserdataHash = 0

		for AddrIndex = 1, #TableAddr do
			TableHash = bit32.bxor(TableHash, string.byte(TableAddr, AddrIndex)) * 31
		end

		if coroutine then
			local ThreadAddr = string.gsub(tostring(coroutine.create(function() end)), "thread: ", "")
			for AddrIndex = 1, #ThreadAddr do
				ThreadHash = bit32.bxor(ThreadHash, string.byte(ThreadAddr, AddrIndex)) * 31
			end
		end

		for AddrIndex = 1, #FuncAddr do
			FuncHash = bit32.bxor(FuncHash, string.byte(FuncAddr, AddrIndex)) * 37
		end
		for AddrIndex = 1, #BufferAddr do
			BufferHash = bit32.bxor(BufferHash, string.byte(BufferAddr, AddrIndex)) * 41
		end
		for AddrIndex = 1, #UserdataAddr do
			UserdataHash = bit32.bxor(UserdataHash, string.byte(UserdataAddr, AddrIndex)) * 43
		end

		buffer.writeu32(AddressEntropy, Index * 16, TableHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 4, ThreadHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 8, FuncHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 12, bit32.bxor(BufferHash, UserdataHash))
	end
	WriteToBuffer(AddressEntropy)

	local function AddExtraEntropy(Entropy: buffer?, Warn: boolean, Provider: string?)
		if not Entropy then
			return
		end

		local BytesLeft = 1024 - Offset

		if BytesLeft > 0 then
			local Extra = buffer.len(Entropy) - BytesLeft
			local Truncated = math.min(BytesLeft, buffer.len(Entropy))

			if Extra > 0 and Warn and Provider then
				warn(`CSPRNG: {Provider} returned {Extra} bytes more than available and was truncated to {Truncated} bytes`)
			end

			buffer.copy(EntropyBuffers, Offset, Entropy, 0, Truncated)
		end
	end

	for Index, Provider in CSPRNG.EntropyProviders do
		local BytesLeft = 1024 - Offset
		if BytesLeft > 0 then
			local Success: boolean, ExtraEntropy: buffer? = pcall(Provider, BytesLeft)
			if not Success then
				warn(`CSPRNG Provider errored with {ExtraEntropy}`)
			end

			AddExtraEntropy(ExtraEntropy, true, `Entropy Provider #{Index}`)
		end
	end

	if CustomEntropy then
		AddExtraEntropy(CustomEntropy, false)
	end

	local KeyMaterial = Blake3(EntropyBuffers, KEY_SIZE + NONCE_SIZE)

	CSPRNG.Key = buffer.create(KEY_SIZE)
	buffer.copy(CSPRNG.Key, 0, KeyMaterial, 0, KEY_SIZE)

	CSPRNG.Nonce = buffer.create(NONCE_SIZE)
	buffer.copy(CSPRNG.Nonce, 0, KeyMaterial, KEY_SIZE, NONCE_SIZE)

	return buffer.len(EntropyBuffers) - Offset
end

local function GenerateBlock()
	buffer.fill(INPUT_BUFFER, 0, 0, BLOCK_SIZE)
	local ChaChaOutput = ChaCha20(INPUT_BUFFER, CSPRNG.Key, CSPRNG.Nonce, CSPRNG.Counter, 20)

	CSPRNG.Buffer = if CSPRNG.BlockExpansion then Blake3(ChaChaOutput, SIZE_TARGET_CLAMPED) else ChaChaOutput
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = buffer.len(CSPRNG.Buffer)
	CSPRNG.Counter += 1

	if CSPRNG.Counter % REKEY_THRESHOLD == 0 then
		GatherEntropy() 
		CSPRNG.Counter = 0
	end
end

local function GetBytes(Count: number): buffer
	local Result = buffer.create(Count)
	local ResultPosition = 0

	while ResultPosition < Count do
		if CSPRNG.BufferPosition >= CSPRNG.BufferSize then
			GenerateBlock()
		end

		local BytesNeeded = Count - ResultPosition
		local BytesAvailable = CSPRNG.BufferSize - CSPRNG.BufferPosition
		local BytesToCopy = math.min(BytesNeeded, BytesAvailable)

		buffer.copy(Result, ResultPosition, CSPRNG.Buffer, CSPRNG.BufferPosition, BytesToCopy)
		ResultPosition += BytesToCopy
		CSPRNG.BufferPosition += BytesToCopy
	end

	return Result
end

local function GetFloat(): number
	if CSPRNG.BufferPosition + 8 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value1 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	local Value2 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition + 4)
	CSPRNG.BufferPosition += 8

	local High = bit32.rshift(Value1, 5)
	local Low = bit32.rshift(Value2, 6)

	return (High * 67108864.0 + Low) / 9007199254740992.0
end

local function GetIntRange(Min: number, Max: number): number
	local Range = Max - Min + 1
	local MaxUInt32 = 0xFFFFFFFF
	local Limit = MaxUInt32 - (MaxUInt32 % Range)

	if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	CSPRNG.BufferPosition += 4

	if bit32.band(Range, Range - 1) == 0 then
		return Min + bit32.band(Value, Range - 1)
	else
		while Value > Limit do
			if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
				GenerateBlock()
			end
			Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
			CSPRNG.BufferPosition += 4
		end

		return Min + (Value % Range)
	end
end

local function GetNumberRange(Min: number, Max: number): number
	if Min > Max then
		Min, Max = Max, Min
	end

	local Range = Max - Min
	if Range <= 0 then
		return Min
	end

	return Min + (GetFloat() * Range)
end

local function GetRandomString(Length: number, AsBuffer: boolean?): string | buffer
	local Characters = buffer.create(Length)

	for Index = 0, Length - 1 do
		buffer.writeu8(Characters, Index, GetIntRange(36, 122))
	end

	return if AsBuffer
		then Characters
		else buffer.tostring(Characters)
end

local function GetEd25519RandomBytes(): buffer
	local Output = buffer.create(32)

	for Index = 0, 31 do
		buffer.writeu8(Output, Index, GetIntRange(0, 255))
	end

	return Output
end

local function GetEd25519ClampedBytes(Input: buffer): buffer
	local Output = buffer.create(32)
	buffer.copy(Output, 0, Input, 0, 32)

	local FirstByte = buffer.readu8(Output, 0)
	FirstByte = bit32.band(FirstByte, 0xF8)
	buffer.writeu8(Output, 0, FirstByte)

	local LastByte = buffer.readu8(Output, 31)
	LastByte = bit32.band(LastByte, 0x7F)
	LastByte = bit32.bor(LastByte, 0x40)
	buffer.writeu8(Output, 31, LastByte)

	local HasVariation = false
	local FirstMiddleByte = buffer.readu8(Output, 1)
	for Index = 2, 30 do
		if buffer.readu8(Output, Index) ~= FirstMiddleByte then
			HasVariation = true
			break
		end
	end

	if not HasVariation then
		buffer.writeu8(Output, 15, bit32.bxor(FirstMiddleByte, 0x55))
	end

	return Output
end

local function GetHexString(Length: number): string
	local BytesNeeded = Length / 2
	local Bytes = GetBytes(BytesNeeded)
	local Hex = Conversions.ToHex(Bytes)

	return Hex
end

function CSPRNG.AddEntropyProvider(ProviderFunction: EntropyProvider)
	table.insert(CSPRNG.EntropyProviders, ProviderFunction)
end

function CSPRNG.RemoveEntropyProvider(ProviderFunction: EntropyProvider)
	for Index = #CSPRNG.EntropyProviders, 1, -1 do
		if CSPRNG.EntropyProviders[Index] == ProviderFunction then
			table.remove(CSPRNG.EntropyProviders, Index)
			break
		end
	end
end

function CSPRNG.Random(): number
	return GetFloat()
end

function CSPRNG.RandomInt(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) can't be less than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 1
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetIntRange(ActualMin, ActualMax)
end

function CSPRNG.RandomNumber(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) must be bigger than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 0
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetNumberRange(ActualMin, ActualMax)
end

function CSPRNG.RandomBytes(Count: number): buffer
	if type(Count) ~= "number" then
		error(`Count must be a number, got {typeof(Count)}`, 2)
	end

	if Count <= 0 then
		error(`Count must be bigger than 0, got {Count}`, 2)
	end

	if Count % 1 ~= 0 then
		error("Count must be an integer", 2)
	end

	return GetBytes(Count)
end

function CSPRNG.RandomString(Length: number, AsBuffer: boolean?): string | buffer
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if AsBuffer ~= nil and type(AsBuffer) ~= "boolean" then
		error(`AsBuffer must be a boolean or nil, got {typeof(AsBuffer)}`, 2)
	end

	return GetRandomString(Length, AsBuffer)
end

function CSPRNG.RandomHex(Length: number): string
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`, 2)
	end

	return GetHexString(Length)
end

function CSPRNG.Ed25519ClampedBytes(Input: buffer): buffer
	if type(Input) ~= "buffer" then
		error(`Input must be a buffer, got {typeof(Input)}`, 2)
	end

	return GetEd25519ClampedBytes(Input)
end

function CSPRNG.Ed25519Random(): buffer
	return GetEd25519ClampedBytes(GetEd25519RandomBytes())
end

function CSPRNG.Reseed(CustomEntropy: buffer?)
	if CustomEntropy ~= nil and type(CustomEntropy) ~= "buffer" then
		error(`CustomEntropy must be a buffer or nil, got {typeof(CustomEntropy)}`, 2)
	end

	Reset()
	GatherEntropy(CustomEntropy)
end

CSPRNG.BytesLeft = GatherEntropy()
GenerateBlock()

return CSPRNG]]></ProtectedString>
								<string name="ScriptGuid">{FFE53FC2-834B-4E18-A507-63C13334D3E0}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CSPRNG</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXE19810304B044BE583ACCCF7EC36F69B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Blake3
	
	Sizes:
		Key: 32 bytes
		Output: variable
	
	Return type: string (hex)
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		
		--------Standard Hash--------
		local Hash = Blake3.Digest(Message, 32)
		
		--------Keyed Hash--------
		local KeyedHash = Blake3.DigestKeyed(Key, Message, 32)
		
		--------Key Derivation--------
		local Context = buffer.fromstring("my context")
		local KeyDeriver = Blake3.DeriveKey(Context)
		local DerivedKey = KeyDeriver(Message, 32)
--]=]

--!strict
--!optimize 2
--!native

local BLOCK_SIZE = 64
local CV_SIZE = 32
local EXTENDED_CV_SIZE = 64
local MAX_STACK_DEPTH = 64
local STACK_BUFFER_SIZE = MAX_STACK_DEPTH * CV_SIZE

local CHUNK_START = 0x01
local CHUNK_END = 0x02
local PARENT_FLAG = 0x04
local ROOT_FLAG = 0x08

local INITIAL_VECTORS = buffer.create(CV_SIZE) do
	local IV = {
		0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
		0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
	}
	for Index, Value in ipairs(IV) do
		buffer.writeu32(INITIAL_VECTORS, (Index - 1) * 4, Value)
	end
end

local function Compress(Hash: buffer, MessageBlock: buffer, Counter: number, V14: number, V15: number, IsFull: boolean?): buffer
	local Hash00 = buffer.readu32(Hash, 0)
	local Hash01 = buffer.readu32(Hash, 4)
	local Hash02 = buffer.readu32(Hash, 8)
	local Hash03 = buffer.readu32(Hash, 12)
	local Hash04 = buffer.readu32(Hash, 16)
	local Hash05 = buffer.readu32(Hash, 20)
	local Hash06 = buffer.readu32(Hash, 24)
	local Hash07 = buffer.readu32(Hash, 28)

	local V00, V01, V02, V03 = Hash00, Hash01, Hash02, Hash03
	local V04, V05, V06, V07 = Hash04, Hash05, Hash06, Hash07
	local V08, V09, V10, V11 = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a

	local V12 = Counter % (2 ^ 32)
	local V13 = (Counter - V12) * (2 ^ -32)

	local M00 = buffer.readu32(MessageBlock, 0)
	local M01 = buffer.readu32(MessageBlock, 4)
	local M02 = buffer.readu32(MessageBlock, 8)
	local M03 = buffer.readu32(MessageBlock, 12)
	local M04 = buffer.readu32(MessageBlock, 16)
	local M05 = buffer.readu32(MessageBlock, 20)
	local M06 = buffer.readu32(MessageBlock, 24)
	local M07 = buffer.readu32(MessageBlock, 28)
	local M08 = buffer.readu32(MessageBlock, 32)
	local M09 = buffer.readu32(MessageBlock, 36)
	local M10 = buffer.readu32(MessageBlock, 40)
	local M11 = buffer.readu32(MessageBlock, 44)
	local M12 = buffer.readu32(MessageBlock, 48)
	local M13 = buffer.readu32(MessageBlock, 52)
	local M14 = buffer.readu32(MessageBlock, 56)
	local M15 = buffer.readu32(MessageBlock, 60)

	local Temp
	for Index = 1, 7 do
		V00 += V04 + M00; V12 = bit32.lrotate(bit32.bxor(V12, V00), 16)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 20)
		V00 += V04 + M01; V12 = bit32.lrotate(bit32.bxor(V12, V00), 24)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 25)

		V01 += V05 + M02; V13 = bit32.lrotate(bit32.bxor(V13, V01), 16)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 20)
		V01 += V05 + M03; V13 = bit32.lrotate(bit32.bxor(V13, V01), 24)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 25)

		V02 += V06 + M04; V14 = bit32.lrotate(bit32.bxor(V14, V02), 16)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 20)
		V02 += V06 + M05; V14 = bit32.lrotate(bit32.bxor(V14, V02), 24)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 25)

		V03 += V07 + M06; V15 = bit32.lrotate(bit32.bxor(V15, V03), 16)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 20)
		V03 += V07 + M07; V15 = bit32.lrotate(bit32.bxor(V15, V03), 24)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 25)

		V00 += V05 + M08; V15 = bit32.lrotate(bit32.bxor(V15, V00), 16)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 20)
		V00 += V05 + M09; V15 = bit32.lrotate(bit32.bxor(V15, V00), 24)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 25)

		V01 += V06 + M10; V12 = bit32.lrotate(bit32.bxor(V12, V01), 16)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 20)
		V01 += V06 + M11; V12 = bit32.lrotate(bit32.bxor(V12, V01), 24)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 25)

		V02 += V07 + M12; V13 = bit32.lrotate(bit32.bxor(V13, V02), 16)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 20)
		V02 += V07 + M13; V13 = bit32.lrotate(bit32.bxor(V13, V02), 24)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 25)

		V03 += V04 + M14; V14 = bit32.lrotate(bit32.bxor(V14, V03), 16)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 20)
		V03 += V04 + M15; V14 = bit32.lrotate(bit32.bxor(V14, V03), 24)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 25)

		if Index ~= 7 then
			Temp = M02
			M02 = M03
			M03 = M10
			M10 = M12
			M12 = M09
			M09 = M11
			M11 = M05
			M05 = M00
			M00 = Temp

			Temp = M06
			M06 = M04
			M04 = M07
			M07 = M13
			M13 = M14
			M14 = M15
			M15 = M08
			M08 = M01
			M01 = Temp
		end
	end

	if IsFull then
		local Result = buffer.create(EXTENDED_CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		buffer.writeu32(Result, 32, bit32.bxor(V08, Hash00))
		buffer.writeu32(Result, 36, bit32.bxor(V09, Hash01))
		buffer.writeu32(Result, 40, bit32.bxor(V10, Hash02))
		buffer.writeu32(Result, 44, bit32.bxor(V11, Hash03))
		buffer.writeu32(Result, 48, bit32.bxor(V12, Hash04))
		buffer.writeu32(Result, 52, bit32.bxor(V13, Hash05))
		buffer.writeu32(Result, 56, bit32.bxor(V14, Hash06))
		buffer.writeu32(Result, 60, bit32.bxor(V15, Hash07))

		return Result
	else
		local Result = buffer.create(CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		return Result
	end
end

local function ProcessMessage(InitialHashVector: buffer, Flags: number, Message: buffer, Length: number): buffer
	local MessageLength = buffer.len(Message)
	local StateCvs = buffer.create(STACK_BUFFER_SIZE)
	local StackSize = 0
	local StateCv = buffer.create(CV_SIZE)
	buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)

	local StateCounter = 0
	local StateChunkNumber = 0
	local StateEndFlag = 0
	local StateStartFlag = CHUNK_START

	local BlockBuffer = buffer.create(BLOCK_SIZE)

	for BlockOffset = 0, MessageLength - BLOCK_SIZE - 1, BLOCK_SIZE do
		buffer.copy(BlockBuffer, 0, Message, BlockOffset, BLOCK_SIZE)
		local StateFlags = Flags + StateStartFlag + StateEndFlag

		StateCv = Compress(StateCv, BlockBuffer, StateCounter, BLOCK_SIZE, StateFlags)
		StateStartFlag = 0
		StateChunkNumber += 1

		if StateChunkNumber == 15 then
			StateEndFlag = CHUNK_END
		elseif StateChunkNumber == 16 then
			local MergeCv = StateCv
			local MergeAmount = StateCounter + 1

			while MergeAmount % 2 == 0 do
				StackSize = StackSize - 1
				local PopCv = buffer.create(CV_SIZE)
				buffer.copy(PopCv, 0, StateCvs, StackSize * CV_SIZE, CV_SIZE)

				local Block = buffer.create(EXTENDED_CV_SIZE)
				buffer.copy(Block, 0, PopCv, 0, CV_SIZE)
				buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

				MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
				MergeAmount = MergeAmount / 2
			end

			buffer.copy(StateCvs, StackSize * CV_SIZE, MergeCv, 0, CV_SIZE)
			StackSize = StackSize + 1
			buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)
			StateStartFlag = CHUNK_START

			StateCounter += 1
			StateChunkNumber = 0
			StateEndFlag = 0
		end
	end

	local LastLength = MessageLength == 0 and 0 or ((MessageLength - 1) % BLOCK_SIZE + 1)
	local PaddedMessage = buffer.create(BLOCK_SIZE)

	if LastLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, MessageLength - LastLength, LastLength)
	end

	local OutputCv: buffer
	local OutputBlock: buffer
	local OutputLength: number
	local OutputFlags: number

	if StateCounter > 0 then
		local StateFlags = Flags + StateStartFlag + CHUNK_END
		local MergeCv = Compress(StateCv, PaddedMessage, StateCounter, LastLength, StateFlags)

		for Index = StackSize, 2, -1 do
			local StackCv = buffer.create(CV_SIZE)
			buffer.copy(StackCv, 0, StateCvs, (Index - 1) * CV_SIZE, CV_SIZE)

			local Block = buffer.create(EXTENDED_CV_SIZE)
			buffer.copy(Block, 0, StackCv, 0, CV_SIZE)
			buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

			MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
		end

		OutputCv = InitialHashVector
		local FirstStackCv = buffer.create(CV_SIZE)
		buffer.copy(FirstStackCv, 0, StateCvs, 0, CV_SIZE)

		OutputBlock = buffer.create(EXTENDED_CV_SIZE)
		buffer.copy(OutputBlock, 0, FirstStackCv, 0, CV_SIZE)
		buffer.copy(OutputBlock, CV_SIZE, MergeCv, 0, CV_SIZE)

		OutputLength = BLOCK_SIZE
		OutputFlags = Flags + ROOT_FLAG + PARENT_FLAG
	else
		OutputCv = StateCv
		OutputBlock = PaddedMessage
		OutputLength = LastLength
		OutputFlags = Flags + StateStartFlag + CHUNK_END + ROOT_FLAG
	end

	local Output = buffer.create(Length)
	local OutputOffset = 0

	for Index = 0, Length // BLOCK_SIZE do
		local MessageDigest = Compress(OutputCv, OutputBlock, Index, OutputLength, OutputFlags, true)

		local BytesToCopy = math.min(BLOCK_SIZE, Length - OutputOffset)
		buffer.copy(Output, OutputOffset, MessageDigest, 0, BytesToCopy)
		OutputOffset += BytesToCopy

		if OutputOffset >= Length then
			break
		end
	end

	return Output
end

return function(Message: buffer, Length: number?): buffer
	return ProcessMessage(INITIAL_VECTORS, 0, Message, Length or 32)
end]]></ProtectedString>
									<string name="ScriptGuid">{04CE6A7F-D8FD-446B-8315-72B2A83AE09F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Blake3</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX285CC2F1985744A29570F02A99BF2286">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: ChaCha20
	
	Sizes:
		Nonce: 12 bytes
		Key: 16/32 bytes
	
	Return type: buffer
	Example usage:
		local Data = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		local Nonce = buffer.fromstring(string.rep("n", 12))
		
		--------Usage Case 1--------
		local Encrypted = ChaCha20(Data, Key, Nonce)
		
		--------Usage Case 2--------
		local Decrypted = ChaCha20(Encrypted, Key, Nonce)
--]=]

--!strict
--!native
--!optimize 2

local DWORD = 4
local BLOCK_SIZE = 64
local STATE_SIZE = 16

local CHACHA20_NONCE_SIZE = 12
local CHACHA20_KEY_SIZE_16 = 16
local CHACHA20_KEY_SIZE_32 = 32

local SIGMA_CONSTANTS = buffer.create(16) do
	local SigmaBytes = { string.byte("expand 32-byte k", 1, -1) }
	for Index, ByteValue in SigmaBytes do
		buffer.writeu8(SIGMA_CONSTANTS, Index - 1, ByteValue)
	end
end

local TAU_CONSTANTS = buffer.create(16) do
	local TauBytes = { string.byte("expand 16-byte k", 1, -1) }
	for Index, ByteValue in TauBytes do
		buffer.writeu8(TAU_CONSTANTS, Index - 1, ByteValue)
	end
end

local function ProcessBlock(InitialState: buffer, Rounds: number)
	local S0: number, S1: number, S2: number, S3: number, S4: number, S5: number, S6: number, S7: number, S8: number, S9: number, S10: number, S11: number, S12: number, S13: number, S14: number, S15: number =
		buffer.readu32(InitialState, 0), buffer.readu32(InitialState, 4),
		buffer.readu32(InitialState, 8), buffer.readu32(InitialState, 12),
		buffer.readu32(InitialState, 16), buffer.readu32(InitialState, 20),
		buffer.readu32(InitialState, 24), buffer.readu32(InitialState, 28),
		buffer.readu32(InitialState, 32), buffer.readu32(InitialState, 36),
		buffer.readu32(InitialState, 40), buffer.readu32(InitialState, 44),
		buffer.readu32(InitialState, 48), buffer.readu32(InitialState, 52),
		buffer.readu32(InitialState, 56), buffer.readu32(InitialState, 60)

	for Round = 1, Rounds do
		local IsOddRound = Round % 2 == 1

		if IsOddRound then
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 16)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 12)
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 8)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 7)

			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 16)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 12)
			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 8)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 7)

			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 16)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 12)
			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 8)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 7)

			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 16)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 12)
			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 8)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 7)
		else
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 16)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 12)
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 8)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 7)

			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 16)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 12)
			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 8)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 7)

			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 16)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 12)
			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 8)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 7)

			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 16)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 12)
			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 8)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 7)
		end
	end

	buffer.writeu32(InitialState, 0, buffer.readu32(InitialState, 0) + S0)
	buffer.writeu32(InitialState, 4, buffer.readu32(InitialState, 4) + S1)
	buffer.writeu32(InitialState, 8, buffer.readu32(InitialState, 8) + S2)
	buffer.writeu32(InitialState, 12, buffer.readu32(InitialState, 12) + S3)
	buffer.writeu32(InitialState, 16, buffer.readu32(InitialState, 16) + S4)
	buffer.writeu32(InitialState, 20, buffer.readu32(InitialState, 20) + S5)
	buffer.writeu32(InitialState, 24, buffer.readu32(InitialState, 24) + S6)
	buffer.writeu32(InitialState, 28, buffer.readu32(InitialState, 28) + S7)
	buffer.writeu32(InitialState, 32, buffer.readu32(InitialState, 32) + S8)
	buffer.writeu32(InitialState, 36, buffer.readu32(InitialState, 36) + S9)
	buffer.writeu32(InitialState, 40, buffer.readu32(InitialState, 40) + S10)
	buffer.writeu32(InitialState, 44, buffer.readu32(InitialState, 44) + S11)
	buffer.writeu32(InitialState, 48, buffer.readu32(InitialState, 48) + S12)
	buffer.writeu32(InitialState, 52, buffer.readu32(InitialState, 52) + S13)
	buffer.writeu32(InitialState, 56, buffer.readu32(InitialState, 56) + S14)
	buffer.writeu32(InitialState, 60, buffer.readu32(InitialState, 60) + S15)
end

local function InitializeState(Key: buffer, Nonce: buffer, Counter: number): buffer
	local KeyLength = buffer.len(Key)
	local State = buffer.create(STATE_SIZE * DWORD)

	local Constants = KeyLength == 32 and SIGMA_CONSTANTS or TAU_CONSTANTS

	buffer.copy(State, 0, Constants, 0, 16)

	buffer.copy(State, 16, Key, 0, math.min(KeyLength, 16))
	if KeyLength == 32 then
		buffer.copy(State, 32, Key, 16, 16)
	else
		buffer.copy(State, 32, Key, 0, 16)
	end

	buffer.writeu32(State, 48, Counter)
	buffer.copy(State, 52, Nonce, 0, 12)

	return State
end

local function ChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?): buffer
	if Data == nil then
		error("Data cannot be nil", 2)
	end

	if typeof(Data) ~= "buffer" then
		error(`Data must be a buffer, got {typeof(Data)}`, 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE_16 and KeyLength ~= CHACHA20_KEY_SIZE_32 then
		error(`Key must be {CHACHA20_KEY_SIZE_16} or {CHACHA20_KEY_SIZE_32} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	if NonceLength ~= CHACHA20_NONCE_SIZE then
		error(`Nonce must be exactly {CHACHA20_NONCE_SIZE} bytes long, got {NonceLength} bytes`, 2)
	end

	if Counter then
		if typeof(Counter) ~= "number" then
			error(`Counter must be a number, got {typeof(Counter)}`, 2)
		end

		if Counter < 0 then
			error(`Counter cannot be negative, got {Counter}`, 2)
		end

		if Counter ~= math.floor(Counter) then
			error(`Counter must be an integer, got {Counter}`, 2)
		end

		if Counter >= 2^32 then
			error(`Counter must be less than 2^32, got {Counter}`, 2)
		end
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds ~= math.floor(Rounds) then
			error(`Rounds must be an integer, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockCounter = Counter or 1
	local BlockRounds = Rounds or 20

	local DataLength = buffer.len(Data)
	if DataLength == 0 then
		return buffer.create(0)
	end

	local Output = buffer.create(DataLength)

	local DataOffset = 0

	local State = InitializeState(Key, Nonce, BlockCounter)
	local StateBackup = buffer.create(64)
	buffer.copy(StateBackup, 0, State, 0)

	while DataOffset < DataLength do
		ProcessBlock(State, BlockRounds)

		local BytesToProcess = math.min(BLOCK_SIZE, DataLength - DataOffset)

		for Index = 0, BytesToProcess - 1 do
			local DataByte = buffer.readu8(Data, DataOffset + Index)
			local KeystreamByte = buffer.readu8(State, Index)
			buffer.writeu8(Output, DataOffset + Index, bit32.bxor(DataByte, KeystreamByte))
		end

		DataOffset += BytesToProcess
		BlockCounter += 1
		buffer.copy(State, 0, StateBackup, 0)
		buffer.writeu32(State, 48, BlockCounter)
	end

	return Output
end

return ChaCha20]]></ProtectedString>
									<string name="ScriptGuid">{7B7A3DC4-3EA0-4E60-9156-7733A260E042}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ChaCha20</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7F2756CC78DD4AC18E9FC6A00BBE5887">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Conversions
	
	Return type: string / buffer
	Example Usage:
		local HexString = Conversions.ToHex(buffer.fromstring("Hello World"))
		local OriginalBuffer = Conversions.FromHex("48656c6c6f20576f726c64")
--]=]

--!strict
--!optimize 2
--!native

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local DECODE_LOOKUP = buffer.create(65536 * 2) do
	for High = 0, 255 do
		for Low = 0, 255 do
			local HighNibble = 0
			local LowNibble = 0

			if High >= 48 and High <= 57 then
				HighNibble = High - 48
			elseif High >= 65 and High <= 70 then
				HighNibble = High - 55
			elseif High >= 97 and High <= 102 then
				HighNibble = High - 87
			else
				HighNibble = 0
			end

			if Low >= 48 and Low <= 57 then
				LowNibble = Low - 48
			elseif Low >= 65 and Low <= 70 then
				LowNibble = Low - 55
			elseif Low >= 97 and Low <= 102 then
				LowNibble = Low - 87
			else
				LowNibble = 0
			end

			local Combined = bit32.lshift(HighNibble, 4) + LowNibble
			local Index = bit32.lshift(Low, 8) + High
			buffer.writeu16(DECODE_LOOKUP, Index * 2, Combined)
		end
	end
end

local Conversions = {}

function Conversions.ToHex(Buffer: buffer): string
	local Length = buffer.len(Buffer)
	local Hex = buffer.create(Length * 2)

	local Lookup = ENCODE_LOOKUP

	local Leftover = Length % 8
	local HexCursor = 0

	for Index = 0, Length - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = Length - Leftover, Length - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex)
end

function Conversions.FromHex(Hex: string | buffer): buffer
	local BufferHex = if type(Hex) == "string" then buffer.fromstring(Hex) else Hex
	local Length = buffer.len(BufferHex)
	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`)
	end

	local Buffer = buffer.create(bit32.rshift(Length, 1))
	local Leftover = Length % 16
	local BufferCursor = 0
	local Lookup = DECODE_LOOKUP

	for Index = 0, Length - Leftover - 1, 16 do
		local Pair1 = buffer.readu16(BufferHex, Index)
		local Pair2 = buffer.readu16(BufferHex, Index + 2)
		local Pair3 = buffer.readu16(BufferHex, Index + 4)
		local Pair4 = buffer.readu16(BufferHex, Index + 6)
		local Pair5 = buffer.readu16(BufferHex, Index + 8)
		local Pair6 = buffer.readu16(BufferHex, Index + 10)
		local Pair7 = buffer.readu16(BufferHex, Index + 12)
		local Pair8 = buffer.readu16(BufferHex, Index + 14)

		local Byte1 = buffer.readu16(Lookup, Pair1 * 2)
		local Byte2 = buffer.readu16(Lookup, Pair2 * 2)
		local Byte3 = buffer.readu16(Lookup, Pair3 * 2)
		local Byte4 = buffer.readu16(Lookup, Pair4 * 2)
		local Byte5 = buffer.readu16(Lookup, Pair5 * 2)
		local Byte6 = buffer.readu16(Lookup, Pair6 * 2)
		local Byte7 = buffer.readu16(Lookup, Pair7 * 2)
		local Byte8 = buffer.readu16(Lookup, Pair8 * 2)

		local Chunk1 = bit32.lshift(Byte4, 24) + bit32.lshift(Byte3, 16) + 
			bit32.lshift(Byte2, 8) + Byte1
		local Chunk2 = bit32.lshift(Byte8, 24) + bit32.lshift(Byte7, 16) + 
			bit32.lshift(Byte6, 8) + Byte5

		buffer.writeu32(Buffer, BufferCursor, Chunk1)
		buffer.writeu32(Buffer, BufferCursor + 4, Chunk2)
		BufferCursor += 8
	end

	for Index = Length - Leftover, Length - 1, 2 do
		local Pair = buffer.readu16(BufferHex, Index)
		local Byte = buffer.readu16(Lookup, Pair * 2)
		buffer.writeu8(Buffer, BufferCursor, Byte)
		BufferCursor += 1
	end

	return Buffer
end

return Conversions]]></ProtectedString>
									<string name="ScriptGuid">{1E1B2329-EC10-4803-BA36-9C44B21192D3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Conversions</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX412E78CDFA1B4377B339295193354AD3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Compression Module
	
	Polynomial coefficient compression and decompression operations for ML-KEM.
	Maps field elements to and from reduced bit representations.
--]=]

--!strict
--!optimize 2
--!native

local Params = require("./Params")

local N = 256
local Q = 3329

local Compression = {}

function Compression.Compress(Value: number, D: number): number
	local Shifted = Value * (2^D)
	local QHalf = 1664
	local Rounded = Shifted + QHalf
	local Quotient = Rounded // Q
	local Mask = (2^D) - 1
	
	return bit32.band(Quotient, Mask)
end

function Compression.Decompress(Value: number, D: number): number
	local Product = Value * Q
	local Quotient = bit32.rshift(Product, D)
	local RoundBit = bit32.band(bit32.rshift(Product, D - 1), 1)
	return Quotient + RoundBit
end

function Compression.PolyCompress(Poly: buffer, D: number)
	if not Params.CheckD(D) then
		error("Invalid compression parameter d")
	end

	local Modulus = Q

	if D == 1 then
		for Index = 0, N - 1 do
			local Value = buffer.readu16(Poly, Index * 2)
			local Shifted = Value * 2
			local Rounded = Shifted + 1664
			local Quotient = Rounded // Modulus
			buffer.writeu16(Poly, Index * 2, bit32.band(Quotient, 1))
		end
	elseif D == 4 then
		for Index = 0, N - 1 do
			local Value = buffer.readu16(Poly, Index * 2)
			local Shifted = Value * 16
			local Rounded = Shifted + 1664
			local Quotient = Rounded // Modulus
			buffer.writeu16(Poly, Index * 2, bit32.band(Quotient, 15))
		end
	elseif D == 5 then
		for Index = 0, N - 1 do
			local Value = buffer.readu16(Poly, Index * 2)
			local Shifted = Value * 32
			local Rounded = Shifted + 1664
			local Quotient = Rounded // Modulus
			buffer.writeu16(Poly, Index * 2, bit32.band(Quotient, 31))
		end
	elseif D == 10 then
		for Index = 0, N - 1 do
			local Value = buffer.readu16(Poly, Index * 2)
			local Shifted = Value * 1024
			local Rounded = Shifted + 1664
			local Quotient = Rounded // Modulus
			buffer.writeu16(Poly, Index * 2, bit32.band(Quotient, 1023))
		end
	elseif D == 11 then
		for Index = 0, N - 1 do
			local Value = buffer.readu16(Poly, Index * 2)
			local Shifted = Value * 2048
			local Rounded = Shifted + 1664
			local Quotient = Rounded // Modulus
			buffer.writeu16(Poly, Index * 2, bit32.band(Quotient, 2047))
		end
	else
		local Compress = Compression.Compress
		for Index = 0, N - 1 do
			local Value = buffer.readu16(Poly, Index * 2)
			local Compressed = Compress(Value, D)
			buffer.writeu16(Poly, Index * 2, Compressed)
		end
	end
end

function Compression.PolyDecompress(Poly: buffer, D: number)
	if not Params.CheckD(D) then
		error("Invalid decompression parameter d")
	end

	local Modulus = Q

	if D == 1 then
		for Index = 0, N - 1 do
			local Compressed = buffer.readu16(Poly, Index * 2)
			local Product = Compressed * Modulus
			local Quotient = bit32.rshift(Product, 1)
			local RoundBit = bit32.band(Product, 1)
			buffer.writeu16(Poly, Index * 2, Quotient + RoundBit)
		end
	elseif D == 4 then
		for Index = 0, N - 1 do
			local Compressed = buffer.readu16(Poly, Index * 2)
			local Product = Compressed * Modulus
			local Quotient = bit32.rshift(Product, 4)
			local RoundBit = bit32.band(bit32.rshift(Product, 3), 1)
			buffer.writeu16(Poly, Index * 2, Quotient + RoundBit)
		end
	elseif D == 5 then
		for Index = 0, N - 1 do
			local Compressed = buffer.readu16(Poly, Index * 2)
			local Product = Compressed * Modulus
			local Quotient = bit32.rshift(Product, 5)
			local RoundBit = bit32.band(bit32.rshift(Product, 4), 1)
			buffer.writeu16(Poly, Index * 2, Quotient + RoundBit)
		end
	elseif D == 10 then
		for Index = 0, N - 1 do
			local Compressed = buffer.readu16(Poly, Index * 2)
			local Product = Compressed * Modulus
			local Quotient = bit32.rshift(Product, 10)
			local RoundBit = bit32.band(bit32.rshift(Product, 9), 1)
			buffer.writeu16(Poly, Index * 2, Quotient + RoundBit)
		end
	elseif D == 11 then
		for Index = 0, N - 1 do
			local Compressed = buffer.readu16(Poly, Index * 2)
			local Product = Compressed * Modulus
			local Quotient = bit32.rshift(Product, 11)
			local RoundBit = bit32.band(bit32.rshift(Product, 10), 1)
			buffer.writeu16(Poly, Index * 2, Quotient + RoundBit)
		end
	else
		local Decompress = Compression.Decompress
		for Index = 0, N - 1 do
			local Compressed = buffer.readu16(Poly, Index * 2)
			local Decompressed = Decompress(Compressed, D)
			buffer.writeu16(Poly, Index * 2, Decompressed)
		end
	end
end

return Compression]]></ProtectedString>
								<string name="ScriptGuid">{29048D8E-FC6A-499F-BFFF-6132F06784D7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Compression</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4EDC9BAAD16D4B08B581B74B1FEAB64C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Field Arithmetic Module
	
	Prime field Zq arithmetic operations for ML-KEM.
	Modular arithmetic over the field Z_q where q = 3329.
	
	Example usage:
		local Field = require(script.Field)
		
		local Sum = Field.Add(1234, 567)
		local Product = Field.Multiply(1234, 567)
		local Inverse = Field.Invert(1234)
		
		local Buffer = Field.BufferCreate(256)
		Field.BufferReduce(Buffer, 256)
		
		local Sum = Field.BufferAdd(BufferA, BufferB, Result, 256)
--]=]

--!strict
--!optimize 2
--!native

local Q = 13 * 256 + 1

local Field = {}

function Field.Add(A: number, B: number): number
	local Sum = A + B
	return if Sum >= Q then Sum - Q else Sum
end

function Field.Subtract(A: number, B: number): number
	local Diff = A - B
	return if Diff < 0 then Diff + Q else Diff
end

function Field.Multiply(A: number, B: number): number
	return (A * B) % Q
end

function Field.Negate(A: number): number
	return if A == 0 then 0 else Q - A
end

function Field.Power(Base: number, Exponent: number): number
	local Result = if bit32.band(Exponent, 1) == 1 then Base else 1
	local CurrentBase = Base

	local Exp = Exponent
	while Exp > 1 do
		Exp = bit32.rshift(Exp, 1)
		CurrentBase = Field.Multiply(CurrentBase, CurrentBase)

		if bit32.band(Exp, 1) == 1 then
			Result = Field.Multiply(Result, CurrentBase)
		end
	end

	return Result
end

function Field.Invert(A: number): number
	if A == 0 then
		return 0
	end

	return Field.Power(A, Q - 2)
end

function Field.BufferReduce(Buffer: buffer, Count: number)
	local Modulus = Q
	for Index = 0, Count - 1 do
		local Value = buffer.readu16(Buffer, Index * 2)
		buffer.writeu16(Buffer, Index * 2, (Value % Modulus))
	end
end

return Field]]></ProtectedString>
								<string name="ScriptGuid">{E3C89F64-99B0-4D15-AA9E-5465E1985303}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Field</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7E45BDFDACF54ADD9D783B8BEE7615E9">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Number Theoretic Transform Module
	
	Number Theoretic Transform (NTT) operations for polynomial multiplication.
	Cooley-Tukey NTT and Gentleman-Sande inverse NTT algorithms
		
	Example usage:
		local NTT = require(script.NTT)
		
		local Poly = buffer.create(512) -- 256 coefficients * 2 bytes
		NTT.Ntt(Poly) -- Forward transform
		NTT.Intt(Poly) -- Inverse transform
--]=]

--!strict
--!optimize 2
--!native

local Field = require("./Field")
local Utils = require("./Utils")

local LOG2N = 8
local N = 2^LOG2N

local Q = 3329
local ZETA = 17
local INV_N = Field.Invert(N / 2)

local Ntt = {}

local NTT_ZETA_EXP = buffer.create((N / 2) * 2) do
	for I = 0, N / 2 - 1 do
		local BitRevIndex = Utils.BitReverse(I, LOG2N - 1)
		local ZetaExp = Field.Power(ZETA, BitRevIndex)
		buffer.writeu16(NTT_ZETA_EXP, I * 2, ZetaExp)
	end
end

local INTT_ZETA_EXP = buffer.create((N / 2) * 2) do
	for I = 0, N / 2 - 1 do
		local NttZeta = buffer.readu16(NTT_ZETA_EXP, I * 2)
		local NegZeta = if NttZeta == 0 then 0 else Q - NttZeta
		buffer.writeu16(INTT_ZETA_EXP, I * 2, NegZeta)
	end
end

local POLY_MUL_ZETA_EXP = buffer.create((N / 2) * 2) do
	for I = 0, N / 2 - 1 do
		local BitRevIndex = Utils.BitReverse(I, LOG2N - 1)
		local Exponent = bit32.bxor(bit32.lshift(BitRevIndex, 1), 1)
		local ZetaExp = Field.Power(ZETA, Exponent)
		buffer.writeu16(POLY_MUL_ZETA_EXP, I * 2, ZetaExp)
	end
end

local POWERS_OF_TWO = table.create(LOG2N) :: {{number}}
for I = 0, LOG2N - 1 do
	POWERS_OF_TWO[I] = {2^I, (2^I) * 2}
end

function Ntt.Ntt(Poly: buffer)
	local Zeta = NTT_ZETA_EXP
	local Powers = POWERS_OF_TWO
	local Modulus = Q
	
	for L = LOG2N - 1, 1, -1 do
		local Len = Powers[L][1]
		local LenX2 = Powers[L][2]
		local KBeg = bit32.rshift(N, L + 1)

		for Start = 0, N - 1, LenX2 do
			local KNow = KBeg + bit32.rshift(Start, L + 1)
			local ZetaExp = buffer.readu16(Zeta, KNow * 2)

			for I = Start, Start + Len - 1 do
				local OffsetI = I * 2
				local OffsetILen = (I + Len) * 2

				local PolyI = buffer.readu16(Poly, OffsetI)
				local PolyILen = buffer.readu16(Poly, OffsetILen)

				local Tmp = (ZetaExp * PolyILen) % Modulus

				local SubResult = if PolyI >= Tmp then PolyI - Tmp else PolyI - Tmp + Modulus

				local Sum = PolyI + Tmp
				local AddResult = if Sum >= Modulus then Sum - Modulus else Sum

				buffer.writeu16(Poly, OffsetILen, SubResult)
				buffer.writeu16(Poly, OffsetI, AddResult)
			end
		end
	end
end

function Ntt.Intt(Poly: buffer)
	local Zeta = INTT_ZETA_EXP
	local InvN = INV_N
	local Powers = POWERS_OF_TWO
	local Modulus = Q
	
	for L = 1, LOG2N - 1 do
		local Len = Powers[L][1]
		local LenX2 = Powers[L][2]
		local KBeg = bit32.rshift(N, L) - 1

		for Start = 0, N - 1, LenX2 do
			local KNow = KBeg - bit32.rshift(Start, L + 1)
			local NegZetaExp = buffer.readu16(Zeta, KNow * 2)

			for I = Start, Start + Len - 1 do
				local OffsetI = I * 2
				local OffsetILen = (I + Len) * 2

				local PolyI = buffer.readu16(Poly, OffsetI)
				local PolyILen = buffer.readu16(Poly, OffsetILen)

				local Sum = PolyI + PolyILen
				
				local AddResult = if Sum >= Modulus then Sum - Modulus else Sum
				local SubResult = if PolyI >= PolyILen then PolyI - PolyILen else PolyI - PolyILen + Modulus

				local MulResult = (SubResult * NegZetaExp) % Modulus

				buffer.writeu16(Poly, OffsetI, AddResult)
				buffer.writeu16(Poly, OffsetILen, MulResult)
			end
		end
	end

	for I = 0, N - 1 do
		local Offset = I * 2
		local Coeff = buffer.readu16(Poly, Offset)

		local Scaled = (Coeff * InvN) % Q
		buffer.writeu16(Poly, Offset, Scaled)
	end
end

function Ntt.NttAt(Poly: buffer, BaseOffset: number)
	local Zeta = NTT_ZETA_EXP
	local Powers = POWERS_OF_TWO
	local Modulus = Q

	for L = LOG2N - 1, 1, -1 do
		local Len = Powers[L][1]
		local LenX2 = Powers[L][2]
		local KBeg = bit32.rshift(N, L + 1)

		for Start = 0, N - 1, LenX2 do
			local KNow = KBeg + bit32.rshift(Start, L + 1)
			local ZetaExp = buffer.readu16(Zeta, KNow * 2)

			for I = Start, Start + Len - 1 do
				local OffsetI = BaseOffset + I * 2
				local OffsetILen = BaseOffset + (I + Len) * 2

				local PolyI = buffer.readu16(Poly, OffsetI)
				local PolyILen = buffer.readu16(Poly, OffsetILen)

				local Tmp = (ZetaExp * PolyILen) % Modulus

				local SubResult = if PolyI >= Tmp then PolyI - Tmp else PolyI - Tmp + Modulus
				local Sum = PolyI + Tmp
				local AddResult = if Sum >= Modulus then Sum - Modulus else Sum

				buffer.writeu16(Poly, OffsetILen, SubResult)
				buffer.writeu16(Poly, OffsetI, AddResult)
			end
		end
	end
end

function Ntt.InttAt(Poly: buffer, BaseOffset: number)
	local Zeta = INTT_ZETA_EXP
	local InvN = INV_N
	local Powers = POWERS_OF_TWO
	local Modulus = Q

	for L = 1, LOG2N - 1 do
		local Len = Powers[L][1]
		local LenX2 = Powers[L][2]
		local KBeg = bit32.rshift(N, L) - 1

		for Start = 0, N - 1, LenX2 do
			local KNow = KBeg - bit32.rshift(Start, L + 1)
			local NegZetaExp = buffer.readu16(Zeta, KNow * 2)

			for I = Start, Start + Len - 1 do
				local OffsetI = BaseOffset + I * 2
				local OffsetILen = BaseOffset + (I + Len) * 2

				local PolyI = buffer.readu16(Poly, OffsetI)
				local PolyILen = buffer.readu16(Poly, OffsetILen)

				local Sum = PolyI + PolyILen
				local AddResult = if Sum >= Modulus then Sum - Modulus else Sum
				local SubResult = if PolyI >= PolyILen then PolyI - PolyILen else PolyI - PolyILen + Modulus

				local MulResult = (SubResult * NegZetaExp) % Modulus

				buffer.writeu16(Poly, OffsetI, AddResult)
				buffer.writeu16(Poly, OffsetILen, MulResult)
			end
		end
	end

	for I = 0, N - 1 do
		local Offset = BaseOffset + I * 2
		local Coeff = buffer.readu16(Poly, Offset)
		buffer.writeu16(Poly, Offset, (Coeff * InvN) % Modulus)
	end
end

function Ntt.PolyAddAt(F: buffer, FOffset: number, G: buffer, GOffset: number, H: buffer, HOffset: number)
	local Modulus = Q
	for Index = 0, 255 do
		local Offset = Index * 2
		local AValue = buffer.readu16(F, FOffset + Offset)
		local BValue = buffer.readu16(G, GOffset + Offset)
		local Sum = AValue + BValue
		buffer.writeu16(H, HOffset + Offset, if Sum >= Modulus then Sum - Modulus else Sum)
	end
end

function Ntt.PolyMul(F: buffer, G: buffer, H: buffer)
	local PolyZeta = POLY_MUL_ZETA_EXP
	local Modulus = Q
	
	for I = 0, N / 2 - 1 do
		local Offset = I * 4
		local ZetaExp = buffer.readu16(PolyZeta, I * 2)

		local F0 = buffer.readu16(F, Offset)
		local F1 = buffer.readu16(F, Offset + 2)
		local G0 = buffer.readu16(G, Offset)
		local G1 = buffer.readu16(G, Offset + 2)

		local Mul1 = (F0 * G0) % Modulus
		local Mul2 = (F1 * G1) % Modulus
		local Mul3 = (Mul2 * ZetaExp) % Modulus

		local Sum0 = Mul1 + Mul3
		local H0 = if Sum0 >= Modulus then Sum0 - Modulus else Sum0

		local Mul4 = (F0 * G1) % Modulus
		local Mul5 = (F1 * G0) % Modulus

		local Sum1 = Mul4 + Mul5
		local H1 = if Sum1 >= Modulus then Sum1 - Modulus else Sum1

		buffer.writeu16(H, Offset, H0)
		buffer.writeu16(H, Offset + 2, H1)
	end
end

function Ntt.PolyMulAt(F: buffer, FOffset: number, G: buffer, GOffset: number, H: buffer, HOffset: number)
	local PolyZeta = POLY_MUL_ZETA_EXP
	local Modulus = Q

	for I = 0, 127 do
		local LocalOffset = I * 4
		local ZetaExp = buffer.readu16(PolyZeta, I * 2)

		local F0 = buffer.readu16(F, FOffset + LocalOffset)
		local F1 = buffer.readu16(F, FOffset + LocalOffset + 2)
		local G0 = buffer.readu16(G, GOffset + LocalOffset)
		local G1 = buffer.readu16(G, GOffset + LocalOffset + 2)

		local Mul1 = (F0 * G0) % Modulus
		local Mul2 = (F1 * G1) % Modulus
		local Mul3 = (Mul2 * ZetaExp) % Modulus

		local Sum0 = Mul1 + Mul3
		local H0 = if Sum0 >= Modulus then Sum0 - Modulus else Sum0

		local Mul4 = (F0 * G1) % Modulus
		local Mul5 = (F1 * G0) % Modulus

		local Sum1 = Mul4 + Mul5
		local H1 = if Sum1 >= Modulus then Sum1 - Modulus else Sum1

		buffer.writeu16(H, HOffset + LocalOffset, H0)
		buffer.writeu16(H, HOffset + LocalOffset + 2, H1)
	end
end

function Ntt.PolyAdd(F: buffer, G: buffer, H: buffer)
	local Modulus = Q
	for Index = 0, N - 1 do
		local Offset = Index * 2
		local AValue = buffer.readu16(F, Offset)
		local BValue = buffer.readu16(G, Offset)

		local Sum = AValue + BValue
		local Result = if Sum >= Modulus then Sum - Modulus else Sum
		buffer.writeu16(H, Offset, Result)
	end
end

function Ntt.PolySub(F: buffer, G: buffer, H: buffer)
	local Modulus = Q
	for Index = 0, N - 1 do
		local Offset = Index * 2
		local AValue = buffer.readu16(F, Offset)
		local BValue = buffer.readu16(G, Offset)
		
		local Diff = AValue - BValue
		local Result = if Diff < 0 then Diff + Modulus else Diff
		buffer.writeu16(H, Offset, Result)
	end
end

return Ntt]]></ProtectedString>
								<string name="ScriptGuid">{753B8CF9-E003-49DB-A594-6F5763DEEC48}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">NTT</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4C77EC6DAFC54D59872DA3E91236B639">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Public Key Encryption Module
	
	K-PKE (CPA-secure public key encryption) implementation for ML-KEM.
	Provides key generation, encryption, and decryption operations
	as specified in NIST FIPS 203.
	
	Example usage:
		local PKE = require(script.PKE)
		
		local Seed = buffer.fromstring("32_byte_seed_here...")
		local PublicKey, SecretKey = PKE.MLKEM_1024.KeyGen(Seed)
		
		local Message = buffer.create(32)
		local Randomness = buffer.create(32)
		local Ciphertext = PKE.MLKEM_1024.Encrypt(PublicKey, Message, Randomness)
		
		local Plaintext = PKE.MLKEM_1024.Decrypt(SecretKey, Ciphertext)
--]=]

--!strict
--!optimize 2
--!native

local Ntt = require("./NTT")

local PolyVec = require("./PolyVec")
local Sampling = require("./Sampling")

local Serialize = require("./Serialize")
local Compression = require("./Compression")

local Params = require("./Params")
local Utils = require("./Utils")
local SHA3 = require("./SHA3")

local LOG2N = 8
local N = 2^LOG2N
local POLY_SIZE = N * 2 

local TEMP_V = buffer.create(N * 2)
local TEMP_V2 = buffer.create(N * 2)
local TEMP_SINGLE_POLY = buffer.create(N * 2)
local TEMP_R_POLY = buffer.create(N * 2)
local TEMP_T = buffer.create(N * 2)
local TEMP_T2 = buffer.create(N * 2)
local TEMP_U_POLY = buffer.create(N * 2)

local KEYGEN_G_INPUT = buffer.create(33)
local KEYGEN_RHO = buffer.create(32)
local KEYGEN_SIGMA = buffer.create(32)

local Pke = {}

function Pke.KeyGen(K: number, Eta1: number, Seed: buffer): (buffer, buffer)
	if not Params.CheckKeygenParams(K, Eta1) then
		error("Invalid keygen parameters")
	end
	if buffer.len(Seed) ~= 32 then
		error("Seed must be 32 bytes")
	end

	local GInput = KEYGEN_G_INPUT
	buffer.copy(GInput, 0, Seed, 0, 32)
	buffer.writeu8(GInput, 32, K)

	local GOutput = SHA3.SHA3_512(GInput)
	local Rho = KEYGEN_RHO
	local Sigma = KEYGEN_SIGMA
	buffer.copy(Rho, 0, GOutput, 0, 32)
	buffer.copy(Sigma, 0, GOutput, 32, 32)

	local APrime = Sampling.GenerateMatrix(K, Rho, false)

	local Nonce = 0
	local S = Sampling.GenerateVector(K, Eta1, Sigma, Nonce)
	Nonce += K
	local E = Sampling.GenerateVector(K, Eta1, Sigma, Nonce)

	PolyVec.VecNtt(S, K)
	PolyVec.VecNtt(E, K)

	local TPrime = PolyVec.VecCreate(K)
	PolyVec.MatVecMultiply(APrime, S, TPrime, K, K, K)
	PolyVec.VecAddTo(E, TPrime, K)

	local PublicKeyLen = Utils.GetPkePublicKeyLen(K)
	local PublicKey = buffer.create(PublicKeyLen)

	local EncodedTPrime = PolyVec.VecEncode(TPrime, K, 12)
	local RhoOffset = K * 12 * 32
	buffer.copy(PublicKey, 0, EncodedTPrime, 0, RhoOffset)
	buffer.copy(PublicKey, RhoOffset, Rho, 0, 32)

	return PublicKey, PolyVec.VecEncode(S, K, 12)
end

function Pke.Encrypt(K: number, Eta1: number, Eta2: number, Du: number, Dv: number, PublicKey: buffer, Message: buffer, Randomness: buffer): buffer
	if not Params.CheckEncryptParams(K, Eta1, Eta2, Du, Dv) then
		error("Invalid encryption parameters")
	end
	if buffer.len(PublicKey) ~= Utils.GetPkePublicKeyLen(K) then
		error("Invalid public key length")
	end
	if buffer.len(Message) ~= 32 then
		error("Message must be 32 bytes")
	end
	if buffer.len(Randomness) ~= 32 then
		error("Randomness must be 32 bytes")
	end
	
	local RhoOffset = K * 12 * 32
	local EncodedTPrime = buffer.create(RhoOffset)
	local Rho = buffer.create(32)
	buffer.copy(EncodedTPrime, 0, PublicKey, 0, RhoOffset)
	buffer.copy(Rho, 0, PublicKey, RhoOffset, 32)

	local TPrime = PolyVec.VecDecode(EncodedTPrime, K, 12)
	local ReEncodedTPrime = PolyVec.VecEncode(TPrime, K, 12)
	local IsValid = Utils.CtMemcmp(EncodedTPrime, ReEncodedTPrime)
	if IsValid ~= 0xFFFFFFFF then
		error("Key encapsulation verification failed")
	end
	
	local APrime = Sampling.GenerateMatrix(K, Rho, true)

	local Nonce = 0
	local R = Sampling.GenerateVector(K, Eta1, Randomness, Nonce)
	Nonce += K
	local E1 = Sampling.GenerateVector(K, Eta2, Randomness, Nonce)
	Nonce += K
	local E2 = Sampling.GenerateNoisePoly(Eta2, Randomness, Nonce)

	PolyVec.VecNtt(R, K)
	
	local U = PolyVec.VecCreate(K)
	PolyVec.MatVecMultiply(APrime, R, U, K, K, K)

	PolyVec.VecIntt(U, K)
	PolyVec.VecAddTo(E1, U, K)

	local V = TEMP_V
	local TempV = TEMP_V2
	local SinglePoly = TEMP_SINGLE_POLY
	local RPoly = TEMP_R_POLY
	buffer.fill(V, 0, 0, N * 2)

	local PolySize = POLY_SIZE
	for I = 0, K - 1 do
		local TPolyOffset = I * PolySize
		local RPolyOffset = I * PolySize
		buffer.copy(SinglePoly, 0, TPrime, TPolyOffset, PolySize)
		buffer.copy(RPoly, 0, R, RPolyOffset, PolySize)
		Ntt.PolyMul(SinglePoly, RPoly, TempV)
		Ntt.PolyAdd(V, TempV, V)
	end

	Ntt.Intt(V)
	Ntt.PolyAdd(V, E2, V)

	local M = Serialize.Decode(Message, 1)
	Compression.PolyDecompress(M, 1)
	Ntt.PolyAdd(V, M, V)

	PolyVec.VecCompress(U, K, Du)
	local EncodedU = PolyVec.VecEncode(U, K, Du)

	Compression.PolyCompress(V, Dv)
	local EncodedV = Serialize.Encode(V, Dv)

	local CiphertextLen = Utils.GetPkeCipherTextLen(K, Du, Dv)
	local Ciphertext = buffer.create(CiphertextLen)
	local ULen = buffer.len(EncodedU)
	buffer.copy(Ciphertext, 0, EncodedU, 0, ULen)
	buffer.copy(Ciphertext, ULen, EncodedV, 0, buffer.len(EncodedV))

	return Ciphertext
end

function Pke.Decrypt(K: number, Du: number, Dv: number, SecretKey: buffer, Ciphertext: buffer): buffer
	if not Params.CheckDecryptParams(K, Du, Dv) then
		error("Invalid decryption parameters")
	end
	if buffer.len(SecretKey) ~= Utils.GetPkeSecretKeyLen(K) then
		error("Invalid secret key length")
	end
	if buffer.len(Ciphertext) ~= Utils.GetPkeCipherTextLen(K, Du, Dv) then
		error("Invalid ciphertext length")
	end

	local ULen = K * Du * 32
	local VLen = Dv * 32

	local EncodedU = buffer.create(ULen)
	local EncodedV = buffer.create(VLen)
	buffer.copy(EncodedU, 0, Ciphertext, 0, ULen)
	buffer.copy(EncodedV, 0, Ciphertext, ULen, VLen)

	local U = PolyVec.VecDecode(EncodedU, K, Du)
	PolyVec.VecDecompress(U, K, Du)

	local V = Serialize.Decode(EncodedV, Dv)
	Compression.PolyDecompress(V, Dv)

	local SPrime = PolyVec.VecDecode(SecretKey, K, 12)

	PolyVec.VecNtt(U, K)

	local T = TEMP_T
	local TempT = TEMP_T2
	local SinglePoly = TEMP_SINGLE_POLY
	local UPoly = TEMP_U_POLY
	buffer.fill(T, 0, 0, N * 2)

	local PolySize = POLY_SIZE
	for I = 0, K - 1 do
		local SPolyOffset = I * PolySize
		local UPolyOffset = I * PolySize

		buffer.copy(SinglePoly, 0, SPrime, SPolyOffset, PolySize)
		buffer.copy(UPoly, 0, U, UPolyOffset, PolySize)

		Ntt.PolyMul(SinglePoly, UPoly, TempT)
		Ntt.PolyAdd(T, TempT, T)
	end

	Ntt.Intt(T)
	Ntt.PolySub(V, T, V)

	Compression.PolyCompress(V, 1)
	local Plaintext = Serialize.Encode(V, 1)

	return Plaintext
end

Pke.MLKEM_512 = {
	KeyGen = function(Seed: buffer): (buffer, buffer)
		return Pke.KeyGen(2, 3, Seed)
	end,

	Encrypt = function(PublicKey: buffer, Message: buffer, Randomness: buffer): buffer
		return Pke.Encrypt(2, 3, 2, 10, 4, PublicKey, Message, Randomness)
	end,

	Decrypt = function(SecretKey: buffer, Ciphertext: buffer): buffer
		return Pke.Decrypt(2, 10, 4, SecretKey, Ciphertext)
	end
}

Pke.MLKEM_768 = {
	KeyGen = function(Seed: buffer): (buffer, buffer)
		return Pke.KeyGen(3, 2, Seed)
	end,

	Encrypt = function(PublicKey: buffer, Message: buffer, Randomness: buffer): buffer
		return Pke.Encrypt(3, 2, 2, 10, 4, PublicKey, Message, Randomness)
	end,

	Decrypt = function(SecretKey: buffer, Ciphertext: buffer): buffer
		return Pke.Decrypt(3, 10, 4, SecretKey, Ciphertext)
	end
}

Pke.MLKEM_1024 = {
	KeyGen = function(Seed: buffer): (buffer, buffer)
		return Pke.KeyGen(4, 2, Seed)
	end,

	Encrypt = function(PublicKey: buffer, Message: buffer, Randomness: buffer): buffer
		return Pke.Encrypt(4, 2, 2, 11, 5, PublicKey, Message, Randomness)
	end,

	Decrypt = function(SecretKey: buffer, Ciphertext: buffer): buffer
		return Pke.Decrypt(4, 11, 5, SecretKey, Ciphertext)
	end
}

return Pke]]></ProtectedString>
								<string name="ScriptGuid">{F1966592-45BC-47AA-8C3D-23A914A868DF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PKE</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4143B43BD3134132B144BE1461D25557">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Parameters Module
	
	Parameter validation functions for ML-KEM.
	 NIST FIPS 203 specification.

	Example usage:
		local Params = require(script.Params)
		local IsValid = Params.CheckKeygenParams(4, 2) -- true
		
		local ValidD = Params.CheckD(11) -- true
		local ValidEncrypt = Params.CheckEncryptParams(4, 2, 2, 11, 5) -- true
--]=]

--!strict
--!optimize 2
--!native

local Params = {}

function Params.CheckD(D: number): boolean
	return D < 12
end

function Params.CheckEta(Eta: number): boolean
	return (Eta == 2) or (Eta == 3)
end

function Params.CheckK(K: number): boolean
	return (K == 2) or (K == 3) or (K == 4)
end

function Params.CheckL(L: number): boolean
	return (L == 1) or (L == 4) or (L == 5) or (L == 10) or (L == 11) or (L == 12)
end



function Params.CheckKeygenParams(K: number, Eta1: number): boolean
	local Flag0 = (K == 2) and (Eta1 == 3)
	local Flag1 = (K == 3) and (Eta1 == 2)
	local Flag2 = (K == 4) and (Eta1 == 2)

	return Flag0 or Flag1 or Flag2
end

function Params.CheckEncryptParams(K: number, Eta1: number, Eta2: number, Du: number, Dv: number): boolean
	local Flag0 = (K == 2) and (Eta1 == 3) and (Eta2 == 2) and (Du == 10) and (Dv == 4)
	local Flag1 = (K == 3) and (Eta1 == 2) and (Eta2 == 2) and (Du == 10) and (Dv == 4)
	local Flag2 = (K == 4) and (Eta1 == 2) and (Eta2 == 2) and (Du == 11) and (Dv == 5)

	return Flag0 or Flag1 or Flag2
end

function Params.CheckDecryptParams(K: number, Du: number, Dv: number): boolean
	local Flag0 = (K == 2) and (Du == 10) and (Dv == 4)
	local Flag1 = (K == 3) and (Du == 10) and (Dv == 4)
	local Flag2 = (K == 4) and (Du == 11) and (Dv == 5)

	return Flag0 or Flag1 or Flag2
end

function Params.CheckEncapParams(K: number, Eta1: number, Eta2: number, Du: number, Dv: number): boolean
	return Params.CheckEncryptParams(K, Eta1, Eta2, Du, Dv)
end

function Params.CheckDecapParams(K: number, Eta1: number, Eta2: number, Du: number, Dv: number): boolean
	return Params.CheckEncapParams(K, Eta1, Eta2, Du, Dv)
end

return Params]]></ProtectedString>
								<string name="ScriptGuid">{1766ACC3-B805-4A9D-8136-9FFB848266CF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Params</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE6E919CCACD7482B8E5FF3832AAA59F0">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Polynomial Vector Module
	
	Polynomial vector and matrix operations for ML-KEM.
	Vector arithmetic, matrix multiplication, and encoding/decoding
	operations on vectors of degree-255 polynomials.
--]=]

--!strict
--!optimize 2
--!native

local Ntt = require("./NTT")
local MlKemParams = require("./Params")
local MlKemSerialize = require("./Serialize")
local Compression = require("./Compression")

local LOG2N = 8
local N = 2^LOG2N
local Q = 3329
local POLY_SIZE = N * 2

local TEMP_POLY_MUL = buffer.create(N * 2)
local TEMP_POLY_ACCUM = buffer.create(N * 2)
local TEMP_POLY_ENCODE = buffer.create(N * 2)
local TEMP_POLY_COMPRESS = buffer.create(N * 2)

local PolyVec = {}

function PolyVec.VecCreate(K: number): buffer
	return buffer.create(K * POLY_SIZE)
end

function PolyVec.MatCreate(Rows: number, Cols: number): buffer
	return buffer.create(Rows * Cols * POLY_SIZE)
end

function PolyVec.MatSetPoly(Mat: buffer, Row: number, Col: number, Cols: number, Poly: buffer)
	local Index = Row * Cols + Col
	local Offset = Index * POLY_SIZE

	buffer.copy(Mat, Offset, Poly, 0, POLY_SIZE)
end

function PolyVec.MatVecMultiply(A: buffer, B: buffer, C: buffer, ARows: number, ACols: number, BRows: number)
	local PolySize = POLY_SIZE
	local AccumPoly = TEMP_POLY_ACCUM
	local TempPoly = TEMP_POLY_MUL
	
	local PolyMul = Ntt.PolyMulAt
	local PolyAdd = Ntt.PolyAddAt
	
	for I = 0, ARows - 1 do
		local COffset = I * PolySize
		buffer.fill(AccumPoly, 0, 0, PolySize)

		for K = 0, ACols - 1 do
			local AOffset = (I * ACols + K) * PolySize
			local BOffset = K * PolySize

			PolyMul(A, AOffset, B, BOffset, TempPoly, 0)
			PolyAdd(AccumPoly, 0, TempPoly, 0, AccumPoly, 0)
		end

		buffer.copy(C, COffset, AccumPoly, 0, PolySize)
	end
end

function PolyVec.VecNtt(Vec: buffer, K: number)
	local PolySize = POLY_SIZE
	local NttAt = Ntt.NttAt
	for I = 0, K - 1 do
		NttAt(Vec, I * PolySize)
	end
end

function PolyVec.VecIntt(Vec: buffer, K: number)
	local PolySize = POLY_SIZE
	local InttAt = Ntt.InttAt
	
	for I = 0, K - 1 do
		InttAt(Vec, I * PolySize)
	end
end

function PolyVec.VecAddTo(Src: buffer, Dst: buffer, K: number)
	local Modulus = Q
	local Total = K * N * 2

	for Offset = 0, Total - 2, 2 do
		local SrcValue = buffer.readu16(Src, Offset)
		local DstValue = buffer.readu16(Dst, Offset)
		local Sum = SrcValue + DstValue
		buffer.writeu16(Dst, Offset, if Sum >= Modulus then Sum - Modulus else Sum)
	end
end

function PolyVec.VecAdd(A: buffer, B: buffer, Result: buffer, K: number)
	if not (MlKemParams.CheckK(K) or K == 1) then
		error("Invalid vector dimension K")
	end

	local TotalCoeffs = K * N
	local Modulus = Q
	for Index = 0, TotalCoeffs - 1 do
		local Offset = Index * 2
		local AValue = buffer.readu16(A, Offset)
		local BValue = buffer.readu16(B, Offset)
		local Sum = AValue + BValue
		local AddResult = if Sum >= Modulus then Sum - Modulus else Sum
		buffer.writeu16(Result, Offset, AddResult)
	end
end

function PolyVec.VecEncode(Vec: buffer, K: number, L: number): buffer
	local OutputSize = K * 32 * L
	local Output = buffer.create(OutputSize)
	local PolySize = POLY_SIZE
	local ChunkSize = 32 * L
	
	local EncodeAt = MlKemSerialize.EncodeAt
	local Encode = MlKemSerialize.Encode
	
	if L == 12 then
		for I = 0, K - 1 do
			EncodeAt(Vec, I * PolySize, Output, I * ChunkSize, 12)
		end
	else
		local Poly = TEMP_POLY_ENCODE
		for I = 0, K - 1 do
			buffer.copy(Poly, 0, Vec, I * PolySize, PolySize)
			local EncodedPoly = Encode(Poly, L)
			buffer.copy(Output, I * ChunkSize, EncodedPoly, 0, ChunkSize)
		end
	end

	return Output
end

function PolyVec.VecDecode(Data: buffer, K: number, L: number): buffer
	local Vec = buffer.create(K * POLY_SIZE)
	local PolySize = POLY_SIZE
	local ChunkSize = 32 * L
	
	local DecodeAt = MlKemSerialize.DecodeAt
	local Decode = MlKemSerialize.Decode
	
	if L == 12 then
		for I = 0, K - 1 do
			DecodeAt(Data, I * ChunkSize, Vec, I * PolySize, 12)
		end
	else
		local PolyData = buffer.create(ChunkSize)
		for I = 0, K - 1 do
			buffer.copy(PolyData, 0, Data, I * ChunkSize, ChunkSize)
			local DecodedPoly = Decode(PolyData, L)
			buffer.copy(Vec, I * PolySize, DecodedPoly, 0, PolySize)
		end
	end

	return Vec
end

function PolyVec.VecCompress(Vec: buffer, K: number, D: number)
	local Poly = TEMP_POLY_COMPRESS
	local PolySize = POLY_SIZE

	for I = 0, K - 1 do
		local Offset = I * PolySize
		buffer.copy(Poly, 0, Vec, Offset, PolySize)
		Compression.PolyCompress(Poly, D)
		buffer.copy(Vec, Offset, Poly, 0, PolySize)
	end
end

function PolyVec.VecDecompress(Vec: buffer, K: number, D: number)
	local Poly = TEMP_POLY_COMPRESS
	local PolySize = POLY_SIZE

	for I = 0, K - 1 do
		local Offset = I * PolySize
		buffer.copy(Poly, 0, Vec, Offset, PolySize)
		Compression.PolyDecompress(Poly, D)
		buffer.copy(Vec, Offset, Poly, 0, PolySize)
	end
end

return PolyVec]]></ProtectedString>
								<string name="ScriptGuid">{251B5C83-7A84-48CD-A501-1C16C8F499BF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PolyVec</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX36361588482F4D0DB87F0AC33E6CF980">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2
--!native

local SHA3 = {}

local LOW_ROUND, HIGH_ROUND = buffer.create(96), buffer.create(96) do
	local HighFactorKeccak = 0
	local ShiftRegister = 29
	local function GetNextBit(): number
		local Result = ShiftRegister % 2
		ShiftRegister = bit32.bxor((ShiftRegister - Result) // 2, 142 * Result)

		return Result
	end

	for Index = 0, 23 do
		local LowValue = 0
		local Multiplier: number

		for _ = 1, 6 do
			Multiplier = if Multiplier then Multiplier * Multiplier * 2 else 1
			LowValue += GetNextBit() * Multiplier
		end

		local HighValue = GetNextBit() * Multiplier
		buffer.writeu32(HIGH_ROUND, Index * 4, HighValue)
		buffer.writeu32(LOW_ROUND, Index * 4, LowValue + HighValue * HighFactorKeccak)
	end
end

local LANES_LOW = buffer.create(100)
local LANES_HIGH = buffer.create(100)

local function Keccak(LanesLow: buffer, LanesHigh: buffer, InputBuffer: buffer, Offset: number, Size: number, BlockSizeInBytes: number): ()
	local QuadWordsQuantity = BlockSizeInBytes // 8
	local RCHigh, RCLow = HIGH_ROUND, LOW_ROUND

	for Position = Offset, Offset + Size - 1, BlockSizeInBytes do
		for Index = 0, (QuadWordsQuantity - 1) * 4, 4 do
			local BufferPos = Position + Index * 2

			buffer.writeu32(LanesLow, Index, bit32.bxor(
				buffer.readu32(LanesLow, Index),
				buffer.readu32(InputBuffer, BufferPos)
				))

			buffer.writeu32(LanesHigh, Index, bit32.bxor(
				buffer.readu32(LanesHigh, Index),
				buffer.readu32(InputBuffer, BufferPos + 4)
				))
		end

		local Lane01Low, Lane01High = buffer.readu32(LanesLow, 0), buffer.readu32(LanesHigh, 0)
		local Lane02Low, Lane02High = buffer.readu32(LanesLow, 4), buffer.readu32(LanesHigh, 4)
		local Lane03Low, Lane03High = buffer.readu32(LanesLow, 8), buffer.readu32(LanesHigh, 8)

		local Lane04Low, Lane04High = buffer.readu32(LanesLow, 12), buffer.readu32(LanesHigh, 12)
		local Lane05Low, Lane05High = buffer.readu32(LanesLow, 16), buffer.readu32(LanesHigh, 16)
		local Lane06Low, Lane06High = buffer.readu32(LanesLow, 20), buffer.readu32(LanesHigh, 20)

		local Lane07Low, Lane07High = buffer.readu32(LanesLow, 24), buffer.readu32(LanesHigh, 24)
		local Lane08Low, Lane08High = buffer.readu32(LanesLow, 28), buffer.readu32(LanesHigh, 28)
		local Lane09Low, Lane09High = buffer.readu32(LanesLow, 32), buffer.readu32(LanesHigh, 32)

		local Lane10Low, Lane10High = buffer.readu32(LanesLow, 36), buffer.readu32(LanesHigh, 36)
		local Lane11Low, Lane11High = buffer.readu32(LanesLow, 40), buffer.readu32(LanesHigh, 40)
		local Lane12Low, Lane12High = buffer.readu32(LanesLow, 44), buffer.readu32(LanesHigh, 44)

		local Lane13Low, Lane13High = buffer.readu32(LanesLow, 48), buffer.readu32(LanesHigh, 48)
		local Lane14Low, Lane14High = buffer.readu32(LanesLow, 52), buffer.readu32(LanesHigh, 52)
		local Lane15Low, Lane15High = buffer.readu32(LanesLow, 56), buffer.readu32(LanesHigh, 56)

		local Lane16Low, Lane16High = buffer.readu32(LanesLow, 60), buffer.readu32(LanesHigh, 60)
		local Lane17Low, Lane17High = buffer.readu32(LanesLow, 64), buffer.readu32(LanesHigh, 64)
		local Lane18Low, Lane18High = buffer.readu32(LanesLow, 68), buffer.readu32(LanesHigh, 68)

		local Lane19Low, Lane19High = buffer.readu32(LanesLow, 72), buffer.readu32(LanesHigh, 72)
		local Lane20Low, Lane20High = buffer.readu32(LanesLow, 76), buffer.readu32(LanesHigh, 76)
		local Lane21Low, Lane21High = buffer.readu32(LanesLow, 80), buffer.readu32(LanesHigh, 80)

		local Lane22Low, Lane22High = buffer.readu32(LanesLow, 84), buffer.readu32(LanesHigh, 84)
		local Lane23Low, Lane23High = buffer.readu32(LanesLow, 88), buffer.readu32(LanesHigh, 88)
		local Lane24Low, Lane24High = buffer.readu32(LanesLow, 92), buffer.readu32(LanesHigh, 92)

		local Lane25Low, Lane25High = buffer.readu32(LanesLow, 96), buffer.readu32(LanesHigh, 96)

		for RoundIndex = 0, 92, 4 do
			local Column1Low, Column1High = bit32.bxor(Lane01Low, Lane06Low, Lane11Low, Lane16Low, Lane21Low), bit32.bxor(Lane01High, Lane06High, Lane11High, Lane16High, Lane21High)
			local Column2Low, Column2High = bit32.bxor(Lane02Low, Lane07Low, Lane12Low, Lane17Low, Lane22Low), bit32.bxor(Lane02High, Lane07High, Lane12High, Lane17High, Lane22High)
			local Column3Low, Column3High = bit32.bxor(Lane03Low, Lane08Low, Lane13Low, Lane18Low, Lane23Low), bit32.bxor(Lane03High, Lane08High, Lane13High, Lane18High, Lane23High)
			local Column4Low, Column4High = bit32.bxor(Lane04Low, Lane09Low, Lane14Low, Lane19Low, Lane24Low), bit32.bxor(Lane04High, Lane09High, Lane14High, Lane19High, Lane24High)
			local Column5Low, Column5High = bit32.bxor(Lane05Low, Lane10Low, Lane15Low, Lane20Low, Lane25Low), bit32.bxor(Lane05High, Lane10High, Lane15High, Lane20High, Lane25High)

			local DeltaLow, DeltaHigh = bit32.bxor(Column1Low, Column3Low * 2 + Column3High // 2147483648), bit32.bxor(Column1High, Column3High * 2 + Column3Low // 2147483648)
			local Temp0Low, Temp0High = bit32.bxor(DeltaLow, Lane02Low), bit32.bxor(DeltaHigh, Lane02High)
			local Temp1Low, Temp1High = bit32.bxor(DeltaLow, Lane07Low), bit32.bxor(DeltaHigh, Lane07High)
			local Temp2Low, Temp2High = bit32.bxor(DeltaLow, Lane12Low), bit32.bxor(DeltaHigh, Lane12High)
			local Temp3Low, Temp3High = bit32.bxor(DeltaLow, Lane17Low), bit32.bxor(DeltaHigh, Lane17High)
			local Temp4Low, Temp4High = bit32.bxor(DeltaLow, Lane22Low), bit32.bxor(DeltaHigh, Lane22High)

			Lane02Low = Temp1Low // 1048576 + (Temp1High * 4096); Lane02High = Temp1High // 1048576 + (Temp1Low * 4096)
			Lane07Low = Temp3Low // 524288 + (Temp3High * 8192); Lane07High = Temp3High // 524288 + (Temp3Low * 8192)
			Lane12Low = Temp0Low * 2 + Temp0High // 2147483648; Lane12High = Temp0High * 2 + Temp0Low // 2147483648
			Lane17Low = Temp2Low * 1024 + Temp2High // 4194304; Lane17High = Temp2High * 1024 + Temp2Low // 4194304
			Lane22Low = Temp4Low * 4 + Temp4High // 1073741824; Lane22High = Temp4High * 4 + Temp4Low // 1073741824

			DeltaLow = bit32.bxor(Column2Low, Column4Low * 2 + Column4High // 2147483648); DeltaHigh = bit32.bxor(Column2High, Column4High * 2 + Column4Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane03Low); Temp0High = bit32.bxor(DeltaHigh, Lane03High)
			Temp1Low = bit32.bxor(DeltaLow, Lane08Low); Temp1High = bit32.bxor(DeltaHigh, Lane08High)
			Temp2Low = bit32.bxor(DeltaLow, Lane13Low); Temp2High = bit32.bxor(DeltaHigh, Lane13High)
			Temp3Low = bit32.bxor(DeltaLow, Lane18Low); Temp3High = bit32.bxor(DeltaHigh, Lane18High)
			Temp4Low = bit32.bxor(DeltaLow, Lane23Low); Temp4High = bit32.bxor(DeltaHigh, Lane23High)

			Lane03Low = Temp2Low // 2097152 + (Temp2High * 2048); Lane03High = Temp2High // 2097152 + (Temp2Low * 2048)
			Lane08Low = Temp4Low // 8 + bit32.bor(Temp4High * 536870912, 0); Lane08High = Temp4High // 8 + bit32.bor(Temp4Low * 536870912, 0)
			Lane13Low = Temp1Low * 64 + Temp1High // 67108864; Lane13High = Temp1High * 64 + Temp1Low // 67108864
			Lane18Low = (Temp3Low * 32768) + Temp3High // 131072; Lane18High = (Temp3High * 32768) + Temp3Low // 131072
			Lane23Low = Temp0Low // 4 + bit32.bor(Temp0High * 1073741824, 0); Lane23High = Temp0High // 4 + bit32.bor(Temp0Low * 1073741824, 0)

			DeltaLow = bit32.bxor(Column3Low, Column5Low * 2 + Column5High // 2147483648); DeltaHigh = bit32.bxor(Column3High, Column5High * 2 + Column5Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane04Low); Temp0High = bit32.bxor(DeltaHigh, Lane04High)
			Temp1Low = bit32.bxor(DeltaLow, Lane09Low); Temp1High = bit32.bxor(DeltaHigh, Lane09High)
			Temp2Low = bit32.bxor(DeltaLow, Lane14Low); Temp2High = bit32.bxor(DeltaHigh, Lane14High)
			Temp3Low = bit32.bxor(DeltaLow, Lane19Low); Temp3High = bit32.bxor(DeltaHigh, Lane19High)
			Temp4Low = bit32.bxor(DeltaLow, Lane24Low); Temp4High = bit32.bxor(DeltaHigh, Lane24High)

			Lane04Low = bit32.bor(Temp3Low * 2097152, 0) + Temp3High // 2048; Lane04High = bit32.bor(Temp3High * 2097152, 0) + Temp3Low // 2048
			Lane09Low = bit32.bor(Temp0Low * 268435456, 0) + Temp0High // 16; Lane09High = bit32.bor(Temp0High * 268435456, 0) + Temp0Low // 16
			Lane14Low = bit32.bor(Temp2Low * 33554432, 0) + Temp2High // 128; Lane14High = bit32.bor(Temp2High * 33554432, 0) + Temp2Low // 128
			Lane19Low = Temp4Low // 256 + bit32.bor(Temp4High * 16777216, 0); Lane19High = Temp4High // 256 + bit32.bor(Temp4Low * 16777216, 0)
			Lane24Low = Temp1Low // 512 + bit32.bor(Temp1High * 8388608, 0); Lane24High = Temp1High // 512 + bit32.bor(Temp1Low * 8388608, 0)
			DeltaLow = bit32.bxor(Column4Low, Column1Low * 2 + Column1High // 2147483648); DeltaHigh = bit32.bxor(Column4High, Column1High * 2 + Column1Low // 2147483648)

			Temp0Low = bit32.bxor(DeltaLow, Lane05Low); Temp0High = bit32.bxor(DeltaHigh, Lane05High)
			Temp1Low = bit32.bxor(DeltaLow, Lane10Low); Temp1High = bit32.bxor(DeltaHigh, Lane10High)
			Temp2Low = bit32.bxor(DeltaLow, Lane15Low); Temp2High = bit32.bxor(DeltaHigh, Lane15High)
			Temp3Low = bit32.bxor(DeltaLow, Lane20Low); Temp3High = bit32.bxor(DeltaHigh, Lane20High)
			Temp4Low = bit32.bxor(DeltaLow, Lane25Low); Temp4High = bit32.bxor(DeltaHigh, Lane25High)

			Lane05Low = (Temp4Low * 16384) + Temp4High // 262144; Lane05High = (Temp4High * 16384) + Temp4Low // 262144
			Lane10Low = bit32.bor(Temp1Low * 1048576, 0) + Temp1High // 4096; Lane10High = bit32.bor(Temp1High * 1048576, 0) + Temp1Low // 4096
			Lane15Low = Temp3Low * 256 + Temp3High // 16777216; Lane15High = Temp3High * 256 + Temp3Low // 16777216
			Lane20Low = bit32.bor(Temp0Low * 134217728, 0) + Temp0High // 32; Lane20High = bit32.bor(Temp0High * 134217728, 0) + Temp0Low // 32
			Lane25Low = Temp2Low // 33554432 + Temp2High * 128; Lane25High = Temp2High // 33554432 + Temp2Low * 128

			DeltaLow = bit32.bxor(Column5Low, Column2Low * 2 + Column2High // 2147483648); DeltaHigh = bit32.bxor(Column5High, Column2High * 2 + Column2Low // 2147483648)
			Temp1Low = bit32.bxor(DeltaLow, Lane06Low); Temp1High = bit32.bxor(DeltaHigh, Lane06High)
			Temp2Low = bit32.bxor(DeltaLow, Lane11Low); Temp2High = bit32.bxor(DeltaHigh, Lane11High)
			Temp3Low = bit32.bxor(DeltaLow, Lane16Low); Temp3High = bit32.bxor(DeltaHigh, Lane16High)
			Temp4Low = bit32.bxor(DeltaLow, Lane21Low); Temp4High = bit32.bxor(DeltaHigh, Lane21High)
			Lane06Low = Temp2Low * 8 + Temp2High // 536870912; Lane06High = Temp2High * 8 + Temp2Low // 536870912
			Lane11Low = (Temp4Low * 262144) + Temp4High // 16384; Lane11High = (Temp4High * 262144) + Temp4Low // 16384
			Lane16Low = Temp1Low // 268435456 + Temp1High * 16; Lane16High = Temp1High // 268435456 + Temp1Low * 16
			Lane21Low = Temp3Low // 8388608 + Temp3High * 512; Lane21High = Temp3High // 8388608 + Temp3Low * 512
			Lane01Low = bit32.bxor(DeltaLow, Lane01Low); Lane01High = bit32.bxor(DeltaHigh, Lane01High)

			Lane01Low, Lane02Low, Lane03Low, Lane04Low, Lane05Low = bit32.bxor(Lane01Low, bit32.band(-1 - Lane02Low, Lane03Low)), bit32.bxor(Lane02Low, bit32.band(-1 - Lane03Low, Lane04Low)), bit32.bxor(Lane03Low, bit32.band(-1 - Lane04Low, Lane05Low)), bit32.bxor(Lane04Low, bit32.band(-1 - Lane05Low, Lane01Low)), bit32.bxor(Lane05Low, bit32.band(-1 - Lane01Low, Lane02Low)) :: number
			Lane01High, Lane02High, Lane03High, Lane04High, Lane05High = bit32.bxor(Lane01High, bit32.band(-1 - Lane02High, Lane03High)), bit32.bxor(Lane02High, bit32.band(-1 - Lane03High, Lane04High)), bit32.bxor(Lane03High, bit32.band(-1 - Lane04High, Lane05High)), bit32.bxor(Lane04High, bit32.band(-1 - Lane05High, Lane01High)), bit32.bxor(Lane05High, bit32.band(-1 - Lane01High, Lane02High)) :: number
			Lane06Low, Lane07Low, Lane08Low, Lane09Low, Lane10Low = bit32.bxor(Lane09Low, bit32.band(-1 - Lane10Low, Lane06Low)), bit32.bxor(Lane10Low, bit32.band(-1 - Lane06Low, Lane07Low)), bit32.bxor(Lane06Low, bit32.band(-1 - Lane07Low, Lane08Low)), bit32.bxor(Lane07Low, bit32.band(-1 - Lane08Low, Lane09Low)), bit32.bxor(Lane08Low, bit32.band(-1 - Lane09Low, Lane10Low)) :: number
			Lane06High, Lane07High, Lane08High, Lane09High, Lane10High = bit32.bxor(Lane09High, bit32.band(-1 - Lane10High, Lane06High)), bit32.bxor(Lane10High, bit32.band(-1 - Lane06High, Lane07High)), bit32.bxor(Lane06High, bit32.band(-1 - Lane07High, Lane08High)), bit32.bxor(Lane07High, bit32.band(-1 - Lane08High, Lane09High)), bit32.bxor(Lane08High, bit32.band(-1 - Lane09High, Lane10High)) :: number
			Lane11Low, Lane12Low, Lane13Low, Lane14Low, Lane15Low = bit32.bxor(Lane12Low, bit32.band(-1 - Lane13Low, Lane14Low)), bit32.bxor(Lane13Low, bit32.band(-1 - Lane14Low, Lane15Low)), bit32.bxor(Lane14Low, bit32.band(-1 - Lane15Low, Lane11Low)), bit32.bxor(Lane15Low, bit32.band(-1 - Lane11Low, Lane12Low)), bit32.bxor(Lane11Low, bit32.band(-1 - Lane12Low, Lane13Low)) :: number
			Lane11High, Lane12High, Lane13High, Lane14High, Lane15High = bit32.bxor(Lane12High, bit32.band(-1 - Lane13High, Lane14High)), bit32.bxor(Lane13High, bit32.band(-1 - Lane14High, Lane15High)), bit32.bxor(Lane14High, bit32.band(-1 - Lane15High, Lane11High)), bit32.bxor(Lane15High, bit32.band(-1 - Lane11High, Lane12High)), bit32.bxor(Lane11High, bit32.band(-1 - Lane12High, Lane13High)) :: number
			Lane16Low, Lane17Low, Lane18Low, Lane19Low, Lane20Low = bit32.bxor(Lane20Low, bit32.band(-1 - Lane16Low, Lane17Low)), bit32.bxor(Lane16Low, bit32.band(-1 - Lane17Low, Lane18Low)), bit32.bxor(Lane17Low, bit32.band(-1 - Lane18Low, Lane19Low)), bit32.bxor(Lane18Low, bit32.band(-1 - Lane19Low, Lane20Low)), bit32.bxor(Lane19Low, bit32.band(-1 - Lane20Low, Lane16Low)) :: number
			Lane16High, Lane17High, Lane18High, Lane19High, Lane20High = bit32.bxor(Lane20High, bit32.band(-1 - Lane16High, Lane17High)), bit32.bxor(Lane16High, bit32.band(-1 - Lane17High, Lane18High)), bit32.bxor(Lane17High, bit32.band(-1 - Lane18High, Lane19High)), bit32.bxor(Lane18High, bit32.band(-1 - Lane19High, Lane20High)), bit32.bxor(Lane19High, bit32.band(-1 - Lane20High, Lane16High)) :: number
			Lane21Low, Lane22Low, Lane23Low, Lane24Low, Lane25Low = bit32.bxor(Lane23Low, bit32.band(-1 - Lane24Low, Lane25Low)), bit32.bxor(Lane24Low, bit32.band(-1 - Lane25Low, Lane21Low)), bit32.bxor(Lane25Low, bit32.band(-1 - Lane21Low, Lane22Low)), bit32.bxor(Lane21Low, bit32.band(-1 - Lane22Low, Lane23Low)), bit32.bxor(Lane22Low, bit32.band(-1 - Lane23Low, Lane24Low)) :: number
			Lane21High, Lane22High, Lane23High, Lane24High, Lane25High = bit32.bxor(Lane23High, bit32.band(-1 - Lane24High, Lane25High)), bit32.bxor(Lane24High, bit32.band(-1 - Lane25High, Lane21High)), bit32.bxor(Lane25High, bit32.band(-1 - Lane21High, Lane22High)), bit32.bxor(Lane21High, bit32.band(-1 - Lane22High, Lane23High)), bit32.bxor(Lane22High, bit32.band(-1 - Lane23High, Lane24High)) :: number

			Lane01Low = bit32.bxor(Lane01Low, buffer.readu32(RCLow, RoundIndex))
			Lane01High = bit32.bxor(Lane01High, buffer.readu32(RCHigh, RoundIndex))
		end

		buffer.writeu32(LanesLow, 0, Lane01Low); buffer.writeu32(LanesHigh, 0, Lane01High)
		buffer.writeu32(LanesLow, 4, Lane02Low); buffer.writeu32(LanesHigh, 4, Lane02High)
		buffer.writeu32(LanesLow, 8, Lane03Low); buffer.writeu32(LanesHigh, 8, Lane03High)
		buffer.writeu32(LanesLow, 12, Lane04Low); buffer.writeu32(LanesHigh, 12, Lane04High)
		buffer.writeu32(LanesLow, 16, Lane05Low); buffer.writeu32(LanesHigh, 16, Lane05High)
		buffer.writeu32(LanesLow, 20, Lane06Low); buffer.writeu32(LanesHigh, 20, Lane06High)
		buffer.writeu32(LanesLow, 24, Lane07Low); buffer.writeu32(LanesHigh, 24, Lane07High)
		buffer.writeu32(LanesLow, 28, Lane08Low); buffer.writeu32(LanesHigh, 28, Lane08High)
		buffer.writeu32(LanesLow, 32, Lane09Low); buffer.writeu32(LanesHigh, 32, Lane09High)
		buffer.writeu32(LanesLow, 36, Lane10Low); buffer.writeu32(LanesHigh, 36, Lane10High)
		buffer.writeu32(LanesLow, 40, Lane11Low); buffer.writeu32(LanesHigh, 40, Lane11High)
		buffer.writeu32(LanesLow, 44, Lane12Low); buffer.writeu32(LanesHigh, 44, Lane12High)
		buffer.writeu32(LanesLow, 48, Lane13Low); buffer.writeu32(LanesHigh, 48, Lane13High)
		buffer.writeu32(LanesLow, 52, Lane14Low); buffer.writeu32(LanesHigh, 52, Lane14High)
		buffer.writeu32(LanesLow, 56, Lane15Low); buffer.writeu32(LanesHigh, 56, Lane15High)
		buffer.writeu32(LanesLow, 60, Lane16Low); buffer.writeu32(LanesHigh, 60, Lane16High)
		buffer.writeu32(LanesLow, 64, Lane17Low); buffer.writeu32(LanesHigh, 64, Lane17High)
		buffer.writeu32(LanesLow, 68, Lane18Low); buffer.writeu32(LanesHigh, 68, Lane18High)
		buffer.writeu32(LanesLow, 72, Lane19Low); buffer.writeu32(LanesHigh, 72, Lane19High)
		buffer.writeu32(LanesLow, 76, Lane20Low); buffer.writeu32(LanesHigh, 76, Lane20High)
		buffer.writeu32(LanesLow, 80, Lane21Low); buffer.writeu32(LanesHigh, 80, Lane21High)
		buffer.writeu32(LanesLow, 84, Lane22Low); buffer.writeu32(LanesHigh, 84, Lane22High)
		buffer.writeu32(LanesLow, 88, Lane23Low); buffer.writeu32(LanesHigh, 88, Lane23High)
		buffer.writeu32(LanesLow, 92, Lane24Low); buffer.writeu32(LanesHigh, 92, Lane24High)
		buffer.writeu32(LanesLow, 96, Lane25Low); buffer.writeu32(LanesHigh, 96, Lane25High)
	end
end

local function ProcessSponge(Message: buffer, CapacityBits: number, OutputBytes: number, DomainSeparator: number): buffer
	local RateBytes = (1600 - CapacityBits) // 8
	buffer.fill(LANES_LOW, 0, 0, 100)
	buffer.fill(LANES_HIGH, 0, 0, 100)

	local LanesLow = LANES_LOW
	local LanesHigh = LANES_HIGH

	local MessageLength: number = buffer.len(Message)
	local PaddedLength: number = MessageLength + 1

	local Remainder = PaddedLength % RateBytes
	if Remainder ~= 0 then
		PaddedLength += (RateBytes - Remainder)
	end

	local PaddedMessage = buffer.create(PaddedLength)

	if MessageLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
	end

	if PaddedLength - MessageLength == 1 then
		buffer.writeu8(PaddedMessage, MessageLength, bit32.bor(DomainSeparator, 0x80))
	else
		buffer.writeu8(PaddedMessage, MessageLength, DomainSeparator)
		if PaddedLength - MessageLength > 2 then
			buffer.fill(PaddedMessage, MessageLength + 1, 0, PaddedLength - MessageLength - 2)
		end
		buffer.writeu8(PaddedMessage, PaddedLength - 1, 0x80)
	end

	Keccak(LanesLow, LanesHigh, PaddedMessage, 0, PaddedLength, RateBytes)

	local Output = buffer.create(OutputBytes)
	local OutputOffset = 0

	local ZeroBuffer = buffer.create(RateBytes)
	while OutputOffset < OutputBytes do
		local BytesThisRound = math.min(RateBytes, OutputBytes - OutputOffset)

		for ByteIndex = 0, BytesThisRound - 1 do
			local AbsoluteIndex = OutputOffset + ByteIndex
			if AbsoluteIndex < OutputBytes then
				local Lane = ByteIndex // 8
				local ByteInLane = ByteIndex % 8
				local LaneOffset = Lane * 4

				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), ByteInLane * 8, 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), (ByteInLane - 4) * 8, 8)
				end
				buffer.writeu8(Output, AbsoluteIndex, Value)
			end
		end

		OutputOffset += BytesThisRound

		if OutputOffset < OutputBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
		end
	end

	return Output
end

function SHA3.SHA3_256(Message: buffer): buffer
	return ProcessSponge(Message, 512, 32, 0x06)
end

function SHA3.SHA3_512(Message: buffer): buffer
	return ProcessSponge(Message, 1024, 64, 0x06)
end

function SHA3.SHAKE256(Message: buffer, OutputBytes: number): buffer
	return ProcessSponge(Message, 512, OutputBytes, 0x1F)
end

return SHA3]]></ProtectedString>
								<string name="ScriptGuid">{A2703E18-E301-4BF3-9929-CDB4221168FD}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SHA3</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX85BE31FC5D69494CBADEBF5BD508221D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Sampling Module
	
	Polynomial sampling operations for ML-KEM.
	 Uniform sampling from Rq and centered binomial distribution sampling.
	
	Example usage:
		local Sampling = require(script.Sampling)
		
		local Rho = buffer.create(32)
		local Matrix = Sampling.GenerateMatrix(3, Rho, false)
		
		local Sigma = buffer.create(32)
		local Vector = Sampling.GenerateVector(3, 2, Sigma, 0)
		
		local PrfOutput = buffer.create(128)
		local NoisePoly = Sampling.SamplePolyCbd(PrfOutput, 2)
--]=]

--!strict
--!optimize 2
--!native

local PolyVec = require("./PolyVec")
local MlKemParams = require("./Params")
local SHA3 = require("./SHA3")
local XOF = require("./XOF")

local LOG2N = 8
local N = 2^LOG2N
local POLY_SIZE = N * 2 

local Q = 13 * 256 + 1

local SAMPLE_NTT_CHUNK = buffer.create(168)
local SAMPLE_NTT_POLY = buffer.create(N * 2)
local GEN_VECTOR_PRF_OUTPUT = buffer.create(192)
local GEN_VECTOR_PRF_INPUT = buffer.create(33)

local function SamplePolyCbd2(Prf: buffer, Poly: buffer, Offset: number?)
	local BaseOffset = Offset or 0
	local Mask2 = 0x03
	local Modulus = Q

	for I = 0, 127 do
		local PolyOffset = I * 2
		local Word = buffer.readu8(Prf, I)

		local T0 = bit32.band(Word, 0x55)
		local T1 = bit32.band(bit32.rshift(Word, 1), 0x55)
		local T2 = T0 + T1

		local A0 = bit32.band(T2, Mask2)
		local B0 = bit32.band(bit32.rshift(T2, 2), Mask2)
		local Diff0 = A0 - B0
		local Coeff0 = if Diff0 < 0 then Diff0 + Modulus else Diff0

		local A1 = bit32.band(bit32.rshift(T2, 4), Mask2)
		local B1 = bit32.band(bit32.rshift(T2, 6), Mask2)
		local Diff1 = A1 - B1
		local Coeff1 = if Diff1 < 0 then Diff1 + Modulus else Diff1

		buffer.writeu16(Poly, BaseOffset + PolyOffset * 2, Coeff0)
		buffer.writeu16(Poly, BaseOffset + (PolyOffset + 1) * 2, Coeff1)
	end
end

local function SamplePolyCbd3(Prf: buffer, Poly: buffer, Offset: number?)
	local BaseOffset = Offset or 0
	local Mask24 = 0x249249
	local Mask3 = 0x07
	local Modulus = Q

	for I = 0, 63 do
		local ByteOffset = I * 3
		local PolyOffset = I * 4

		local B0 = buffer.readu8(Prf, ByteOffset)
		local B1 = buffer.readu8(Prf, ByteOffset + 1)
		local B2 = buffer.readu8(Prf, ByteOffset + 2)
		local Word = bit32.bor(B0, bit32.lshift(B1, 8), bit32.lshift(B2, 16))

		local T0 = bit32.band(Word, Mask24)
		local T1 = bit32.band(bit32.rshift(Word, 1), Mask24)
		local T2 = bit32.band(bit32.rshift(Word, 2), Mask24)
		local T3 = T0 + T1 + T2

		for J = 0, 3 do
			local JOffset = J * 6
			local A = bit32.band(bit32.rshift(T3, JOffset), Mask3)
			local B = bit32.band(bit32.rshift(T3, JOffset + 3), Mask3)
			local Diff = A - B
			local Coeff = if Diff < 0 then Diff + Modulus else Diff

			buffer.writeu16(Poly, BaseOffset + (PolyOffset + J) * 2, Coeff)
		end
	end
end

local function SampleNtt(XofInput: buffer, Poly: buffer)
	local CoeffIndex = 0
	local Chunk = SAMPLE_NTT_CHUNK

	XOF.Reset128()
	XOF.Absorb128(XofInput)

	while CoeffIndex < N do
		XOF.Squeeze128Into(Chunk, 168, 0)
		local Offset = 0

		while Offset + 2 < 168 and CoeffIndex < N do
			local B0 = buffer.readu8(Chunk, Offset)
			local B1 = buffer.readu8(Chunk, Offset + 1)
			local B2 = buffer.readu8(Chunk, Offset + 2)

			local D1 = bit32.bor(B0, bit32.lshift(bit32.band(B1, 0x0F), 8))
			local D2 = bit32.bor(bit32.rshift(B1, 4), bit32.lshift(B2, 4))

			if D1 < Q then
				buffer.writeu16(Poly, CoeffIndex * 2, D1)
				CoeffIndex += 1
			end

			if D2 < Q and CoeffIndex < N then
				buffer.writeu16(Poly, CoeffIndex * 2, D2)
				CoeffIndex += 1
			end

			Offset += 3
		end
	end
end

local Sampling = {}

function Sampling.GenerateMatrix(K: number, Rho: buffer, Transpose: boolean): buffer
	local Matrix = PolyVec.MatCreate(K, K)
	local XofInput = buffer.create(34)
	buffer.copy(XofInput, 0, Rho, 0, 32)

	local PolySize = POLY_SIZE
	local Poly = SAMPLE_NTT_POLY
	local Sample = SampleNtt

	for I = 0, K - 1 do
		for J = 0, K - 1 do
			if Transpose then
				buffer.writeu8(XofInput, 32, I)
				buffer.writeu8(XofInput, 33, J)
			else
				buffer.writeu8(XofInput, 32, J)
				buffer.writeu8(XofInput, 33, I)
			end

			Sample(XofInput, Poly)
			local Index = (I * K + J) * PolySize
			buffer.copy(Matrix, Index, Poly, 0, PolySize)
		end
	end

	return Matrix
end

function Sampling.SamplePolyCbd(Prf: buffer, Eta: number): buffer
	local Poly = buffer.create(N * 2)

	if Eta == 2 then
		SamplePolyCbd2(Prf, Poly, 0)
	else
		SamplePolyCbd3(Prf, Poly, 0)
	end

	return Poly
end

function Sampling.GenerateVector(K: number, Eta: number, Sigma: buffer, Nonce: number): buffer
	local Vec = PolyVec.VecCreate(K)
	local PrfInput = GEN_VECTOR_PRF_INPUT
	local PrfOutput = GEN_VECTOR_PRF_OUTPUT
	buffer.copy(PrfInput, 0, Sigma, 0, 32)

	local PolySize = POLY_SIZE
	local PrfLen = 64 * Eta

	for I = 0, K - 1 do
		buffer.writeu8(PrfInput, 32, Nonce + I)

		XOF.Reset256()
		XOF.Absorb256(PrfInput)
		XOF.Squeeze256Into(PrfOutput, PrfLen, 0)

		local Offset = I * PolySize
		if Eta == 2 then
			SamplePolyCbd2(PrfOutput, Vec, Offset)
		else
			SamplePolyCbd3(PrfOutput, Vec, Offset)
		end
	end

	return Vec
end

function Sampling.GenerateNoisePoly(Eta: number, Sigma: buffer, Nonce: number): buffer
	if not MlKemParams.CheckEta(Eta) then
		error("Invalid eta parameter")
	end
	if buffer.len(Sigma) ~= 32 then
		error("Sigma must be 32 bytes")
	end

	local PrfInput = buffer.create(33)
	buffer.copy(PrfInput, 0, Sigma, 0, 32)
	buffer.writeu8(PrfInput, 32, Nonce)

	local PrfOutput = SHA3.SHAKE256(PrfInput, 64 * Eta)
	return Sampling.SamplePolyCbd(PrfOutput, Eta)
end

return Sampling]]></ProtectedString>
								<string name="ScriptGuid">{C4459F73-F7BD-4EA4-B141-36ECF38F0A2C}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Sampling</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX773BE0A82C0D4D9D95837CE19D48450B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Serialization Module
	
	Polynomial encoding and decoding operations for ML-KEM.
	Converts polynomials to/from byte arrays with different bit lengths.
		
	Example usage:
		local Serialize = require(script.Serialize)
		
		local Poly = buffer.create(512) -- 256 coefficients
		local Encoded = Serialize.Encode(Poly, 12)
		local Decoded = Serialize.Decode(Encoded, 12)
--]=]

--!strict
--!optimize 2
--!native

local Params = require("./Params")

local LOG2N = 8
local N = 2^LOG2N

local Serialize = {}

function Serialize.Encode(Poly: buffer, L: number): buffer
	if not Params.CheckL(L) then
		error("Invalid encoding parameter l")
	end

	local OutputSize = 32 * L
	local Output = buffer.create(OutputSize)

	if L == 1 then
		local IterCount = N / 8

		for I = 0, IterCount - 1 do
			local Offset = I * 8
			local Byte = 0

			for J = 0, 7 do
				local Coeff = buffer.readu16(Poly, (Offset + J) * 2)
				local Bit = bit32.band(Coeff, 1)
				Byte = bit32.bor(Byte, bit32.lshift(Bit, J))
			end

			buffer.writeu8(Output, I, Byte)
		end

	elseif L == 4 then
		local IterCount = N / 2

		for I = 0, IterCount - 1 do
			local Offset = I * 2
			local C0 = bit32.band(buffer.readu16(Poly, Offset * 2), 0xF)
			local C1 = bit32.band(buffer.readu16(Poly, (Offset + 1) * 2), 0xF)

			local Byte = bit32.bor(C0, bit32.lshift(C1, 4))
			buffer.writeu8(Output, I, Byte)
		end

	elseif L == 5 then
		local IterCount = N / 8

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 8
			local ByteOffset = I * 5

			local T0 = buffer.readu16(Poly, (PolyOffset + 0) * 2)
			local T1 = buffer.readu16(Poly, (PolyOffset + 1) * 2)
			local T2 = buffer.readu16(Poly, (PolyOffset + 2) * 2)
			local T3 = buffer.readu16(Poly, (PolyOffset + 3) * 2)
			local T4 = buffer.readu16(Poly, (PolyOffset + 4) * 2)
			local T5 = buffer.readu16(Poly, (PolyOffset + 5) * 2)
			local T6 = buffer.readu16(Poly, (PolyOffset + 6) * 2)
			local T7 = buffer.readu16(Poly, (PolyOffset + 7) * 2)

			buffer.writeu8(Output, ByteOffset + 0, bit32.bor(bit32.band(T0, 0x1F), bit32.lshift(bit32.band(T1, 0x07), 5)))
			buffer.writeu8(Output, ByteOffset + 1, bit32.bor(bit32.rshift(T1, 3), bit32.lshift(bit32.band(T2, 0x1F), 2), bit32.lshift(bit32.band(T3, 0x01), 7)))
			buffer.writeu8(Output, ByteOffset + 2, bit32.bor(bit32.rshift(T3, 1), bit32.lshift(bit32.band(T4, 0x0F), 4)))
			buffer.writeu8(Output, ByteOffset + 3, bit32.bor(bit32.rshift(T4, 4), bit32.lshift(bit32.band(T5, 0x1F), 1), bit32.lshift(bit32.band(T6, 0x03), 6)))
			buffer.writeu8(Output, ByteOffset + 4, bit32.bor(bit32.rshift(T6, 2), bit32.lshift(bit32.band(T7, 0x1F), 3)))
		end

	elseif L == 10 then
		local IterCount = N / 4

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 4
			local ByteOffset = I * 5

			local T0 = buffer.readu16(Poly, (PolyOffset + 0) * 2)
			local T1 = buffer.readu16(Poly, (PolyOffset + 1) * 2)
			local T2 = buffer.readu16(Poly, (PolyOffset + 2) * 2)
			local T3 = buffer.readu16(Poly, (PolyOffset + 3) * 2)

			buffer.writeu8(Output, ByteOffset + 0, bit32.band(T0, 0xFF))
			buffer.writeu8(Output, ByteOffset + 1, bit32.bor(bit32.rshift(T0, 8), bit32.lshift(bit32.band(T1, 0x3F), 2)))
			buffer.writeu8(Output, ByteOffset + 2, bit32.bor(bit32.rshift(T1, 6), bit32.lshift(bit32.band(T2, 0x0F), 4)))
			buffer.writeu8(Output, ByteOffset + 3, bit32.bor(bit32.rshift(T2, 4), bit32.lshift(bit32.band(T3, 0x03), 6)))
			buffer.writeu8(Output, ByteOffset + 4, bit32.rshift(T3, 2))
		end

	elseif L == 11 then
		local IterCount = N / 8

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 8
			local ByteOffset = I * 11

			local T0 = buffer.readu16(Poly, (PolyOffset + 0) * 2)
			local T1 = buffer.readu16(Poly, (PolyOffset + 1) * 2)
			local T2 = buffer.readu16(Poly, (PolyOffset + 2) * 2)
			local T3 = buffer.readu16(Poly, (PolyOffset + 3) * 2)
			local T4 = buffer.readu16(Poly, (PolyOffset + 4) * 2)
			local T5 = buffer.readu16(Poly, (PolyOffset + 5) * 2)
			local T6 = buffer.readu16(Poly, (PolyOffset + 6) * 2)
			local T7 = buffer.readu16(Poly, (PolyOffset + 7) * 2)

			buffer.writeu8(Output, ByteOffset + 0, bit32.band(T0, 0xFF))
			buffer.writeu8(Output, ByteOffset + 1, bit32.bor(bit32.rshift(T0, 8), bit32.lshift(bit32.band(T1, 0x1F), 3)))
			buffer.writeu8(Output, ByteOffset + 2, bit32.bor(bit32.rshift(T1, 5), bit32.lshift(bit32.band(T2, 0x03), 6)))
			buffer.writeu8(Output, ByteOffset + 3, bit32.rshift(T2, 2))
			buffer.writeu8(Output, ByteOffset + 4, bit32.bor(bit32.rshift(T2, 10), bit32.lshift(bit32.band(T3, 0x7F), 1)))
			buffer.writeu8(Output, ByteOffset + 5, bit32.bor(bit32.rshift(T3, 7), bit32.lshift(bit32.band(T4, 0x0F), 4)))
			buffer.writeu8(Output, ByteOffset + 6, bit32.bor(bit32.rshift(T4, 4), bit32.lshift(bit32.band(T5, 0x01), 7)))
			buffer.writeu8(Output, ByteOffset + 7, bit32.rshift(T5, 1))
			buffer.writeu8(Output, ByteOffset + 8, bit32.bor(bit32.rshift(T5, 9), bit32.lshift(bit32.band(T6, 0x3F), 2)))
			buffer.writeu8(Output, ByteOffset + 9, bit32.bor(bit32.rshift(T6, 6), bit32.lshift(bit32.band(T7, 0x07), 5)))
			buffer.writeu8(Output, ByteOffset + 10, bit32.rshift(T7, 3))
		end
	else 
		local IterCount = N / 2

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 2
			local ByteOffset = I * 3

			local T0 = buffer.readu16(Poly, (PolyOffset + 0) * 2)
			local T1 = buffer.readu16(Poly, (PolyOffset + 1) * 2)

			buffer.writeu8(Output, ByteOffset + 0, bit32.band(T0, 0xFF))
			buffer.writeu8(Output, ByteOffset + 1, bit32.bor(bit32.rshift(T0, 8), bit32.lshift(bit32.band(T1, 0x0F), 4)))
			buffer.writeu8(Output, ByteOffset + 2, bit32.rshift(T1, 4))
		end
	end

	return Output
end

function Serialize.EncodeAt(Poly: buffer, PolyOffset: number, Output: buffer, OutOffset: number, L: number)
	if L == 12 then
		for I = 0, 127 do
			local PolyIdx = PolyOffset + I * 4
			local ByteIdx = OutOffset + I * 3

			local T0 = buffer.readu16(Poly, PolyIdx)
			local T1 = buffer.readu16(Poly, PolyIdx + 2)

			buffer.writeu8(Output, ByteIdx, bit32.band(T0, 0xFF))
			buffer.writeu8(Output, ByteIdx + 1, bit32.bor(bit32.rshift(T0, 8), bit32.lshift(bit32.band(T1, 0x0F), 4)))
			buffer.writeu8(Output, ByteIdx + 2, bit32.rshift(T1, 4))
		end
	end
end

function Serialize.Decode(Data: buffer, L: number): buffer
	if not Params.CheckL(L) then
		error("Invalid encoding parameter l")
	end

	local Poly = buffer.create(N * 2)
	if L == 1 then
		local IterCount = N / 8

		for I = 0, IterCount - 1 do
			local Byte = buffer.readu8(Data, I)
			local Offset = I * 8

			for J = 0, 7 do
				local Bit = bit32.band(bit32.rshift(Byte, J), 1)
				buffer.writeu16(Poly, (Offset + J) * 2, Bit)
			end
		end

	elseif L == 4 then
		local IterCount = N / 2

		for I = 0, IterCount - 1 do
			local Byte = buffer.readu8(Data, I)
			local Offset = I * 2

			buffer.writeu16(Poly, (Offset + 0) * 2, bit32.band(Byte, 0x0F))
			buffer.writeu16(Poly, (Offset + 1) * 2, bit32.rshift(Byte, 4))
		end

	elseif L == 5 then
		local IterCount = N / 8

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 8
			local ByteOffset = I * 5

			local B0 = buffer.readu8(Data, ByteOffset + 0)
			local B1 = buffer.readu8(Data, ByteOffset + 1)
			local B2 = buffer.readu8(Data, ByteOffset + 2)
			local B3 = buffer.readu8(Data, ByteOffset + 3)
			local B4 = buffer.readu8(Data, ByteOffset + 4)

			local T0 = bit32.band(B0, 0x1F)
			local T1 = bit32.bor(bit32.rshift(B0, 5), bit32.lshift(bit32.band(B1, 0x03), 3))
			local T2 = bit32.band(bit32.rshift(B1, 2), 0x1F)
			local T3 = bit32.bor(bit32.rshift(B1, 7), bit32.lshift(bit32.band(B2, 0x0F), 1))
			local T4 = bit32.bor(bit32.rshift(B2, 4), bit32.lshift(bit32.band(B3, 0x01), 4))
			local T5 = bit32.band(bit32.rshift(B3, 1), 0x1F)
			local T6 = bit32.bor(bit32.rshift(B3, 6), bit32.lshift(bit32.band(B4, 0x07), 2))
			local T7 = bit32.rshift(B4, 3)

			buffer.writeu16(Poly, (PolyOffset + 0) * 2, T0)
			buffer.writeu16(Poly, (PolyOffset + 1) * 2, T1)
			buffer.writeu16(Poly, (PolyOffset + 2) * 2, T2)
			buffer.writeu16(Poly, (PolyOffset + 3) * 2, T3)
			buffer.writeu16(Poly, (PolyOffset + 4) * 2, T4)
			buffer.writeu16(Poly, (PolyOffset + 5) * 2, T5)
			buffer.writeu16(Poly, (PolyOffset + 6) * 2, T6)
			buffer.writeu16(Poly, (PolyOffset + 7) * 2, T7)
		end

	elseif L == 10 then
		local IterCount = N / 4

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 4
			local ByteOffset = I * 5

			local B0 = buffer.readu8(Data, ByteOffset + 0)
			local B1 = buffer.readu8(Data, ByteOffset + 1)
			local B2 = buffer.readu8(Data, ByteOffset + 2)
			local B3 = buffer.readu8(Data, ByteOffset + 3)
			local B4 = buffer.readu8(Data, ByteOffset + 4)

			local T0 = bit32.bor(B0, bit32.lshift(bit32.band(B1, 0x03), 8))
			local T1 = bit32.bor(bit32.rshift(B1, 2), bit32.lshift(bit32.band(B2, 0x0F), 6))
			local T2 = bit32.bor(bit32.rshift(B2, 4), bit32.lshift(bit32.band(B3, 0x3F), 4))
			local T3 = bit32.bor(bit32.rshift(B3, 6), bit32.lshift(B4, 2))

			buffer.writeu16(Poly, (PolyOffset + 0) * 2, T0)
			buffer.writeu16(Poly, (PolyOffset + 1) * 2, T1)
			buffer.writeu16(Poly, (PolyOffset + 2) * 2, T2)
			buffer.writeu16(Poly, (PolyOffset + 3) * 2, T3)
		end

	elseif L == 11 then
		local IterCount = N / 8

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 8
			local ByteOffset = I * 11

			local B0 = buffer.readu8(Data, ByteOffset + 0)
			local B1 = buffer.readu8(Data, ByteOffset + 1)
			local B2 = buffer.readu8(Data, ByteOffset + 2)
			local B3 = buffer.readu8(Data, ByteOffset + 3)
			local B4 = buffer.readu8(Data, ByteOffset + 4)
			local B5 = buffer.readu8(Data, ByteOffset + 5)
			local B6 = buffer.readu8(Data, ByteOffset + 6)
			local B7 = buffer.readu8(Data, ByteOffset + 7)
			local B8 = buffer.readu8(Data, ByteOffset + 8)
			local B9 = buffer.readu8(Data, ByteOffset + 9)
			local B10 = buffer.readu8(Data, ByteOffset + 10)

			local T0 = bit32.bor(B0, bit32.lshift(bit32.band(B1, 0x07), 8))
			local T1 = bit32.bor(bit32.rshift(B1, 3), bit32.lshift(bit32.band(B2, 0x3F), 5))
			local T2 = bit32.bor(bit32.rshift(B2, 6), bit32.lshift(B3, 2), bit32.lshift(bit32.band(B4, 0x01), 10))
			local T3 = bit32.bor(bit32.rshift(B4, 1), bit32.lshift(bit32.band(B5, 0x0F), 7))
			local T4 = bit32.bor(bit32.rshift(B5, 4), bit32.lshift(bit32.band(B6, 0x7F), 4))
			local T5 = bit32.bor(bit32.rshift(B6, 7), bit32.lshift(B7, 1), bit32.lshift(bit32.band(B8, 0x03), 9))
			local T6 = bit32.bor(bit32.rshift(B8, 2), bit32.lshift(bit32.band(B9, 0x1F), 6))
			local T7 = bit32.bor(bit32.rshift(B9, 5), bit32.lshift(B10, 3))

			buffer.writeu16(Poly, (PolyOffset + 0) * 2, T0)
			buffer.writeu16(Poly, (PolyOffset + 1) * 2, T1)
			buffer.writeu16(Poly, (PolyOffset + 2) * 2, T2)
			buffer.writeu16(Poly, (PolyOffset + 3) * 2, T3)
			buffer.writeu16(Poly, (PolyOffset + 4) * 2, T4)
			buffer.writeu16(Poly, (PolyOffset + 5) * 2, T5)
			buffer.writeu16(Poly, (PolyOffset + 6) * 2, T6)
			buffer.writeu16(Poly, (PolyOffset + 7) * 2, T7)
		end
	else
		local IterCount = N / 2

		for I = 0, IterCount - 1 do
			local PolyOffset = I * 2
			local ByteOffset = I * 3

			local B0 = buffer.readu8(Data, ByteOffset + 0)
			local B1 = buffer.readu8(Data, ByteOffset + 1)
			local B2 = buffer.readu8(Data, ByteOffset + 2)

			local T0 = bit32.bor(B0, bit32.lshift(bit32.band(B1, 0x0F), 8))
			local T1 = bit32.bor(bit32.rshift(B1, 4), bit32.lshift(B2, 4))

			if T0 >= 3329 or T1 >= 3329 then
				error("Invalid polynomial coefficient encoding")
			end

			buffer.writeu16(Poly, (PolyOffset + 0) * 2, T0)
			buffer.writeu16(Poly, (PolyOffset + 1) * 2, T1)
		end
	end

	return Poly
end

function Serialize.DecodeAt(Data: buffer, DataOffset: number, Poly: buffer, PolyOffset: number, L: number)
	if L == 12 then
		for I = 0, 127 do
			local ByteIdx = DataOffset + I * 3
			local PolyIdx = PolyOffset + I * 4

			local B0 = buffer.readu8(Data, ByteIdx)
			local B1 = buffer.readu8(Data, ByteIdx + 1)
			local B2 = buffer.readu8(Data, ByteIdx + 2)

			local T0 = bit32.bor(B0, bit32.lshift(bit32.band(B1, 0x0F), 8))
			local T1 = bit32.bor(bit32.rshift(B1, 4), bit32.lshift(B2, 4))

			if T0 >= 3329 or T1 >= 3329 then
				error("Invalid polynomial coefficient encoding")
			end

			buffer.writeu16(Poly, PolyIdx, T0)
			buffer.writeu16(Poly, PolyIdx + 2, T1)
		end
	end
end

return Serialize]]></ProtectedString>
								<string name="ScriptGuid">{29C92188-66BA-4829-8B0A-D0825F96D24F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Serialize</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE93C7944F4F74A0A8A1D9B1B0F5052AE">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM Utilities Module
	
	Utility functions for ML-KEM implementation
	
	Example usage:
		local Utils = require(script.Utils)
		local IsEqual = Utils.CtMemcmp(Buffer1, Buffer2)
		
		Utils.CtCondMemcpy(Condition, Dest, Src1, Src2)
		
		local PubKeySize = Utils.GetKemPublicKeyLen(4) -- 1568 bytes
		local SecKeySize = Utils.GetKemSecretKeyLen(4) -- 3168 bytes
--]=]

--!strict
--!optimize 2
--!native

local MlKemParams = require("./Params")

local Utils = {}

function Utils.CtMemcmp(Bytes0: buffer, Bytes1: buffer): number
	local Len0 = buffer.len(Bytes0)
	local Len1 = buffer.len(Bytes1)

	if Len0 ~= Len1 then
		return 0x00000000
	end

	local Diff = 0
	local Len4 = Len0 - (Len0 % 4)

	for Index = 0, Len4 - 4, 4 do
		local Word0 = buffer.readu32(Bytes0, Index)
		local Word1 = buffer.readu32(Bytes1, Index)
		Diff = bit32.bor(Diff, bit32.bxor(Word0, Word1))
	end

	for Index = Len4, Len0 - 1 do
		local Byte0 = buffer.readu8(Bytes0, Index)
		local Byte1 = buffer.readu8(Bytes1, Index)
		Diff = bit32.bor(Diff, bit32.bxor(Byte0, Byte1))
	end

	return if Diff == 0 then 0xFFFFFFFF else 0x00000000
end

function Utils.CtCondMemcpy(Cond: number, Sink: buffer, Source0: buffer, Source1: buffer)
	local SinkLen = buffer.len(Sink)
	local Mask = bit32.band(Cond, 0xFFFFFFFF)
	local InvMask = bit32.bnot(Mask)
	local Len4 = SinkLen - (SinkLen % 4)

	for Index = 0, Len4 - 4, 4 do
		local Word0 = buffer.readu32(Source0, Index)
		local Word1 = buffer.readu32(Source1, Index)
		local Selected = bit32.bor(bit32.band(Word0, Mask), bit32.band(Word1, InvMask))
		buffer.writeu32(Sink, Index, Selected)
	end

	for Index = Len4, SinkLen - 1 do
		local Byte0 = buffer.readu8(Source0, Index)
		local Byte1 = buffer.readu8(Source1, Index)
		local Selected = bit32.bor(bit32.band(Byte0, Mask), bit32.band(Byte1, InvMask))
		buffer.writeu8(Sink, Index, Selected)
	end
end

function Utils.BitReverse(Value: number, BitWidth: number): number
	local Reversed = 0
	for I = 0, BitWidth - 1 do
		local Bit = bit32.band(bit32.rshift(Value, I), 1)
		Reversed = bit32.bor(Reversed, bit32.lshift(Bit, BitWidth - 1 - I))
	end

	return Reversed
end

function Utils.GetPkePublicKeyLen(K: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end

	return K * 12 * 32 + 32
end

function Utils.GetPkeSecretKeyLen(K: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end

	return K * 12 * 32
end

function Utils.GetPkeCipherTextLen(K: number, Du: number, Dv: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end
	if not MlKemParams.CheckD(Du) then
		error("Invalid Du parameter")
	end
	if not MlKemParams.CheckD(Dv) then
		error("Invalid Dv parameter")
	end

	return 32 * (K * Du + Dv)
end

function Utils.GetKemPublicKeyLen(K: number): number
	return Utils.GetPkePublicKeyLen(K)
end

function Utils.GetKemSecretKeyLen(K: number): number
	if not MlKemParams.CheckK(K) then
		error("Invalid K parameter")
	end

	return Utils.GetPkeSecretKeyLen(K) + Utils.GetPkePublicKeyLen(K) + 32 + 32
end

function Utils.GetKemCipherTextLen(K: number, Du: number, Dv: number): number
	return Utils.GetPkeCipherTextLen(K, Du, Dv)
end

return Utils]]></ProtectedString>
								<string name="ScriptGuid">{1B7E2447-B9C2-418A-AD7E-01BC05BE2F9F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Utils</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX129B39B2C0374CCBAA112A9BF5F12A41">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Stateful SHAKE XOF (Extensible Output Function)
	
	Non-OOP implementation with reusable state buffers.
	For ML-DSA sampling functions that use rejection sampling.
	
	Example usage:
		local XOF = require(script)
		
		XOF.Reset128()
		XOF.Absorb128(message)
		local Chunk1 = XOF.Squeeze128(168)
		local Chunk2 = XOF.Squeeze128(168)
--]=]

--!strict
--!optimize 2
--!native

local RATE_128 = 168
local RATE_256 = 136

local LanesLow128 = buffer.create(100)
local LanesHigh128 = buffer.create(100)
local SqueezeOffset128 = 0

local LanesLow256 = buffer.create(100)
local LanesHigh256 = buffer.create(100)
local SqueezeOffset256 = 0

local ZeroBuffer128 = buffer.create(RATE_128)
local ZeroBuffer256 = buffer.create(RATE_256)

local PaddedBuffer128 = buffer.create(RATE_128)
local PaddedBuffer256 = buffer.create(RATE_256)

local SqueezeBuffer128_168 = buffer.create(168)
local SqueezeBuffer256_128 = buffer.create(128)
local SqueezeBuffer256_192 = buffer.create(192)

local LOW_ROUND, HIGH_ROUND = buffer.create(96), buffer.create(96) do
	local HighFactorKeccak = 0
	local ShiftRegister = 29
	local function GetNextBit(): number
		local Result = ShiftRegister % 2
		ShiftRegister = bit32.bxor((ShiftRegister - Result) // 2, 142 * Result)
		return Result
	end

	for Index = 0, 23 do
		local LowValue = 0
		local Multiplier: number

		for _ = 1, 6 do
			Multiplier = if Multiplier then Multiplier * Multiplier * 2 else 1
			LowValue += GetNextBit() * Multiplier
		end

		local HighValue = GetNextBit() * Multiplier
		buffer.writeu32(HIGH_ROUND, Index * 4, HighValue)
		buffer.writeu32(LOW_ROUND, Index * 4, LowValue + HighValue * HighFactorKeccak)
	end
end

local function Keccak(LanesLow: buffer, LanesHigh: buffer, InputBuffer: buffer, Offset: number, Size: number, BlockSizeInBytes: number): ()
	local QuadWordsQuantity = BlockSizeInBytes // 8
	local RCHigh, RCLow = HIGH_ROUND, LOW_ROUND

	for Position = Offset, Offset + Size - 1, BlockSizeInBytes do
		for Index = 0, (QuadWordsQuantity - 1) * 4, 4 do
			local BufferPos = Position + Index * 2

			buffer.writeu32(LanesLow, Index, bit32.bxor(
				buffer.readu32(LanesLow, Index),
				buffer.readu32(InputBuffer, BufferPos)
				))

			buffer.writeu32(LanesHigh, Index, bit32.bxor(
				buffer.readu32(LanesHigh, Index),
				buffer.readu32(InputBuffer, BufferPos + 4)
				))
		end

		local Lane01Low, Lane01High = buffer.readu32(LanesLow, 0), buffer.readu32(LanesHigh, 0)
		local Lane02Low, Lane02High = buffer.readu32(LanesLow, 4), buffer.readu32(LanesHigh, 4)
		local Lane03Low, Lane03High = buffer.readu32(LanesLow, 8), buffer.readu32(LanesHigh, 8)

		local Lane04Low, Lane04High = buffer.readu32(LanesLow, 12), buffer.readu32(LanesHigh, 12)
		local Lane05Low, Lane05High = buffer.readu32(LanesLow, 16), buffer.readu32(LanesHigh, 16)
		local Lane06Low, Lane06High = buffer.readu32(LanesLow, 20), buffer.readu32(LanesHigh, 20)

		local Lane07Low, Lane07High = buffer.readu32(LanesLow, 24), buffer.readu32(LanesHigh, 24)
		local Lane08Low, Lane08High = buffer.readu32(LanesLow, 28), buffer.readu32(LanesHigh, 28)
		local Lane09Low, Lane09High = buffer.readu32(LanesLow, 32), buffer.readu32(LanesHigh, 32)

		local Lane10Low, Lane10High = buffer.readu32(LanesLow, 36), buffer.readu32(LanesHigh, 36)
		local Lane11Low, Lane11High = buffer.readu32(LanesLow, 40), buffer.readu32(LanesHigh, 40)
		local Lane12Low, Lane12High = buffer.readu32(LanesLow, 44), buffer.readu32(LanesHigh, 44)

		local Lane13Low, Lane13High = buffer.readu32(LanesLow, 48), buffer.readu32(LanesHigh, 48)
		local Lane14Low, Lane14High = buffer.readu32(LanesLow, 52), buffer.readu32(LanesHigh, 52)
		local Lane15Low, Lane15High = buffer.readu32(LanesLow, 56), buffer.readu32(LanesHigh, 56)

		local Lane16Low, Lane16High = buffer.readu32(LanesLow, 60), buffer.readu32(LanesHigh, 60)
		local Lane17Low, Lane17High = buffer.readu32(LanesLow, 64), buffer.readu32(LanesHigh, 64)
		local Lane18Low, Lane18High = buffer.readu32(LanesLow, 68), buffer.readu32(LanesHigh, 68)

		local Lane19Low, Lane19High = buffer.readu32(LanesLow, 72), buffer.readu32(LanesHigh, 72)
		local Lane20Low, Lane20High = buffer.readu32(LanesLow, 76), buffer.readu32(LanesHigh, 76)
		local Lane21Low, Lane21High = buffer.readu32(LanesLow, 80), buffer.readu32(LanesHigh, 80)

		local Lane22Low, Lane22High = buffer.readu32(LanesLow, 84), buffer.readu32(LanesHigh, 84)
		local Lane23Low, Lane23High = buffer.readu32(LanesLow, 88), buffer.readu32(LanesHigh, 88)
		local Lane24Low, Lane24High = buffer.readu32(LanesLow, 92), buffer.readu32(LanesHigh, 92)

		local Lane25Low, Lane25High = buffer.readu32(LanesLow, 96), buffer.readu32(LanesHigh, 96)

		for RoundIndex = 0, 92, 4 do
			local Column1Low, Column1High = bit32.bxor(Lane01Low, Lane06Low, Lane11Low, Lane16Low, Lane21Low), bit32.bxor(Lane01High, Lane06High, Lane11High, Lane16High, Lane21High)
			local Column2Low, Column2High = bit32.bxor(Lane02Low, Lane07Low, Lane12Low, Lane17Low, Lane22Low), bit32.bxor(Lane02High, Lane07High, Lane12High, Lane17High, Lane22High)
			local Column3Low, Column3High = bit32.bxor(Lane03Low, Lane08Low, Lane13Low, Lane18Low, Lane23Low), bit32.bxor(Lane03High, Lane08High, Lane13High, Lane18High, Lane23High)
			local Column4Low, Column4High = bit32.bxor(Lane04Low, Lane09Low, Lane14Low, Lane19Low, Lane24Low), bit32.bxor(Lane04High, Lane09High, Lane14High, Lane19High, Lane24High)
			local Column5Low, Column5High = bit32.bxor(Lane05Low, Lane10Low, Lane15Low, Lane20Low, Lane25Low), bit32.bxor(Lane05High, Lane10High, Lane15High, Lane20High, Lane25High)

			local DeltaLow, DeltaHigh = bit32.bxor(Column1Low, Column3Low * 2 + Column3High // 2147483648), bit32.bxor(Column1High, Column3High * 2 + Column3Low // 2147483648)
			local Temp0Low, Temp0High = bit32.bxor(DeltaLow, Lane02Low), bit32.bxor(DeltaHigh, Lane02High)
			local Temp1Low, Temp1High = bit32.bxor(DeltaLow, Lane07Low), bit32.bxor(DeltaHigh, Lane07High)
			local Temp2Low, Temp2High = bit32.bxor(DeltaLow, Lane12Low), bit32.bxor(DeltaHigh, Lane12High)
			local Temp3Low, Temp3High = bit32.bxor(DeltaLow, Lane17Low), bit32.bxor(DeltaHigh, Lane17High)
			local Temp4Low, Temp4High = bit32.bxor(DeltaLow, Lane22Low), bit32.bxor(DeltaHigh, Lane22High)

			Lane02Low = Temp1Low // 1048576 + (Temp1High * 4096); Lane02High = Temp1High // 1048576 + (Temp1Low * 4096)
			Lane07Low = Temp3Low // 524288 + (Temp3High * 8192); Lane07High = Temp3High // 524288 + (Temp3Low * 8192)
			Lane12Low = Temp0Low * 2 + Temp0High // 2147483648; Lane12High = Temp0High * 2 + Temp0Low // 2147483648
			Lane17Low = Temp2Low * 1024 + Temp2High // 4194304; Lane17High = Temp2High * 1024 + Temp2Low // 4194304
			Lane22Low = Temp4Low * 4 + Temp4High // 1073741824; Lane22High = Temp4High * 4 + Temp4Low // 1073741824

			DeltaLow = bit32.bxor(Column2Low, Column4Low * 2 + Column4High // 2147483648); DeltaHigh = bit32.bxor(Column2High, Column4High * 2 + Column4Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane03Low); Temp0High = bit32.bxor(DeltaHigh, Lane03High)
			Temp1Low = bit32.bxor(DeltaLow, Lane08Low); Temp1High = bit32.bxor(DeltaHigh, Lane08High)
			Temp2Low = bit32.bxor(DeltaLow, Lane13Low); Temp2High = bit32.bxor(DeltaHigh, Lane13High)
			Temp3Low = bit32.bxor(DeltaLow, Lane18Low); Temp3High = bit32.bxor(DeltaHigh, Lane18High)
			Temp4Low = bit32.bxor(DeltaLow, Lane23Low); Temp4High = bit32.bxor(DeltaHigh, Lane23High)

			Lane03Low = Temp2Low // 2097152 + (Temp2High * 2048); Lane03High = Temp2High // 2097152 + (Temp2Low * 2048)
			Lane08Low = Temp4Low // 8 + bit32.bor(Temp4High * 536870912, 0); Lane08High = Temp4High // 8 + bit32.bor(Temp4Low * 536870912, 0)
			Lane13Low = Temp1Low * 64 + Temp1High // 67108864; Lane13High = Temp1High * 64 + Temp1Low // 67108864
			Lane18Low = (Temp3Low * 32768) + Temp3High // 131072; Lane18High = (Temp3High * 32768) + Temp3Low // 131072
			Lane23Low = Temp0Low // 4 + bit32.bor(Temp0High * 1073741824, 0); Lane23High = Temp0High // 4 + bit32.bor(Temp0Low * 1073741824, 0)

			DeltaLow = bit32.bxor(Column3Low, Column5Low * 2 + Column5High // 2147483648); DeltaHigh = bit32.bxor(Column3High, Column5High * 2 + Column5Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane04Low); Temp0High = bit32.bxor(DeltaHigh, Lane04High)
			Temp1Low = bit32.bxor(DeltaLow, Lane09Low); Temp1High = bit32.bxor(DeltaHigh, Lane09High)
			Temp2Low = bit32.bxor(DeltaLow, Lane14Low); Temp2High = bit32.bxor(DeltaHigh, Lane14High)
			Temp3Low = bit32.bxor(DeltaLow, Lane19Low); Temp3High = bit32.bxor(DeltaHigh, Lane19High)
			Temp4Low = bit32.bxor(DeltaLow, Lane24Low); Temp4High = bit32.bxor(DeltaHigh, Lane24High)

			Lane04Low = bit32.bor(Temp3Low * 2097152, 0) + Temp3High // 2048; Lane04High = bit32.bor(Temp3High * 2097152, 0) + Temp3Low // 2048
			Lane09Low = bit32.bor(Temp0Low * 268435456, 0) + Temp0High // 16; Lane09High = bit32.bor(Temp0High * 268435456, 0) + Temp0Low // 16
			Lane14Low = bit32.bor(Temp2Low * 33554432, 0) + Temp2High // 128; Lane14High = bit32.bor(Temp2High * 33554432, 0) + Temp2Low // 128
			Lane19Low = Temp4Low // 256 + bit32.bor(Temp4High * 16777216, 0); Lane19High = Temp4High // 256 + bit32.bor(Temp4Low * 16777216, 0)
			Lane24Low = Temp1Low // 512 + bit32.bor(Temp1High * 8388608, 0); Lane24High = Temp1High // 512 + bit32.bor(Temp1Low * 8388608, 0)
			DeltaLow = bit32.bxor(Column4Low, Column1Low * 2 + Column1High // 2147483648); DeltaHigh = bit32.bxor(Column4High, Column1High * 2 + Column1Low // 2147483648)

			Temp0Low = bit32.bxor(DeltaLow, Lane05Low); Temp0High = bit32.bxor(DeltaHigh, Lane05High)
			Temp1Low = bit32.bxor(DeltaLow, Lane10Low); Temp1High = bit32.bxor(DeltaHigh, Lane10High)
			Temp2Low = bit32.bxor(DeltaLow, Lane15Low); Temp2High = bit32.bxor(DeltaHigh, Lane15High)
			Temp3Low = bit32.bxor(DeltaLow, Lane20Low); Temp3High = bit32.bxor(DeltaHigh, Lane20High)
			Temp4Low = bit32.bxor(DeltaLow, Lane25Low); Temp4High = bit32.bxor(DeltaHigh, Lane25High)

			Lane05Low = (Temp4Low * 16384) + Temp4High // 262144; Lane05High = (Temp4High * 16384) + Temp4Low // 262144
			Lane10Low = bit32.bor(Temp1Low * 1048576, 0) + Temp1High // 4096; Lane10High = bit32.bor(Temp1High * 1048576, 0) + Temp1Low // 4096
			Lane15Low = Temp3Low * 256 + Temp3High // 16777216; Lane15High = Temp3High * 256 + Temp3Low // 16777216
			Lane20Low = bit32.bor(Temp0Low * 134217728, 0) + Temp0High // 32; Lane20High = bit32.bor(Temp0High * 134217728, 0) + Temp0Low // 32
			Lane25Low = Temp2Low // 33554432 + Temp2High * 128; Lane25High = Temp2High // 33554432 + Temp2Low * 128

			DeltaLow = bit32.bxor(Column5Low, Column2Low * 2 + Column2High // 2147483648); DeltaHigh = bit32.bxor(Column5High, Column2High * 2 + Column2Low // 2147483648)
			Temp1Low = bit32.bxor(DeltaLow, Lane06Low); Temp1High = bit32.bxor(DeltaHigh, Lane06High)
			Temp2Low = bit32.bxor(DeltaLow, Lane11Low); Temp2High = bit32.bxor(DeltaHigh, Lane11High)
			Temp3Low = bit32.bxor(DeltaLow, Lane16Low); Temp3High = bit32.bxor(DeltaHigh, Lane16High)
			Temp4Low = bit32.bxor(DeltaLow, Lane21Low); Temp4High = bit32.bxor(DeltaHigh, Lane21High)
			Lane06Low = Temp2Low * 8 + Temp2High // 536870912; Lane06High = Temp2High * 8 + Temp2Low // 536870912
			Lane11Low = (Temp4Low * 262144) + Temp4High // 16384; Lane11High = (Temp4High * 262144) + Temp4Low // 16384
			Lane16Low = Temp1Low // 268435456 + Temp1High * 16; Lane16High = Temp1High // 268435456 + Temp1Low * 16
			Lane21Low = Temp3Low // 8388608 + Temp3High * 512; Lane21High = Temp3High // 8388608 + Temp3Low * 512
			Lane01Low = bit32.bxor(DeltaLow, Lane01Low); Lane01High = bit32.bxor(DeltaHigh, Lane01High)

			Lane01Low, Lane02Low, Lane03Low, Lane04Low, Lane05Low = bit32.bxor(Lane01Low, bit32.band(-1 - Lane02Low, Lane03Low)), bit32.bxor(Lane02Low, bit32.band(-1 - Lane03Low, Lane04Low)), bit32.bxor(Lane03Low, bit32.band(-1 - Lane04Low, Lane05Low)), bit32.bxor(Lane04Low, bit32.band(-1 - Lane05Low, Lane01Low)), bit32.bxor(Lane05Low, bit32.band(-1 - Lane01Low, Lane02Low)) :: number
			Lane01High, Lane02High, Lane03High, Lane04High, Lane05High = bit32.bxor(Lane01High, bit32.band(-1 - Lane02High, Lane03High)), bit32.bxor(Lane02High, bit32.band(-1 - Lane03High, Lane04High)), bit32.bxor(Lane03High, bit32.band(-1 - Lane04High, Lane05High)), bit32.bxor(Lane04High, bit32.band(-1 - Lane05High, Lane01High)), bit32.bxor(Lane05High, bit32.band(-1 - Lane01High, Lane02High)) :: number
			Lane06Low, Lane07Low, Lane08Low, Lane09Low, Lane10Low = bit32.bxor(Lane09Low, bit32.band(-1 - Lane10Low, Lane06Low)), bit32.bxor(Lane10Low, bit32.band(-1 - Lane06Low, Lane07Low)), bit32.bxor(Lane06Low, bit32.band(-1 - Lane07Low, Lane08Low)), bit32.bxor(Lane07Low, bit32.band(-1 - Lane08Low, Lane09Low)), bit32.bxor(Lane08Low, bit32.band(-1 - Lane09Low, Lane10Low)) :: number
			Lane06High, Lane07High, Lane08High, Lane09High, Lane10High = bit32.bxor(Lane09High, bit32.band(-1 - Lane10High, Lane06High)), bit32.bxor(Lane10High, bit32.band(-1 - Lane06High, Lane07High)), bit32.bxor(Lane06High, bit32.band(-1 - Lane07High, Lane08High)), bit32.bxor(Lane07High, bit32.band(-1 - Lane08High, Lane09High)), bit32.bxor(Lane08High, bit32.band(-1 - Lane09High, Lane10High)) :: number
			Lane11Low, Lane12Low, Lane13Low, Lane14Low, Lane15Low = bit32.bxor(Lane12Low, bit32.band(-1 - Lane13Low, Lane14Low)), bit32.bxor(Lane13Low, bit32.band(-1 - Lane14Low, Lane15Low)), bit32.bxor(Lane14Low, bit32.band(-1 - Lane15Low, Lane11Low)), bit32.bxor(Lane15Low, bit32.band(-1 - Lane11Low, Lane12Low)), bit32.bxor(Lane11Low, bit32.band(-1 - Lane12Low, Lane13Low)) :: number
			Lane11High, Lane12High, Lane13High, Lane14High, Lane15High = bit32.bxor(Lane12High, bit32.band(-1 - Lane13High, Lane14High)), bit32.bxor(Lane13High, bit32.band(-1 - Lane14High, Lane15High)), bit32.bxor(Lane14High, bit32.band(-1 - Lane15High, Lane11High)), bit32.bxor(Lane15High, bit32.band(-1 - Lane11High, Lane12High)), bit32.bxor(Lane11High, bit32.band(-1 - Lane12High, Lane13High)) :: number
			Lane16Low, Lane17Low, Lane18Low, Lane19Low, Lane20Low = bit32.bxor(Lane20Low, bit32.band(-1 - Lane16Low, Lane17Low)), bit32.bxor(Lane16Low, bit32.band(-1 - Lane17Low, Lane18Low)), bit32.bxor(Lane17Low, bit32.band(-1 - Lane18Low, Lane19Low)), bit32.bxor(Lane18Low, bit32.band(-1 - Lane19Low, Lane20Low)), bit32.bxor(Lane19Low, bit32.band(-1 - Lane20Low, Lane16Low)) :: number
			Lane16High, Lane17High, Lane18High, Lane19High, Lane20High = bit32.bxor(Lane20High, bit32.band(-1 - Lane16High, Lane17High)), bit32.bxor(Lane16High, bit32.band(-1 - Lane17High, Lane18High)), bit32.bxor(Lane17High, bit32.band(-1 - Lane18High, Lane19High)), bit32.bxor(Lane18High, bit32.band(-1 - Lane19High, Lane20High)), bit32.bxor(Lane19High, bit32.band(-1 - Lane20High, Lane16High)) :: number
			Lane21Low, Lane22Low, Lane23Low, Lane24Low, Lane25Low = bit32.bxor(Lane23Low, bit32.band(-1 - Lane24Low, Lane25Low)), bit32.bxor(Lane24Low, bit32.band(-1 - Lane25Low, Lane21Low)), bit32.bxor(Lane25Low, bit32.band(-1 - Lane21Low, Lane22Low)), bit32.bxor(Lane21Low, bit32.band(-1 - Lane22Low, Lane23Low)), bit32.bxor(Lane22Low, bit32.band(-1 - Lane23Low, Lane24Low)) :: number
			Lane21High, Lane22High, Lane23High, Lane24High, Lane25High = bit32.bxor(Lane23High, bit32.band(-1 - Lane24High, Lane25High)), bit32.bxor(Lane24High, bit32.band(-1 - Lane25High, Lane21High)), bit32.bxor(Lane25High, bit32.band(-1 - Lane21High, Lane22High)), bit32.bxor(Lane21High, bit32.band(-1 - Lane22High, Lane23High)), bit32.bxor(Lane22High, bit32.band(-1 - Lane23High, Lane24High)) :: number

			Lane01Low = bit32.bxor(Lane01Low, buffer.readu32(RCLow, RoundIndex))
			Lane01High = bit32.bxor(Lane01High, buffer.readu32(RCHigh, RoundIndex))
		end

		buffer.writeu32(LanesLow, 0, Lane01Low); buffer.writeu32(LanesHigh, 0, Lane01High)
		buffer.writeu32(LanesLow, 4, Lane02Low); buffer.writeu32(LanesHigh, 4, Lane02High)
		buffer.writeu32(LanesLow, 8, Lane03Low); buffer.writeu32(LanesHigh, 8, Lane03High)
		buffer.writeu32(LanesLow, 12, Lane04Low); buffer.writeu32(LanesHigh, 12, Lane04High)
		buffer.writeu32(LanesLow, 16, Lane05Low); buffer.writeu32(LanesHigh, 16, Lane05High)
		buffer.writeu32(LanesLow, 20, Lane06Low); buffer.writeu32(LanesHigh, 20, Lane06High)
		buffer.writeu32(LanesLow, 24, Lane07Low); buffer.writeu32(LanesHigh, 24, Lane07High)
		buffer.writeu32(LanesLow, 28, Lane08Low); buffer.writeu32(LanesHigh, 28, Lane08High)
		buffer.writeu32(LanesLow, 32, Lane09Low); buffer.writeu32(LanesHigh, 32, Lane09High)
		buffer.writeu32(LanesLow, 36, Lane10Low); buffer.writeu32(LanesHigh, 36, Lane10High)
		buffer.writeu32(LanesLow, 40, Lane11Low); buffer.writeu32(LanesHigh, 40, Lane11High)
		buffer.writeu32(LanesLow, 44, Lane12Low); buffer.writeu32(LanesHigh, 44, Lane12High)
		buffer.writeu32(LanesLow, 48, Lane13Low); buffer.writeu32(LanesHigh, 48, Lane13High)
		buffer.writeu32(LanesLow, 52, Lane14Low); buffer.writeu32(LanesHigh, 52, Lane14High)
		buffer.writeu32(LanesLow, 56, Lane15Low); buffer.writeu32(LanesHigh, 56, Lane15High)
		buffer.writeu32(LanesLow, 60, Lane16Low); buffer.writeu32(LanesHigh, 60, Lane16High)
		buffer.writeu32(LanesLow, 64, Lane17Low); buffer.writeu32(LanesHigh, 64, Lane17High)
		buffer.writeu32(LanesLow, 68, Lane18Low); buffer.writeu32(LanesHigh, 68, Lane18High)
		buffer.writeu32(LanesLow, 72, Lane19Low); buffer.writeu32(LanesHigh, 72, Lane19High)
		buffer.writeu32(LanesLow, 76, Lane20Low); buffer.writeu32(LanesHigh, 76, Lane20High)
		buffer.writeu32(LanesLow, 80, Lane21Low); buffer.writeu32(LanesHigh, 80, Lane21High)
		buffer.writeu32(LanesLow, 84, Lane22Low); buffer.writeu32(LanesHigh, 84, Lane22High)
		buffer.writeu32(LanesLow, 88, Lane23Low); buffer.writeu32(LanesHigh, 88, Lane23High)
		buffer.writeu32(LanesLow, 92, Lane24Low); buffer.writeu32(LanesHigh, 92, Lane24High)
		buffer.writeu32(LanesLow, 96, Lane25Low); buffer.writeu32(LanesHigh, 96, Lane25High)
	end
end

local XOF = {}

function XOF.Reset128()
	buffer.fill(LanesLow128, 0, 0, 100)
	buffer.fill(LanesHigh128, 0, 0, 100)
	SqueezeOffset128 = 0
end

function XOF.Reset256()
	buffer.fill(LanesLow256, 0, 0, 100)
	buffer.fill(LanesHigh256, 0, 0, 100)
	SqueezeOffset256 = 0
end

function XOF.Absorb128(Message: buffer)
	local MessageLength = buffer.len(Message)
	local RateBytes = RATE_128

	local PaddedMessage = PaddedBuffer128
	buffer.fill(PaddedMessage, 0, 0, RateBytes)

	if MessageLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
	end

	if RateBytes - MessageLength == 1 then
		buffer.writeu8(PaddedMessage, MessageLength, 0x9F)
	else
		buffer.writeu8(PaddedMessage, MessageLength, 0x1F)
		buffer.writeu8(PaddedMessage, RateBytes - 1, 0x80)
	end

	Keccak(LanesLow128, LanesHigh128, PaddedMessage, 0, RateBytes, RateBytes)
end

function XOF.Absorb256(Message: buffer)
	local MessageLength = buffer.len(Message)
	local RateBytes = RATE_256

	local PaddedMessage = PaddedBuffer256
	buffer.fill(PaddedMessage, 0, 0, RateBytes)

	if MessageLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
	end

	if RateBytes - MessageLength == 1 then
		buffer.writeu8(PaddedMessage, MessageLength, 0x9F)
	else
		buffer.writeu8(PaddedMessage, MessageLength, 0x1F)
		buffer.writeu8(PaddedMessage, RateBytes - 1, 0x80)
	end

	Keccak(LanesLow256, LanesHigh256, PaddedMessage, 0, RateBytes, RateBytes)
end

function XOF.Squeeze128Into(Output: buffer, OutputBytes: number, OutputOffset: number?)
	local OutOffset = OutputOffset or 0
	local RateBytes = RATE_128
	local LanesLow = LanesLow128
	local LanesHigh = LanesHigh128
	local SqueezeOffset = SqueezeOffset128
	local ZeroBuffer = ZeroBuffer128

	local Written = 0
	while Written < OutputBytes do
		if SqueezeOffset >= RateBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
			SqueezeOffset = 0
		end

		local BytesThisRound = RateBytes - SqueezeOffset
		if BytesThisRound > OutputBytes - Written then
			BytesThisRound = OutputBytes - Written
		end

		local ByteIndex = 0
		while ByteIndex < BytesThisRound do
			local AbsoluteIndex = SqueezeOffset + ByteIndex
			local Lane = bit32.rshift(AbsoluteIndex, 3)
			local ByteInLane = bit32.band(AbsoluteIndex, 7)
			local LaneOffset = bit32.lshift(Lane, 2)

			if ByteInLane == 0 and ByteIndex + 8 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				buffer.writeu32(Output, OutOffset + Written + ByteIndex + 4, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 8
			elseif ByteInLane == 0 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				ByteIndex += 4
			elseif ByteInLane == 4 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 4
			else
				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), bit32.lshift(ByteInLane, 3), 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), bit32.lshift(ByteInLane - 4, 3), 8)
				end
				buffer.writeu8(Output, OutOffset + Written + ByteIndex, Value)
				ByteIndex += 1
			end
		end

		Written += BytesThisRound
		SqueezeOffset += BytesThisRound
	end

	SqueezeOffset128 = SqueezeOffset
end

function XOF.Squeeze128(OutputBytes: number): buffer
	local Output = if OutputBytes == 168 then SqueezeBuffer128_168 else buffer.create(OutputBytes)
	XOF.Squeeze128Into(Output, OutputBytes, 0)
	return Output
end

function XOF.Squeeze256Into(Output: buffer, OutputBytes: number, OutputOffset: number?)
	local OutOffset = OutputOffset or 0
	local RateBytes = RATE_256
	local LanesLow = LanesLow256
	local LanesHigh = LanesHigh256
	local SqueezeOffset = SqueezeOffset256
	local ZeroBuffer = ZeroBuffer256

	local Written = 0
	while Written < OutputBytes do
		if SqueezeOffset >= RateBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
			SqueezeOffset = 0
		end

		local BytesThisRound = RateBytes - SqueezeOffset
		if BytesThisRound > OutputBytes - Written then
			BytesThisRound = OutputBytes - Written
		end

		local ByteIndex = 0
		while ByteIndex < BytesThisRound do
			local AbsoluteIndex = SqueezeOffset + ByteIndex
			local Lane = bit32.rshift(AbsoluteIndex, 3)
			local ByteInLane = bit32.band(AbsoluteIndex, 7)
			local LaneOffset = bit32.lshift(Lane, 2)

			if ByteInLane == 0 and ByteIndex + 8 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				buffer.writeu32(Output, OutOffset + Written + ByteIndex + 4, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 8
			elseif ByteInLane == 0 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				ByteIndex += 4
			elseif ByteInLane == 4 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 4
			else
				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), bit32.lshift(ByteInLane, 3), 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), bit32.lshift(ByteInLane - 4, 3), 8)
				end
				buffer.writeu8(Output, OutOffset + Written + ByteIndex, Value)
				ByteIndex += 1
			end
		end

		Written += BytesThisRound
		SqueezeOffset += BytesThisRound
	end

	SqueezeOffset256 = SqueezeOffset
end

function XOF.Squeeze256(OutputBytes: number): buffer
	local Output = if OutputBytes == 128 then SqueezeBuffer256_128 
		elseif OutputBytes == 192 then SqueezeBuffer256_192 
		else buffer.create(OutputBytes)
	XOF.Squeeze256Into(Output, OutputBytes, 0)
	return Output
end

return XOF]]></ProtectedString>
								<string name="ScriptGuid">{AF0866C3-BE2D-44F5-946C-D8DDC7E3B46D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">XOF</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXACB0BB7E31224D71BBA189B33496C432">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	ML-DSA (FIPS 204) Digital Signature Algorithm
	
	Post quantum digital signature scheme based on lattice cryptography.
	Has three security levels: ML-DSA-44, ML-DSA-65, ML-DSA-87.

	Example usage:
		local MLDSA = require("@self/MlDSA")
		
		local PubKey, SecKey = MLDSA.ML_DSA_44.GenerateKeys()
		local Message = buffer.fromstring("Hello World")
		local Context = buffer.create(0)
		local Signature = buffer.create(MLDSA.ML_DSA_44.SigByteLen)
		local Random = buffer.create(32)
		
		local Success = MLDSA.ML_DSA_44.Sign(Message, Random, SecKey, Context, Signature)
		local Valid = MLDSA.ML_DSA_44.Verify(Message, PubKey, Context, Signature)
--]=]

--!strict
--!optimize 2
--!native

local SHA3 = require("@self/SHA3")
local NTT = require("@self/NTT")

local PolyVec = require("@self/PolyVec")
local BitPacking = require("@self/Pack")

local Sampling = require("@self/Sampling")
local Params = require("@self/Params")

local Utils = require("@self/Utils")
local CSPRNG = require("@self/CSPRNG")

local KEYGEN_SEED_BYTE_LEN = 32
local RND_BYTE_LEN = 32

local N = 256
local Q = 8380417

local Mldsa = {
	CSPRNG = CSPRNG
}

local function CompareBufferSlices(A: buffer, AOffset: number, B: buffer, BOffset: number, Length: number): boolean
	local Difference = 0

	if Length == 32 then
		Difference = bit32.bor(
			bit32.bxor(buffer.readu32(A, AOffset), buffer.readu32(B, BOffset)),
			bit32.bxor(buffer.readu32(A, AOffset + 4), buffer.readu32(B, BOffset + 4)),
			bit32.bxor(buffer.readu32(A, AOffset + 8), buffer.readu32(B, BOffset + 8)),
			bit32.bxor(buffer.readu32(A, AOffset + 12), buffer.readu32(B, BOffset + 12)),
			bit32.bxor(buffer.readu32(A, AOffset + 16), buffer.readu32(B, BOffset + 16)),
			bit32.bxor(buffer.readu32(A, AOffset + 20), buffer.readu32(B, BOffset + 20)),
			bit32.bxor(buffer.readu32(A, AOffset + 24), buffer.readu32(B, BOffset + 24)),
			bit32.bxor(buffer.readu32(A, AOffset + 28), buffer.readu32(B, BOffset + 28))
		)
		return Difference == 0
	end

	local AlignedLength = bit32.band(Length, bit32.bnot(3))
	for I = 0, AlignedLength - 4, 4 do
		Difference = bit32.bor(Difference, bit32.bxor(buffer.readu32(A, AOffset + I), buffer.readu32(B, BOffset + I)))
	end

	for I = AlignedLength, Length - 1 do
		Difference = bit32.bor(Difference, bit32.bxor(buffer.readu8(A, AOffset + I), buffer.readu8(B, BOffset + I)))
	end

	return Difference == 0
end

local function Keygen(Seed: buffer, PubKey: buffer, SecKey: buffer, K: number, L: number, D: number, Eta: number)
	if not Params.CheckKeygenParams(K, L, D, Eta) then
		error("Invalid keygen parameters")
	end

	local T1Bw = Utils.BitWidth(Q) - D
	local EtaBw = Utils.BitWidth(2 * Eta)
	local S1Len = L * EtaBw * 32
	local S2Len = K * EtaBw * 32
	local T0Rng = bit32.lshift(1, D - 1)

	local PkOff1 = 32
	local SkOff0 = 0
	local SkOff1 = SkOff0 + 32
	local SkOff2 = SkOff1 + 32
	local SkOff3 = SkOff2 + 64
	local SkOff4 = SkOff3 + S1Len 
	local SkOff5 = SkOff4 + S2Len

	local DomainSeparator = buffer.create(2)
	buffer.writeu8(DomainSeparator, 0, K)
	buffer.writeu8(DomainSeparator, 1, L)

	local SeedHashInput = buffer.create(34)
	buffer.copy(SeedHashInput, 0, Seed, 0, 32)
	buffer.copy(SeedHashInput, 32, DomainSeparator, 0, 2)

	local SeedHash = SHA3.SHAKE256(SeedHashInput, 128)

	local Rho = buffer.create(32)
	local RhoPrime = buffer.create(64)
	local Key = buffer.create(32)

	buffer.copy(Rho, 0, SeedHash, 0, 32)
	buffer.copy(RhoPrime, 0, SeedHash, 32, 64)
	buffer.copy(Key, 0, SeedHash, 96, 32)

	local A = buffer.create(K * L * N * 4)
	Sampling.ExpandA(Rho, A, K, L)

	local S1 = buffer.create(L * N * 4)
	local S2 = buffer.create(K * N * 4)

	Sampling.ExpandS(RhoPrime, S1, Eta, L, 0)
	Sampling.ExpandS(RhoPrime, S2, Eta, K, L)

	local S1Prime = buffer.create(L * N * 4)
	PolyVec.Copy(S1, S1Prime, L)
	PolyVec.ForwardNTT(S1Prime, L)

	local T = buffer.create(K * N * 4)
	PolyVec.MatrixMultiply(A, S1Prime, T, K, L, L, 1)
	PolyVec.InverseNTT(T, K)
	PolyVec.AddTo(S2, T, K)

	local T1 = buffer.create(K * N * 4)
	local T0 = buffer.create(K * N * 4)
	PolyVec.Power2Round(T, T1, T0, K, D)

	buffer.copy(PubKey, 0, Rho, 0, 32)
	local T1Encoded = buffer.create(buffer.len(PubKey) - PkOff1)
	PolyVec.Encode(T1, T1Encoded, K, T1Bw)
	buffer.copy(PubKey, PkOff1, T1Encoded, 0, buffer.len(T1Encoded))

	local Tr = SHA3.SHAKE256(PubKey, 64)

	buffer.copy(SecKey, SkOff0, Rho, 0, 32)
	buffer.copy(SecKey, SkOff1, Key, 0, 32)
	buffer.copy(SecKey, SkOff2, Tr, 0, 64)

	PolyVec.SubFromX(S1, L, Eta)
	PolyVec.SubFromX(S2, K, Eta)

	local S1Encoded = buffer.create(S1Len)
	local S2Encoded = buffer.create(S2Len)
	PolyVec.Encode(S1, S1Encoded, L, EtaBw)
	PolyVec.Encode(S2, S2Encoded, K, EtaBw)

	buffer.copy(SecKey, SkOff3, S1Encoded, 0, S1Len)
	buffer.copy(SecKey, SkOff4, S2Encoded, 0, S2Len)

	PolyVec.SubFromX(T0, K, T0Rng)

	local T0Encoded = buffer.create(buffer.len(SecKey) - SkOff5)
	PolyVec.Encode(T0, T0Encoded, K, D)
	buffer.copy(SecKey, SkOff5, T0Encoded, 0, buffer.len(T0Encoded))
end

local function Sign(Msg: buffer, Rnd: buffer, SecKey: buffer, Ctx: buffer, Sig: buffer, K: number, L: number, D: number, Eta: number, Gamma1: number, Gamma2: number, Tau: number, Beta: number, Omega: number, Lambda: number): boolean
	if not Params.CheckSigningParams(K, L, D, Eta, Gamma1, Gamma2, Tau, Beta, Omega, Lambda) then
		error("Invalid signing parameters")
	end

	if buffer.len(Ctx) > 255 then
		return false
	end

	local T0Rng = bit32.lshift(1, D - 1)
	local EtaBw = Utils.BitWidth(2 * Eta)
	local S1Len = L * EtaBw * 32
	local S2Len = K * EtaBw * 32
	local Alpha = bit32.lshift(Gamma2, 1)
	local M = math.floor((Q - 1) / Alpha)
	local W1Bw = Utils.BitWidth(M - 1)
	local CTildaSize = math.floor((2 * Lambda) / 8)
	local Gamma1Bw = Utils.BitWidth(Gamma1)

	local SkOff0 = 0
	local SkOff1 = SkOff0 + 32
	local SkOff2 = SkOff1 + 32
	local SkOff3 = SkOff2 + 64
	local SkOff4 = SkOff3 + S1Len
	local SkOff5 = SkOff4 + S2Len

	local Rho = buffer.create(32)
	local Key = buffer.create(32)
	local Tr = buffer.create(64)

	buffer.copy(Rho, 0, SecKey, SkOff0, 32)
	buffer.copy(Key, 0, SecKey, SkOff1, 32)
	buffer.copy(Tr, 0, SecKey, SkOff2, 64)

	local A = buffer.create(K * L * N * 4)
	Sampling.ExpandA(Rho, A, K, L)

	local DomainSeparator = buffer.create(2)
	buffer.writeu8(DomainSeparator, 0, 0)
	buffer.writeu8(DomainSeparator, 1, buffer.len(Ctx))

	local MuInput = buffer.create(64 + 2 + buffer.len(Ctx) + buffer.len(Msg))
	local Offset = 0
	buffer.copy(MuInput, Offset, Tr, 0, 64)
	Offset += 64
	buffer.copy(MuInput, Offset, DomainSeparator, 0, 2)
	Offset += 2
	buffer.copy(MuInput, Offset, Ctx, 0, buffer.len(Ctx))
	Offset += buffer.len(Ctx)
	buffer.copy(MuInput, Offset, Msg, 0, buffer.len(Msg))

	local Mu = SHA3.SHAKE256(MuInput, 64)

	local RhoPrimeInput = buffer.create(32 + 32 + 64)
	buffer.copy(RhoPrimeInput, 0, Key, 0, 32)
	buffer.copy(RhoPrimeInput, 32, Rnd, 0, 32)
	buffer.copy(RhoPrimeInput, 64, Mu, 0, 64)

	local RhoPrime = SHA3.SHAKE256(RhoPrimeInput, 64)

	local S1 = buffer.create(L * N * 4)
	local S2 = buffer.create(K * N * 4)
	local T0 = buffer.create(K * N * 4)

	local S1Encoded = buffer.create(S1Len)
	local S2Encoded = buffer.create(S2Len)
	local T0Encoded = buffer.create(buffer.len(SecKey) - SkOff5)

	buffer.copy(S1Encoded, 0, SecKey, SkOff3, S1Len)
	buffer.copy(S2Encoded, 0, SecKey, SkOff4, S2Len)
	buffer.copy(T0Encoded, 0, SecKey, SkOff5, buffer.len(T0Encoded))

	PolyVec.Decode(S1Encoded, S1, L, EtaBw)
	PolyVec.Decode(S2Encoded, S2, K, EtaBw)
	PolyVec.Decode(T0Encoded, T0, K, D)

	PolyVec.SubFromX(S1, L, Eta)
	PolyVec.SubFromX(S2, K, Eta)
	PolyVec.SubFromX(T0, K, T0Rng)

	PolyVec.ForwardNTT(S1, L)
	PolyVec.ForwardNTT(S2, K)
	PolyVec.ForwardNTT(T0, K)

	local HasSigned = false
	local Kappa = 0

	local Y = buffer.create(L * N * 4)
	local YPrime = buffer.create(L * N * 4)
	local W = buffer.create(K * N * 4)
	local W1 = buffer.create(K * N * 4)
	local C = buffer.create(N * 4)
	local Z = buffer.create(L * N * 4)
	local R0 = buffer.create(K * N * 4)
	local R1 = buffer.create(K * N * 4)
	local H0 = buffer.create(K * N * 4)
	local H1 = buffer.create(K * N * 4)
	local H = buffer.create(K * N * 4)
	local CTilda = buffer.create(CTildaSize)
	local W1Encoded = buffer.create(K * W1Bw * 32)

	while not HasSigned do
		Sampling.ExpandMask(RhoPrime, Kappa, Y, Gamma1, L)

		PolyVec.Copy(Y, YPrime, L)
		PolyVec.ForwardNTT(YPrime, L)
		PolyVec.MatrixMultiply(A, YPrime, W, K, L, L, 1)
		PolyVec.InverseNTT(W, K)

		PolyVec.HighBits(W, W1, K, Alpha)
		PolyVec.Encode(W1, W1Encoded, K, W1Bw)

		local ChallengeInput = buffer.create(64 + buffer.len(W1Encoded))
		buffer.copy(ChallengeInput, 0, Mu, 0, 64)
		buffer.copy(ChallengeInput, 64, W1Encoded, 0, buffer.len(W1Encoded))

		local CTildaFull = SHA3.SHAKE256(ChallengeInput, CTildaSize)
		buffer.copy(CTilda, 0, CTildaFull, 0, CTildaSize)

		Sampling.SampleInBall(CTilda, C, Tau, Lambda)
		NTT.ForwardNTT(C)

		PolyVec.MultiplyByPoly(C, S1, Z, L)
		PolyVec.InverseNTT(Z, L)
		PolyVec.AddTo(Y, Z, L)

		PolyVec.MultiplyByPoly(C, S2, R1, K)
		PolyVec.InverseNTT(R1, K)
		PolyVec.Negate(R1, K)
		PolyVec.AddTo(W, R1, K)
		PolyVec.LowBits(R1, R0, K, Alpha)

		local ZNorm = PolyVec.InfinityNorm(Z, L)
		local R0Norm = PolyVec.InfinityNorm(R0, K)

		if ZNorm >= (Gamma1 - Beta) or R0Norm >= (Gamma2 - Beta) then
			HasSigned = false
		else
			PolyVec.MultiplyByPoly(C, T0, H0, K)
			PolyVec.InverseNTT(H0, K)

			PolyVec.Copy(H0, H1, K)
			PolyVec.Negate(H0, K)
			PolyVec.AddTo(H1, R1, K)
			PolyVec.MakeHint(H0, R1, H, K, Alpha)

			local CT0Norm = PolyVec.InfinityNorm(H1, K)
			local Count1s = PolyVec.Count1s(H, K)

			if CT0Norm >= Gamma2 or Count1s > Omega then
				HasSigned = false
			else
				HasSigned = true
			end
		end

		Kappa += L
	end

	local SigOff0 = 0
	local SigOff1 = SigOff0 + CTildaSize
	local SigOff2 = SigOff1 + (32 * L * Gamma1Bw)

	buffer.copy(Sig, SigOff0, CTilda, 0, CTildaSize)

	PolyVec.SubFromX(Z, L, Gamma1)
	local ZEncoded = buffer.create(32 * L * Gamma1Bw)
	PolyVec.Encode(Z, ZEncoded, L, Gamma1Bw)
	buffer.copy(Sig, SigOff1, ZEncoded, 0, buffer.len(ZEncoded))

	local HEncoded = buffer.create(buffer.len(Sig) - SigOff2)
	BitPacking.EncodeHintBits(H, HEncoded, K, Omega)
	buffer.copy(Sig, SigOff2, HEncoded, 0, buffer.len(HEncoded))

	return HasSigned
end

function Verify(Msg: buffer, PubKey: buffer, Ctx: buffer, Sig: buffer, K: number, L: number, D: number, Gamma1: number, Gamma2: number, Tau: number, Beta: number, Omega: number, Lambda: number): boolean
	if not Params.CheckVerifyParams(K, L, D, Gamma1, Gamma2, Tau, Beta, Omega, Lambda) then
		error("Invalid verify parameters")
	end

	if buffer.len(Ctx) > 255 then
		return false
	end

	local T1Bw = Utils.BitWidth(Q) - D
	local Gamma1Bw = Utils.BitWidth(Gamma1)
	local CTildaSize = math.floor((2 * Lambda) / 8)

	local ExpectedPkLen = Utils.PubKeyLen(K, D)
	if buffer.len(PubKey) ~= ExpectedPkLen then
		return false
	end

	local ExpectedSigLen = Utils.SigLen(K, L, Gamma1, Omega, Lambda)
	if buffer.len(Sig) ~= ExpectedSigLen then
		return false
	end

	local Alpha = bit32.lshift(Gamma2, 1)
	local M = math.floor((Q - 1) / Alpha)
	local W1Bw = Utils.BitWidth(M - 1)

	local SigOff0 = 0
	local SigOff1 = SigOff0 + CTildaSize
	local SigOff2 = SigOff1 + (32 * L * Gamma1Bw)
	local PkOff0 = 0
	local PkOff1 = PkOff0 + 32

	local CTilda = buffer.create(CTildaSize)
	local ZEncoded = buffer.create(32 * L * Gamma1Bw)
	local HEncoded = buffer.create(buffer.len(Sig) - SigOff2)

	buffer.copy(CTilda, 0, Sig, SigOff0, CTildaSize)
	buffer.copy(ZEncoded, 0, Sig, SigOff1, buffer.len(ZEncoded))
	buffer.copy(HEncoded, 0, Sig, SigOff2, buffer.len(HEncoded))

	local VerificationFailed = false

	local H = buffer.create(K * N * 4)
	local HintFailed = BitPacking.DecodeHintBits(HEncoded, H, K, Omega)
	VerificationFailed = VerificationFailed or HintFailed

	local Count1s = PolyVec.Count1s(H, K)
	VerificationFailed = VerificationFailed or (Count1s > Omega)

	local C = buffer.create(N * 4)
	Sampling.SampleInBall(CTilda, C, Tau, Lambda)
	NTT.ForwardNTT(C)

	local Z = buffer.create(L * N * 4)
	PolyVec.Decode(ZEncoded, Z, L, Gamma1Bw)
	PolyVec.SubFromX(Z, L, Gamma1)

	local ZNorm = PolyVec.InfinityNorm(Z, L)
	VerificationFailed = VerificationFailed or (ZNorm >= (Gamma1 - Beta))

	local Rho = buffer.create(32)
	local T1Encoded = buffer.create(buffer.len(PubKey) - PkOff1)

	buffer.copy(Rho, 0, PubKey, PkOff0, 32)
	buffer.copy(T1Encoded, 0, PubKey, PkOff1, buffer.len(T1Encoded))

	local A = buffer.create(K * L * N * 4)
	local T1 = buffer.create(K * N * 4)

	Sampling.ExpandA(Rho, A, K, L)
	PolyVec.Decode(T1Encoded, T1, K, T1Bw)

	local Tr = SHA3.SHAKE256(PubKey, 64)

	local DomainSeparator = buffer.create(2)
	buffer.writeu8(DomainSeparator, 0, 0)
	buffer.writeu8(DomainSeparator, 1, buffer.len(Ctx))

	local MuInput = buffer.create(64 + 2 + buffer.len(Ctx) + buffer.len(Msg))
	local Offset = 0
	buffer.copy(MuInput, Offset, Tr, 0, 64)
	Offset += 64
	buffer.copy(MuInput, Offset, DomainSeparator, 0, 2)
	Offset += 2
	buffer.copy(MuInput, Offset, Ctx, 0, buffer.len(Ctx))
	Offset += buffer.len(Ctx)
	buffer.copy(MuInput, Offset, Msg, 0, buffer.len(Msg))

	local Mu = SHA3.SHAKE256(MuInput, 64)

	local W0 = buffer.create(K * N * 4)
	local W1 = buffer.create(K * N * 4)
	local W2 = buffer.create(K * N * 4)

	PolyVec.ForwardNTT(Z, L)
	PolyVec.MatrixMultiply(A, Z, W0, K, L, L, 1)

	PolyVec.LeftShift(T1, K, D)
	PolyVec.ForwardNTT(T1, K)
	PolyVec.MultiplyByPoly(C, T1, W2, K)
	PolyVec.Negate(W2, K)

	PolyVec.AddTo(W0, W2, K)
	PolyVec.InverseNTT(W2, K)

	PolyVec.UseHint(H, W2, W1, K, Alpha)

	local W1Encoded = buffer.create(K * W1Bw * 32)
	PolyVec.Encode(W1, W1Encoded, K, W1Bw)

	local ChallengeInput = buffer.create(64 + buffer.len(W1Encoded))
	buffer.copy(ChallengeInput, 0, Mu, 0, 64)
	buffer.copy(ChallengeInput, 64, W1Encoded, 0, buffer.len(W1Encoded))

	local CTildaPrime = SHA3.SHAKE256(ChallengeInput, CTildaSize)
	
	local CompareResult = CompareBufferSlices(CTilda, 0, CTildaPrime, 0, CTildaSize)
	VerificationFailed = VerificationFailed or (not CompareResult)
	
	return not VerificationFailed
end

Mldsa.ML_DSA_44 = {
	D = 13,
	Tau = 39,
	Gamma1 = bit32.lshift(1, 17),
	Gamma2 = math.floor((Q - 1) / 88),
	K = 4,
	L = 4,
	Eta = 2,
	Beta = 39 * 2,
	Omega = 80,
	Lambda = 128,

	KeygenSeedByteLen = KEYGEN_SEED_BYTE_LEN,
	PubKeyByteLen = Utils.PubKeyLen(4, 13),
	SecKeyByteLen = Utils.SecKeyLen(4, 4, 2, 13), 
	SigningSeedByteLen = RND_BYTE_LEN,
	SigByteLen = Utils.SigLen(4, 4, 131072, 80, 128),

	KeyGen = function(Seed: buffer, PubKey: buffer, SecKey: buffer)
		Keygen(Seed, PubKey, SecKey, 4, 4, 13, 2)
	end,

	Sign = function(Msg: buffer,Rnd: buffer, SecKey: buffer, Ctx: buffer, Sig: buffer): boolean
		return Sign(Msg, Rnd, SecKey, Ctx, Sig, 4, 4, 13, 2, 131072, 95232, 39, 78, 80, 128)
	end,

	Verify = function(Msg: buffer, PubKey: buffer, Ctx: buffer, Sig: buffer): boolean
		return Verify(Msg, PubKey, Ctx, Sig, 4, 4, 13, 131072, 95232, 39, 78, 80, 128)
	end,

	GenerateKeys = function(): (buffer, buffer)
		local Seed = CSPRNG.RandomBytes(32)
		local PubKey = buffer.create(1312)
		local SecKey = buffer.create(2560)
		Mldsa.ML_DSA_44.KeyGen(Seed, PubKey, SecKey)
		return PubKey, SecKey
	end
}

Mldsa.ML_DSA_65 = {
	D = 13,
	Tau = 49,
	Gamma1 = bit32.lshift(1, 19),
	Gamma2 = math.floor((Q - 1) / 32),
	K = 6,
	L = 5,
	Eta = 4,
	Beta = 49 * 4,
	Omega = 55,
	Lambda = 192,

	KeygenSeedByteLen = KEYGEN_SEED_BYTE_LEN,
	PubKeyByteLen = Utils.PubKeyLen(6, 13),
	SecKeyByteLen = Utils.SecKeyLen(6, 5, 4, 13),
	SigningSeedByteLen = RND_BYTE_LEN,
	SigByteLen = Utils.SigLen(6, 5, 524288, 55, 192), 

	KeyGen = function(Seed: buffer, PubKey: buffer, SecKey: buffer)
		Keygen(Seed, PubKey, SecKey, 6, 5, 13, 4)
	end,

	Sign = function(Msg: buffer, Rnd: buffer, SecKey: buffer, Ctx: buffer, Sig: buffer): boolean
		return Sign(Msg, Rnd, SecKey, Ctx, Sig, 6, 5, 13, 4, 524288, 261888, 49, 196, 55, 192)
	end,

	Verify = function(Msg: buffer, PubKey: buffer, Ctx: buffer, Sig: buffer): boolean
		return Verify(Msg, PubKey, Ctx, Sig, 6, 5, 13, 524288, 261888, 49, 196, 55, 192)
	end,

	GenerateKeys = function(): (buffer, buffer)
		local Seed = CSPRNG.RandomBytes(32)
		local PubKey = buffer.create(1952)
		local SecKey = buffer.create(4032)
		Mldsa.ML_DSA_65.KeyGen(Seed, PubKey, SecKey)
		return PubKey, SecKey
	end
}

Mldsa.ML_DSA_87 = {
	D = 13,
	Tau = 60,
	Gamma1 = bit32.lshift(1, 19),
	Gamma2 = math.floor((Q - 1) / 32),
	K = 8,
	L = 7,
	Eta = 2,
	Beta = 60 * 2,
	Omega = 75,
	Lambda = 256,

	KeygenSeedByteLen = KEYGEN_SEED_BYTE_LEN,
	PubKeyByteLen = Utils.PubKeyLen(8, 13),
	SecKeyByteLen = Utils.SecKeyLen(8, 7, 2, 13),
	SigningSeedByteLen = RND_BYTE_LEN,
	SigByteLen = Utils.SigLen(8, 7, 524288, 75, 256),

	KeyGen = function(Seed: buffer, PubKey: buffer, SecKey: buffer)
		Keygen(Seed, PubKey, SecKey, 8, 7, 13, 2)
	end,

	Sign = function(Msg: buffer, Rnd: buffer, SecKey: buffer, Ctx: buffer, Sig: buffer): boolean
		return Sign(Msg, Rnd, SecKey, Ctx, Sig, 8, 7, 13, 2, 524288, 261888, 60, 120, 75, 256)
	end,

	Verify = function(Msg: buffer, PubKey: buffer, Ctx: buffer, Sig: buffer): boolean
		return Verify(Msg, PubKey, Ctx, Sig, 8, 7, 13, 524288, 261888, 60, 120, 75, 256)
	end,

	GenerateKeys = function(): (buffer, buffer)
		local Seed = CSPRNG.RandomBytes(32)
		local PubKey = buffer.create(2592)
		local SecKey = buffer.create(4896)
		Mldsa.ML_DSA_87.KeyGen(Seed, PubKey, SecKey)
		return PubKey, SecKey
	end
}

Mldsa.PubKeyLen = Utils.PubKeyLen
Mldsa.SecKeyLen = Utils.SecKeyLen
Mldsa.SigLen = Utils.SigLen

return Mldsa]]></ProtectedString>
							<string name="ScriptGuid">{740242E9-6122-4480-AE29-F5995A074D40}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MlDSA</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX6C1A25703BCA408ABBACCD35F634CF6D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Finite field arithmetic modulo Q = 8380417
	
	Arithmetic operations over the prime field Z_q where q = 2^23 - 2^13 + 1.
	All operations maintain elements in canonical form [0, Q).

	Example usage:
		local Field = require(script)
		
		local A = 12345
		local B = 67890
		local Sum = Field.Add(A, B)
		local Product = Field.Multiply(A, B)
		local Inverse = Field.Inverse(A)
--]=]

--!strict
--!optimize 2
--!native

local Q = 8380417

local Field = {}

function Field.Add(A: number, B: number): number
	local Sum = A + B
	return if Sum >= Q then Sum - Q else Sum
end

function Field.Negate(A: number): number
	return if A == 0 then 0 else Q - A
end

function Field.Subtract(A: number, B: number): number
	local Diff = A - B
	return if Diff < 0 then Diff + Q else Diff
end

function Field.Multiply(A: number, B: number): number
	return (A * B) % Q
end

function Field.Power(Base: number, Exponent: number): number
	if Exponent == 0 then
		return 1
	end

	if Exponent == 1 then
		return Base % Q
	end

	local Result = 1
	local CurrentBase = Base % Q 
	local Exp = Exponent

	while Exp > 0 do
		if bit32.band(Exp, 1) == 1 then
			Result = Field.Multiply(Result, CurrentBase)
		end

		CurrentBase = Field.Multiply(CurrentBase, CurrentBase)
		Exp = bit32.rshift(Exp, 1)
	end

	return Result
end

function Field.Inverse(A: number): number
	return Field.Power(A, Q - 2)
end

function Field.Divide(A: number, B: number): number
	return Field.Multiply(A, Field.Inverse(B))
end

return Field]]></ProtectedString>
								<string name="ScriptGuid">{3767000C-A76F-4D18-B258-6BA7A9D422CE}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Field</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBA6F99B051BC4BBFA52FFCC3CEACBDCF">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Number Theoretic Transform for degree-255 polynomials
	
	 Forward and inverse NTT over Z_q for polynomial multiplication.
	Uses Cooley-Tukey and Gentleman-Sande algorithms with precomputed roots.

	Example usage:
		local NTT = require(script)
		
		local Poly = buffer.create(256 * 4) -- 256 coefficients, 4 bytes each
		NTT.ForwardNTT(Poly)
		-- Perform operations in NTT domain
		NTT.InverseNTT(Poly)
--]=]

--!strict
--!optimize 2
--!native

local Field = require("./Field")

local LOG2N = 8
local ZETA = 1753
local Q = 8380417

local N = bit32.lshift(1, LOG2N)
local INV_N = Field.Inverse(N)

local ZETA_EXP, ZETA_NEG_EXP = buffer.create(N * 4), buffer.create(N * 4) do
	for I = 0, N - 1 do
		local Reversed = 0
		local Value = I

		for J = 0, LOG2N - 1 do
			local Bit = bit32.band(bit32.rshift(Value, J), 1)
			Reversed = bit32.bxor(Reversed, bit32.lshift(Bit, LOG2N - 1 - J))
		end

		local ZetaExp = Field.Power(ZETA, Reversed)
		local ZetaNegExp = Field.Negate(ZetaExp)

		buffer.writeu32(ZETA_EXP, I * 4, ZetaExp)
		buffer.writeu32(ZETA_NEG_EXP, I * 4, ZetaNegExp)
	end
end

local Ntt = {}

function Ntt.ForwardNTT(Poly: buffer)
	local Zeta = ZETA_EXP
	local Modulus = Q

	for L = LOG2N - 1, 0, -1 do
		local Len = bit32.lshift(1, L)
		local LenX2 = bit32.lshift(Len, 1)
		local KBeg = bit32.rshift(N, L + 1)

		for Start = 0, N - 1, LenX2 do
			local KNow = KBeg + bit32.rshift(Start, L + 1)
			local ZetaExpValue = buffer.readu32(Zeta, KNow * 4)

			for I = Start, Start + Len - 1 do
				local IOffset = I * 4
				local ILenOffset = (I + Len) * 4

				local PolyI = buffer.readu32(Poly, IOffset)
				local PolyILen = buffer.readu32(Poly, ILenOffset)

				local Tmp = (ZetaExpValue * PolyILen) % Modulus

				local Sub = if PolyI >= Tmp then PolyI - Tmp else PolyI - Tmp + Modulus
				local Add = PolyI + Tmp
				Add = if Add >= Modulus then Add - Modulus else Add

				buffer.writeu32(Poly, ILenOffset, Sub)
				buffer.writeu32(Poly, IOffset, Add)
			end
		end
	end
end

function Ntt.ForwardNTTWithOffset(Poly: buffer, BaseOffset: number)
	local Zeta = ZETA_EXP
	local Modulus = Q

	for L = LOG2N - 1, 0, -1 do
		local Len = bit32.lshift(1, L)
		local LenX2 = bit32.lshift(Len, 1)
		local KBeg = bit32.rshift(N, L + 1)

		for Start = 0, N - 1, LenX2 do
			local KNow = KBeg + bit32.rshift(Start, L + 1)
			local ZetaExpValue = buffer.readu32(Zeta, KNow * 4)

			for I = Start, Start + Len - 1 do
				local IOffset = BaseOffset + I * 4
				local ILenOffset = BaseOffset + (I + Len) * 4

				local PolyI = buffer.readu32(Poly, IOffset)
				local PolyILen = buffer.readu32(Poly, ILenOffset)

				local Tmp = (ZetaExpValue * PolyILen) % Modulus

				local Sub = if PolyI >= Tmp then PolyI - Tmp else PolyI - Tmp + Modulus
				local Add = PolyI + Tmp
				Add = if Add >= Modulus then Add - Modulus else Add

				buffer.writeu32(Poly, ILenOffset, Sub)
				buffer.writeu32(Poly, IOffset, Add)
			end
		end
	end
end

function Ntt.InverseNTT(Poly: buffer)
	local Zeta = ZETA_NEG_EXP
	local Inv_n = INV_N
	local Modulus = Q

	for L = 0, LOG2N - 1 do
		local Len = bit32.lshift(1, L)
		local LenX2 = bit32.lshift(Len, 1)
		local KBeg = bit32.rshift(N, L) - 1

		for Start = 0, N - 1, LenX2 do
			local KNow = KBeg - bit32.rshift(Start, L + 1)
			local NegZetaExpValue = buffer.readu32(Zeta, KNow * 4)

			for I = Start, Start + Len - 1 do
				local IOffset = I * 4
				local ILenOffset = (I + Len) * 4

				local PolyI = buffer.readu32(Poly, IOffset)
				local PolyILen = buffer.readu32(Poly, ILenOffset)

				local Sum = PolyI + PolyILen
				Sum = if Sum >= Modulus then Sum - Modulus else Sum

				local Diff = if PolyI >= PolyILen then PolyI - PolyILen else PolyI - PolyILen + Modulus

				local Product = (Diff * NegZetaExpValue) % Modulus

				buffer.writeu32(Poly, IOffset, Sum)
				buffer.writeu32(Poly, ILenOffset, Product)
			end
		end
	end

	for I = 0, N - 1 do
		local Offset = I * 4
		local PolyValue = buffer.readu32(Poly, Offset)
		local Result = (PolyValue * Inv_n) % Modulus
		buffer.writeu32(Poly, Offset, Result)
	end
end

Ntt.ZETA_NEG_EXP = ZETA_NEG_EXP
Ntt.INV_N = INV_N

return Ntt]]></ProtectedString>
								<string name="ScriptGuid">{922C5112-8828-4945-BA3A-D441FF405425}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">NTT</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB362D058BD65446A9ED14F18F4B6A82A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Bit Packing and Unpacking Utilities for ML-DSA
	
	Serializes polynomial coefficients to byte arrays with various bit widths.
	Optimized for ML-DSA parameter sets using 32-bit word operations.
	
	Supported bit widths:
		3, 4, 6, 10, 13, 18, 20 (fast paths)
		Generic fallback for other widths
	
	Return type: nil (modifies buffers in place)
	Example usage:
		local BitPacking = require(script)
		
		local Poly = buffer.create(256 * 4)
		local Encoded = buffer.create(96)
		BitPacking.Encode(Poly, Encoded, 3)
		BitPacking.Decode(Encoded, Poly, 3)
--]=]

--!strict
--!optimize 2
--!native

local N = 256
local POLY_BYTES = N * 4

local BitPacking = {}

function BitPacking.Encode(Poly: buffer, Arr: buffer, Sbw: number)
	local ArrLen = buffer.len(Arr)
	buffer.fill(Arr, 0, 0, ArrLen)

	if Sbw == 3 then
		for I = 0, 31 do
			local PBase = I * 32
			local BBase = I * 3

			local P0 = bit32.band(buffer.readu32(Poly, PBase), 0x7)
			local P1 = bit32.band(buffer.readu32(Poly, PBase + 4), 0x7)
			local P2 = bit32.band(buffer.readu32(Poly, PBase + 8), 0x7)
			local P3 = bit32.band(buffer.readu32(Poly, PBase + 12), 0x7)
			local P4 = bit32.band(buffer.readu32(Poly, PBase + 16), 0x7)
			local P5 = bit32.band(buffer.readu32(Poly, PBase + 20), 0x7)
			local P6 = bit32.band(buffer.readu32(Poly, PBase + 24), 0x7)
			local P7 = bit32.band(buffer.readu32(Poly, PBase + 28), 0x7)

			local Byte0 = bit32.bor(P0, bit32.lshift(P1, 3), bit32.lshift(P2, 6))
			local Byte1 = bit32.bor(bit32.rshift(P2, 2), bit32.lshift(P3, 1), bit32.lshift(P4, 4), bit32.lshift(P5, 7))
			local Byte2 = bit32.bor(bit32.rshift(P5, 1), bit32.lshift(P6, 2), bit32.lshift(P7, 5))

			buffer.writeu8(Arr, BBase, Byte0)
			buffer.writeu8(Arr, BBase + 1, Byte1)
			buffer.writeu8(Arr, BBase + 2, Byte2)
		end

	elseif Sbw == 4 then
		for I = 0, 31 do
			local PBase = I * 32
			local BBase = I * 4

			local Word = buffer.readu32(Poly, PBase)
			local P0 = bit32.band(Word, 0xF)
			Word = buffer.readu32(Poly, PBase + 4)
			local P1 = bit32.band(Word, 0xF)
			Word = buffer.readu32(Poly, PBase + 8)
			local P2 = bit32.band(Word, 0xF)
			Word = buffer.readu32(Poly, PBase + 12)
			local P3 = bit32.band(Word, 0xF)
			Word = buffer.readu32(Poly, PBase + 16)
			local P4 = bit32.band(Word, 0xF)
			Word = buffer.readu32(Poly, PBase + 20)
			local P5 = bit32.band(Word, 0xF)
			Word = buffer.readu32(Poly, PBase + 24)
			local P6 = bit32.band(Word, 0xF)
			Word = buffer.readu32(Poly, PBase + 28)
			local P7 = bit32.band(Word, 0xF)

			buffer.writeu32(Arr, BBase, bit32.bor(
				P0, bit32.lshift(P1, 4), bit32.lshift(P2, 8), bit32.lshift(P3, 12),
				bit32.lshift(P4, 16), bit32.lshift(P5, 20), bit32.lshift(P6, 24), bit32.lshift(P7, 28)
				))
		end

	elseif Sbw == 6 then
		for I = 0, 63 do
			local PBase = I * 16
			local BBase = I * 3

			local P0 = bit32.band(buffer.readu32(Poly, PBase), 0x3F)
			local P1 = bit32.band(buffer.readu32(Poly, PBase + 4), 0x3F)
			local P2 = bit32.band(buffer.readu32(Poly, PBase + 8), 0x3F)
			local P3 = bit32.band(buffer.readu32(Poly, PBase + 12), 0x3F)

			local Packed = bit32.bor(P0, bit32.lshift(P1, 6), bit32.lshift(P2, 12), bit32.lshift(P3, 18))

			buffer.writeu8(Arr, BBase, bit32.band(Packed, 0xFF))
			buffer.writeu8(Arr, BBase + 1, bit32.band(bit32.rshift(Packed, 8), 0xFF))
			buffer.writeu8(Arr, BBase + 2, bit32.rshift(Packed, 16))
		end

	elseif Sbw == 10 then
		for I = 0, 63 do
			local PBase = I * 16
			local BBase = I * 5

			local P0 = bit32.band(buffer.readu32(Poly, PBase), 0x3FF)
			local P1 = bit32.band(buffer.readu32(Poly, PBase + 4), 0x3FF)
			local P2 = bit32.band(buffer.readu32(Poly, PBase + 8), 0x3FF)
			local P3 = bit32.band(buffer.readu32(Poly, PBase + 12), 0x3FF)

			local Lo = bit32.bor(P0, bit32.lshift(P1, 10), bit32.lshift(P2, 20))
			local Hi = bit32.bor(bit32.rshift(P2, 12), bit32.lshift(P3, 8))

			buffer.writeu32(Arr, BBase, Lo)
			buffer.writeu8(Arr, BBase + 4, bit32.band(Hi, 0xFF))
		end

	elseif Sbw == 13 then
		for I = 0, 31 do
			local PBase = I * 32
			local BBase = I * 13

			local P0 = bit32.band(buffer.readu32(Poly, PBase), 0x1FFF)
			local P1 = bit32.band(buffer.readu32(Poly, PBase + 4), 0x1FFF)
			local P2 = bit32.band(buffer.readu32(Poly, PBase + 8), 0x1FFF)
			local P3 = bit32.band(buffer.readu32(Poly, PBase + 12), 0x1FFF)
			local P4 = bit32.band(buffer.readu32(Poly, PBase + 16), 0x1FFF)
			local P5 = bit32.band(buffer.readu32(Poly, PBase + 20), 0x1FFF)
			local P6 = bit32.band(buffer.readu32(Poly, PBase + 24), 0x1FFF)
			local P7 = bit32.band(buffer.readu32(Poly, PBase + 28), 0x1FFF)

			local W0 = bit32.bor(P0, bit32.lshift(P1, 13), bit32.lshift(P2, 26))
			local W1 = bit32.bor(bit32.rshift(P2, 6), bit32.lshift(P3, 7), bit32.lshift(P4, 20))
			local W2 = bit32.bor(bit32.rshift(P4, 12), bit32.lshift(P5, 1), bit32.lshift(P6, 14), bit32.lshift(P7, 27))
			local W3 = bit32.rshift(P7, 5)

			buffer.writeu32(Arr, BBase, W0)
			buffer.writeu32(Arr, BBase + 4, W1)
			buffer.writeu32(Arr, BBase + 8, W2)
			buffer.writeu8(Arr, BBase + 12, W3)
		end

	elseif Sbw == 18 then
		for I = 0, 63 do
			local PBase = I * 16
			local BBase = I * 9

			local P0 = bit32.band(buffer.readu32(Poly, PBase), 0x3FFFF)
			local P1 = bit32.band(buffer.readu32(Poly, PBase + 4), 0x3FFFF)
			local P2 = bit32.band(buffer.readu32(Poly, PBase + 8), 0x3FFFF)
			local P3 = bit32.band(buffer.readu32(Poly, PBase + 12), 0x3FFFF)

			local W0 = bit32.bor(P0, bit32.lshift(P1, 18))
			local W1 = bit32.bor(bit32.rshift(P1, 14), bit32.lshift(P2, 4), bit32.lshift(P3, 22))
			local W2 = bit32.rshift(P3, 10)

			buffer.writeu32(Arr, BBase, W0)
			buffer.writeu32(Arr, BBase + 4, W1)
			buffer.writeu8(Arr, BBase + 8, W2)
		end

	elseif Sbw == 20 then
		for I = 0, 63 do
			local PBase = I * 16
			local BBase = I * 10

			local P0 = bit32.band(buffer.readu32(Poly, PBase), 0xFFFFF)
			local P1 = bit32.band(buffer.readu32(Poly, PBase + 4), 0xFFFFF)
			local P2 = bit32.band(buffer.readu32(Poly, PBase + 8), 0xFFFFF)
			local P3 = bit32.band(buffer.readu32(Poly, PBase + 12), 0xFFFFF)

			local W0 = bit32.bor(P0, bit32.lshift(P1, 20))
			local W1 = bit32.bor(bit32.rshift(P1, 12), bit32.lshift(P2, 8), bit32.lshift(P3, 28))
			local W2 = bit32.rshift(P3, 4)

			buffer.writeu32(Arr, BBase, W0)
			buffer.writeu32(Arr, BBase + 4, W1)
			buffer.writeu16(Arr, BBase + 8, W2)
		end

	else
		local Mask = bit32.lshift(1, Sbw) - 1
		local BitPos = 0

		for I = 0, N - 1 do
			local Value = bit32.band(buffer.readu32(Poly, I * 4), Mask)
			local BitsRemaining = Sbw

			while BitsRemaining > 0 do
				local ByteIdx = bit32.rshift(BitPos, 3)
				local BitOffset = bit32.band(BitPos, 7)
				local BitsInByte = math.min(BitsRemaining, 8 - BitOffset)

				local BitMask = bit32.lshift(1, BitsInByte) - 1
				local Bits = bit32.band(Value, BitMask)
				local Current = buffer.readu8(Arr, ByteIdx)

				buffer.writeu8(Arr, ByteIdx, bit32.bor(Current, bit32.lshift(Bits, BitOffset)))

				Value = bit32.rshift(Value, BitsInByte)
				BitPos += BitsInByte
				BitsRemaining -= BitsInByte
			end
		end
	end
end

function BitPacking.Decode(Arr: buffer, Poly: buffer, Sbw: number)
	buffer.fill(Poly, 0, 0, POLY_BYTES)

	if Sbw == 3 then
		for I = 0, 31 do
			local BBase = I * 3
			local PBase = I * 32

			local B0 = buffer.readu8(Arr, BBase)
			local B1 = buffer.readu8(Arr, BBase + 1)
			local B2 = buffer.readu8(Arr, BBase + 2)

			buffer.writeu32(Poly, PBase, bit32.band(B0, 0x7))
			buffer.writeu32(Poly, PBase + 4, bit32.band(bit32.rshift(B0, 3), 0x7))
			buffer.writeu32(Poly, PBase + 8, bit32.bor(bit32.rshift(B0, 6), bit32.lshift(bit32.band(B1, 0x1), 2)))
			buffer.writeu32(Poly, PBase + 12, bit32.band(bit32.rshift(B1, 1), 0x7))
			buffer.writeu32(Poly, PBase + 16, bit32.band(bit32.rshift(B1, 4), 0x7))
			buffer.writeu32(Poly, PBase + 20, bit32.bor(bit32.rshift(B1, 7), bit32.lshift(bit32.band(B2, 0x3), 1)))
			buffer.writeu32(Poly, PBase + 24, bit32.band(bit32.rshift(B2, 2), 0x7))
			buffer.writeu32(Poly, PBase + 28, bit32.rshift(B2, 5))
		end

	elseif Sbw == 4 then
		for I = 0, 31 do
			local BBase = I * 4
			local PBase = I * 32

			local Word = buffer.readu32(Arr, BBase)

			buffer.writeu32(Poly, PBase, bit32.band(Word, 0xF))
			buffer.writeu32(Poly, PBase + 4, bit32.band(bit32.rshift(Word, 4), 0xF))
			buffer.writeu32(Poly, PBase + 8, bit32.band(bit32.rshift(Word, 8), 0xF))
			buffer.writeu32(Poly, PBase + 12, bit32.band(bit32.rshift(Word, 12), 0xF))
			buffer.writeu32(Poly, PBase + 16, bit32.band(bit32.rshift(Word, 16), 0xF))
			buffer.writeu32(Poly, PBase + 20, bit32.band(bit32.rshift(Word, 20), 0xF))
			buffer.writeu32(Poly, PBase + 24, bit32.band(bit32.rshift(Word, 24), 0xF))
			buffer.writeu32(Poly, PBase + 28, bit32.rshift(Word, 28))
		end

	elseif Sbw == 6 then
		for I = 0, 63 do
			local BBase = I * 3
			local PBase = I * 16

			local B0 = buffer.readu8(Arr, BBase)
			local B1 = buffer.readu8(Arr, BBase + 1)
			local B2 = buffer.readu8(Arr, BBase + 2)

			local Packed = bit32.bor(B0, bit32.lshift(B1, 8), bit32.lshift(B2, 16))

			buffer.writeu32(Poly, PBase, bit32.band(Packed, 0x3F))
			buffer.writeu32(Poly, PBase + 4, bit32.band(bit32.rshift(Packed, 6), 0x3F))
			buffer.writeu32(Poly, PBase + 8, bit32.band(bit32.rshift(Packed, 12), 0x3F))
			buffer.writeu32(Poly, PBase + 12, bit32.rshift(Packed, 18))
		end

	elseif Sbw == 10 then
		for I = 0, 63 do
			local BBase = I * 5
			local PBase = I * 16

			local Lo = buffer.readu32(Arr, BBase)
			local Hi = buffer.readu8(Arr, BBase + 4)

			buffer.writeu32(Poly, PBase, bit32.band(Lo, 0x3FF))
			buffer.writeu32(Poly, PBase + 4, bit32.band(bit32.rshift(Lo, 10), 0x3FF))
			buffer.writeu32(Poly, PBase + 8, bit32.bor(bit32.rshift(Lo, 20), bit32.lshift(bit32.band(Hi, 0x3), 12)))
			buffer.writeu32(Poly, PBase + 12, bit32.rshift(Hi, 2))
		end

	elseif Sbw == 13 then
		for I = 0, 31 do
			local BBase = I * 13
			local PBase = I * 32

			local W0 = buffer.readu32(Arr, BBase)
			local W1 = buffer.readu32(Arr, BBase + 4)
			local W2 = buffer.readu32(Arr, BBase + 8)
			local W3 = buffer.readu8(Arr, BBase + 12)

			buffer.writeu32(Poly, PBase, bit32.band(W0, 0x1FFF))
			buffer.writeu32(Poly, PBase + 4, bit32.band(bit32.rshift(W0, 13), 0x1FFF))
			buffer.writeu32(Poly, PBase + 8, bit32.bor(bit32.rshift(W0, 26), bit32.lshift(bit32.band(W1, 0x7F), 6)))
			buffer.writeu32(Poly, PBase + 12, bit32.band(bit32.rshift(W1, 7), 0x1FFF))
			buffer.writeu32(Poly, PBase + 16, bit32.bor(bit32.rshift(W1, 20), bit32.lshift(bit32.band(W2, 0x1), 12)))
			buffer.writeu32(Poly, PBase + 20, bit32.band(bit32.rshift(W2, 1), 0x1FFF))
			buffer.writeu32(Poly, PBase + 24, bit32.band(bit32.rshift(W2, 14), 0x1FFF))
			buffer.writeu32(Poly, PBase + 28, bit32.bor(bit32.rshift(W2, 27), bit32.lshift(W3, 5)))
		end

	elseif Sbw == 18 then
		for I = 0, 63 do
			local BBase = I * 9
			local PBase = I * 16

			local W0 = buffer.readu32(Arr, BBase)
			local W1 = buffer.readu32(Arr, BBase + 4)
			local W2 = buffer.readu8(Arr, BBase + 8)

			buffer.writeu32(Poly, PBase, bit32.band(W0, 0x3FFFF))
			buffer.writeu32(Poly, PBase + 4, bit32.bor(bit32.rshift(W0, 18), bit32.lshift(bit32.band(W1, 0xF), 14)))
			buffer.writeu32(Poly, PBase + 8, bit32.band(bit32.rshift(W1, 4), 0x3FFFF))
			buffer.writeu32(Poly, PBase + 12, bit32.bor(bit32.rshift(W1, 22), bit32.lshift(W2, 10)))
		end

	elseif Sbw == 20 then
		for I = 0, 63 do
			local BBase = I * 10
			local PBase = I * 16

			local W0 = buffer.readu32(Arr, BBase)
			local W1 = buffer.readu32(Arr, BBase + 4)
			local W2 = buffer.readu16(Arr, BBase + 8)

			buffer.writeu32(Poly, PBase, bit32.band(W0, 0xFFFFF))
			buffer.writeu32(Poly, PBase + 4, bit32.bor(bit32.rshift(W0, 20), bit32.lshift(bit32.band(W1, 0xFF), 12)))
			buffer.writeu32(Poly, PBase + 8, bit32.bor(bit32.rshift(W1, 8), bit32.lshift(bit32.band(W2, 0xF), 24)))
			buffer.writeu32(Poly, PBase + 12, bit32.bor(bit32.rshift(W1, 28), bit32.lshift(W2, 4)))
		end

	else
		local Mask = bit32.lshift(1, Sbw) - 1
		local BitPos = 0

		for I = 0, N - 1 do
			local Value = 0
			local BitsCollected = 0

			while BitsCollected < Sbw do
				local ByteIdx = bit32.rshift(BitPos, 3)
				local BitOffset = bit32.band(BitPos, 7)
				local BitsAvailable = 8 - BitOffset
				local BitsToRead = math.min(Sbw - BitsCollected, BitsAvailable)

				local ByteVal = buffer.readu8(Arr, ByteIdx)
				local Extracted = bit32.band(bit32.rshift(ByteVal, BitOffset), bit32.lshift(1, BitsToRead) - 1)

				Value = bit32.bor(Value, bit32.lshift(Extracted, BitsCollected))

				BitPos += BitsToRead
				BitsCollected += BitsToRead
			end

			buffer.writeu32(Poly, I * 4, bit32.band(Value, Mask))
		end
	end
end

function BitPacking.EncodeHintBits(H: buffer, Arr: buffer, K: number, Omega: number)
	buffer.fill(Arr, 0, 0, Omega + K)

	local Idx = 0

	for I = 0, K - 1 do
		local PolyOffset = I * N * 4

		for J = 0, N - 1 do
			if buffer.readu32(H, PolyOffset + J * 4) ~= 0 then
				buffer.writeu8(Arr, Idx, J)
				Idx += 1

				if Idx >= Omega then
					break
				end
			end
		end

		buffer.writeu8(Arr, Omega + I, Idx)
	end
end

function BitPacking.DecodeHintBits(Arr: buffer, H: buffer, K: number, Omega: number): boolean
	buffer.fill(H, 0, 0, K * N * 4)

	local Idx = 0
	local Failed = false

	for I = 0, K - 1 do
		local PolyOffset = I * N * 4
		local Till = buffer.readu8(Arr, Omega + I)

		if Till < Idx or Till > Omega then
			Failed = true
		end

		if not Failed then
			local Prev = -1

			for J = Idx, Till - 1 do
				local Position = buffer.readu8(Arr, J)

				if Position <= Prev or Position >= N then
					Failed = true
					break
				end

				buffer.writeu32(H, PolyOffset + Position * 4, 1)
				Prev = Position
			end
		end

		Idx = Till
	end

	if not Failed then
		for I = Idx, Omega - 1 do
			if buffer.readu8(Arr, I) ~= 0 then
				Failed = true
				break
			end
		end
	end

	return Failed
end

return BitPacking]]></ProtectedString>
								<string name="ScriptGuid">{BC4A65E8-2D68-48C1-BF5B-C574F0E6CB9C}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Pack</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB1084556A0224F8CB7E20C412D2F2718">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Parameter validation for ML-DSA algorithms
	
	FIPS 204 specification.

	Example usage:
		local Params = require(script)
		
		local IsValid = Params.CheckKeygenParams(4, 4, 13, 2) -- ML-DSA-44
		local ValidEta = Params.CheckEta(2)
--]=]

--!strict
--!optimize 2
--!native

local Q = 8380417

local Params = {}

function Params.CheckEta(Eta: number): boolean
	return Eta == 2 or Eta == 4
end

function Params.CheckNonce(Nonce: number): boolean
	return Nonce == 0 or Nonce == 4 or Nonce == 5 or Nonce == 7
end

function Params.CheckGamma1(Gamma1: number): boolean
	return Gamma1 == bit32.lshift(1, 17) or Gamma1 == bit32.lshift(1, 19)
end

function Params.CheckGamma2(Gamma2: number): boolean
	return Gamma2 == math.floor((Q - 1) / 88) or Gamma2 == math.floor((Q - 1) / 32)
end

function Params.CheckTau(Tau: number): boolean
	return Tau == 39 or Tau == 49 or Tau == 60
end

function Params.CheckD(D: number): boolean
	return D == 13
end

function Params.CheckKeygenParams(K: number, L: number, D: number, Eta: number): boolean
	return (K == 4 and L == 4 and D == 13 and Eta == 2) or
		(K == 6 and L == 5 and D == 13 and Eta == 4) or
		(K == 8 and L == 7 and D == 13 and Eta == 2)
end

function Params.CheckSigningParams(K: number, L: number, D: number, Eta: number, Gamma1: number, Gamma2: number, Tau: number, Beta: number, Omega: number, Lambda: number): boolean
	return (K == 4 and L == 4 and D == 13 and Eta == 2 and 
		Gamma1 == bit32.lshift(1, 17) and 
		Gamma2 == math.floor((Q - 1) / 88) and 
		Tau == 39 and Beta == Tau * Eta and Omega == 80 and Lambda == 128) or
		(K == 6 and L == 5 and D == 13 and Eta == 4 and 
			Gamma1 == bit32.lshift(1, 19) and 
			Gamma2 == math.floor((Q - 1) / 32) and 
			Tau == 49 and Beta == Tau * Eta and Omega == 55 and Lambda == 192) or
		(K == 8 and L == 7 and D == 13 and Eta == 2 and 
			Gamma1 == bit32.lshift(1, 19) and 
			Gamma2 == math.floor((Q - 1) / 32) and 
			Tau == 60 and Beta == Tau * Eta and Omega == 75 and Lambda == 256)
end

function Params.CheckVerifyParams(K: number, L: number, D: number, Gamma1: number, Gamma2: number, Tau: number, Beta: number, Omega: number, Lambda: number): boolean
	return (K == 4 and L == 4 and D == 13 and 
		Gamma1 == bit32.lshift(1, 17) and 
		Gamma2 == math.floor((Q - 1) / 88) and 
		Tau == 39 and Beta == Tau * 2 and Omega == 80 and Lambda == 128) or
		(K == 6 and L == 5 and D == 13 and 
			Gamma1 == bit32.lshift(1, 19) and 
			Gamma2 == math.floor((Q - 1) / 32) and 
			Tau == 49 and Beta == Tau * 4 and Omega == 55 and Lambda == 192) or
		(K == 8 and L == 7 and D == 13 and 
			Gamma1 == bit32.lshift(1, 19) and 
			Gamma2 == math.floor((Q - 1) / 32) and 
			Tau == 60 and Beta == Tau * 2 and Omega == 75 and Lambda == 256)
end

return Params]]></ProtectedString>
								<string name="ScriptGuid">{E4738850-6635-4D3D-A2BE-6C8690D70658}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Params</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7CBA12E5FD6D494A89CED851BEC60CA4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Vector operations on degree-255 polynomials
	
	Works on vectors of polynomials including matrix multiplication,
	NTT transforms, and encoding/decoding for ML-DSA.

	Example usage:
		local PolyVec = require(script)
		
		local Vec = buffer.create(4 * 256 * 4) -- 4 polynomials
		PolyVec.ForwardNTT(Vec, 4)
		local Norm = PolyVec.InfinityNorm(Vec, 4)
--]=]

--!strict
--!optimize 2
--!native

local Field = require("./Field")
local NTT = require("./NTT")
local BitPacking = require("./Pack")

local LOG2N = 8
local ZETA = 1753
local Q = 8380417

local N = 256
local INV_N = Field.Inverse(N)

local ZETA_EXP, ZETA_NEG_EXP = buffer.create(N * 4), buffer.create(N * 4) do
	for I = 0, N - 1 do
		local Reversed = 0
		local Value = I

		for J = 0, LOG2N - 1 do
			local Bit = bit32.band(bit32.rshift(Value, J), 1)
			Reversed = bit32.bxor(Reversed, bit32.lshift(Bit, LOG2N - 1 - J))
		end

		local ZetaExp = Field.Power(ZETA, Reversed)
		local ZetaNegExp = Field.Negate(ZetaExp)

		buffer.writeu32(ZETA_EXP, I * 4, ZetaExp)
		buffer.writeu32(ZETA_NEG_EXP, I * 4, ZetaNegExp)
	end
end

local PolyVec = {}

function PolyVec.ForwardNTT(Vec: buffer, K: number)
	local Num = N
	for I = 0, K - 1 do
		local Offset = I * Num * 4
		NTT.ForwardNTTWithOffset(Vec, Offset)
	end
end

function PolyVec.InverseNTT(Vec: buffer, K: number)
	local Zeta = ZETA_NEG_EXP
	local InvN = INV_N
	local Num = N
	local Modulus = Q
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for L = 0, 7 do
			local Len = bit32.lshift(1, L)
			local LenX2 = bit32.lshift(Len, 1)
			local KBeg = bit32.rshift(Num, L) - 1

			for Start = 0, Num - 1, LenX2 do
				local KNow = KBeg - bit32.rshift(Start, L + 1)
				local NegZetaExpValue = buffer.readu32(Zeta, KNow * 4)

				for J = Start, Start + Len - 1 do
					local JOffset = Offset + J * 4
					local JLenOffset = Offset + (J + Len) * 4

					local PolyJ = buffer.readu32(Vec, JOffset)
					local PolyJLen = buffer.readu32(Vec, JLenOffset)

					local Sum = PolyJ + PolyJLen
					Sum = if Sum >= Modulus then Sum - Modulus else Sum

					local Diff = if PolyJ >= PolyJLen then PolyJ - PolyJLen else PolyJ - PolyJLen + Modulus
					local Product = (Diff * NegZetaExpValue) % Modulus

					buffer.writeu32(Vec, JOffset, Sum)
					buffer.writeu32(Vec, JLenOffset, Product)
				end
			end
		end

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local PolyValue = buffer.readu32(Vec, JOffset)
			local Result = (PolyValue * InvN) % Modulus
			buffer.writeu32(Vec, JOffset, Result)
		end
	end
end

function PolyVec.Power2Round(PolyVec: buffer, PolyHi: buffer, PolyLo: buffer, K: number, D: number)
	local Max = bit32.lshift(1, D - 1)
	local Num = N
	local Modulus = Q
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local R = buffer.readu32(PolyVec, JOffset)

			local T1 = R + Max - 1
			local T2 = bit32.rshift(T1, D)
			local T3 = bit32.lshift(T2, D)

			local Hi = T2
			local Lo = if R >= T3 then R - T3 else R - T3 + Modulus

			buffer.writeu32(PolyHi, JOffset, Hi)
			buffer.writeu32(PolyLo, JOffset, Lo)
		end
	end
end

function PolyVec.MatrixMultiply(A: buffer, B: buffer, C: buffer, ARows: number, ACols: number, BRows: number, BCols: number)
	local Num = N
	local Modulus = Q
	
	buffer.fill(C, 0, 0, ARows * BCols * N * 4)

	for I = 0, ARows - 1 do
		for J = 0, BCols - 1 do
			local COffset = (I * BCols + J) * Num * 4

			for K = 0, ACols - 1 do
				local AOffset = (I * ACols + K) * Num * 4
				local BOffset = (K * BCols + J) * Num * 4

				for L = 0, Num - 1 do
					local ElementOffset = L * 4
					local AValue = buffer.readu32(A, AOffset + ElementOffset)
					local BValue = buffer.readu32(B, BOffset + ElementOffset)

					local Product = (AValue * BValue) % Modulus

					local CValue = buffer.readu32(C, COffset + ElementOffset)
					local Sum = CValue + Product
					Sum = if Sum >= Modulus then Sum - Modulus else Sum

					buffer.writeu32(C, COffset + ElementOffset, Sum)
				end
			end
		end
	end
end

function PolyVec.AddTo(Src: buffer, Dst: buffer, K: number)
	local TotalElements = K * N
	local Modulus = Q
	
	for I = 0, TotalElements - 1 do
		local Offset = I * 4
		local SrcValue = buffer.readu32(Src, Offset)
		local DstValue = buffer.readu32(Dst, Offset)

		local Sum = DstValue + SrcValue
		Sum = if Sum >= Modulus then Sum - Modulus else Sum

		buffer.writeu32(Dst, Offset, Sum)
	end
end

function PolyVec.Negate(Vec: buffer, K: number)
	local TotalElements = K * N
	local Modulus = Q
	
	for I = 0, TotalElements - 1 do
		local Offset = I * 4
		local Value = buffer.readu32(Vec, Offset)
		local Negated = if Value == 0 then 0 else Modulus - Value

		buffer.writeu32(Vec, Offset, Negated)
	end
end

function PolyVec.SubFromX(Vec: buffer, K: number, X: number)
	local Modulus = Q
	local Num = N
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local PolyValue = buffer.readu32(Vec, JOffset)

			local Result = if X >= PolyValue then X - PolyValue else X - PolyValue + Modulus

			buffer.writeu32(Vec, JOffset, Result)
		end
	end
end

function PolyVec.Encode(Src: buffer, Dst: buffer, K: number, Sbw: number)
	local PolyByteLength = math.floor((N * Sbw) / 8)
	local Num = N

	for I = 0, K - 1 do
		local SrcOffset = I * Num * 4
		local DstOffset = I * PolyByteLength

		if Sbw == 3 then
			local ItrCnt = 32
			for J = 0, ItrCnt - 1 do
				local POffset = SrcOffset + J * 32
				local BOffset = DstOffset + J * 3

				local P0 = bit32.band(buffer.readu32(Src, POffset + 0), 0x7)
				local P1 = bit32.band(buffer.readu32(Src, POffset + 4), 0x7)
				local P2 = bit32.band(buffer.readu32(Src, POffset + 8), 0x7)
				local P3 = bit32.band(buffer.readu32(Src, POffset + 12), 0x7)
				local P4 = bit32.band(buffer.readu32(Src, POffset + 16), 0x7)
				local P5 = bit32.band(buffer.readu32(Src, POffset + 20), 0x7)
				local P6 = bit32.band(buffer.readu32(Src, POffset + 24), 0x7)
				local P7 = bit32.band(buffer.readu32(Src, POffset + 28), 0x7)

				buffer.writeu8(Dst, BOffset + 0, bit32.bor(bit32.lshift(bit32.band(P2, 0x3), 6), bit32.lshift(P1, 3), P0))
				buffer.writeu8(Dst, BOffset + 1, bit32.bor(bit32.lshift(bit32.band(P5, 0x1), 7), bit32.lshift(P4, 4), bit32.lshift(P3, 1), bit32.rshift(P2, 2)))
				buffer.writeu8(Dst, BOffset + 2, bit32.bor(bit32.lshift(P7, 5), bit32.lshift(P6, 2), bit32.rshift(P5, 1)))
			end
		elseif Sbw == 4 then
			for J = 0, 127 do
				local POffset = SrcOffset + J * 8
				local P0 = bit32.band(buffer.readu32(Src, POffset), 0xF)
				local P1 = bit32.band(buffer.readu32(Src, POffset + 4), 0xF)
				buffer.writeu8(Dst, DstOffset + J, bit32.bor(bit32.lshift(P1, 4), P0))
			end
		elseif Sbw == 6 then
			for J = 0, 63 do
				local POffset = SrcOffset + J * 16
				local BOffset = DstOffset + J * 3

				local P0 = bit32.band(buffer.readu32(Src, POffset + 0), 0x3F)
				local P1 = bit32.band(buffer.readu32(Src, POffset + 4), 0x3F)
				local P2 = bit32.band(buffer.readu32(Src, POffset + 8), 0x3F)
				local P3 = bit32.band(buffer.readu32(Src, POffset + 12), 0x3F)

				buffer.writeu8(Dst, BOffset + 0, bit32.bor(bit32.lshift(bit32.band(P1, 0x3), 6), P0))
				buffer.writeu8(Dst, BOffset + 1, bit32.bor(bit32.lshift(bit32.band(P2, 0xF), 4), bit32.rshift(P1, 2)))
				buffer.writeu8(Dst, BOffset + 2, bit32.bor(bit32.lshift(P3, 2), bit32.rshift(P2, 4)))
			end
		elseif Sbw == 10 then
			for J = 0, 63 do
				local POffset = SrcOffset + J * 16
				local BOffset = DstOffset + J * 5

				local P0 = bit32.band(buffer.readu32(Src, POffset + 0), 0x3FF)
				local P1 = bit32.band(buffer.readu32(Src, POffset + 4), 0x3FF)
				local P2 = bit32.band(buffer.readu32(Src, POffset + 8), 0x3FF)
				local P3 = bit32.band(buffer.readu32(Src, POffset + 12), 0x3FF)

				buffer.writeu8(Dst, BOffset + 0, bit32.band(P0, 0xFF))
				buffer.writeu8(Dst, BOffset + 1, bit32.bor(bit32.lshift(bit32.band(P1, 0x3F), 2), bit32.rshift(P0, 8)))
				buffer.writeu8(Dst, BOffset + 2, bit32.bor(bit32.lshift(bit32.band(P2, 0xF), 4), bit32.rshift(P1, 6)))
				buffer.writeu8(Dst, BOffset + 3, bit32.bor(bit32.lshift(bit32.band(P3, 0x3), 6), bit32.rshift(P2, 4)))
				buffer.writeu8(Dst, BOffset + 4, bit32.rshift(P3, 2))
			end
		elseif Sbw == 13 then
			for J = 0, 31 do
				local POffset = SrcOffset + J * 32
				local BOffset = DstOffset + J * 13

				local P0 = bit32.band(buffer.readu32(Src, POffset + 0), 0x1FFF)
				local P1 = bit32.band(buffer.readu32(Src, POffset + 4), 0x1FFF)
				local P2 = bit32.band(buffer.readu32(Src, POffset + 8), 0x1FFF)
				local P3 = bit32.band(buffer.readu32(Src, POffset + 12), 0x1FFF)
				local P4 = bit32.band(buffer.readu32(Src, POffset + 16), 0x1FFF)
				local P5 = bit32.band(buffer.readu32(Src, POffset + 20), 0x1FFF)
				local P6 = bit32.band(buffer.readu32(Src, POffset + 24), 0x1FFF)
				local P7 = bit32.band(buffer.readu32(Src, POffset + 28), 0x1FFF)

				buffer.writeu8(Dst, BOffset + 0, bit32.band(P0, 0xFF))
				buffer.writeu8(Dst, BOffset + 1, bit32.bor(bit32.lshift(bit32.band(P1, 0x7), 5), bit32.rshift(P0, 8)))
				buffer.writeu8(Dst, BOffset + 2, bit32.rshift(P1, 3))
				buffer.writeu8(Dst, BOffset + 3, bit32.bor(bit32.lshift(bit32.band(P2, 0x3F), 2), bit32.rshift(P1, 11)))
				buffer.writeu8(Dst, BOffset + 4, bit32.bor(bit32.lshift(bit32.band(P3, 0x1), 7), bit32.rshift(P2, 6)))
				buffer.writeu8(Dst, BOffset + 5, bit32.rshift(P3, 1))
				buffer.writeu8(Dst, BOffset + 6, bit32.bor(bit32.lshift(bit32.band(P4, 0xF), 4), bit32.rshift(P3, 9)))
				buffer.writeu8(Dst, BOffset + 7, bit32.rshift(P4, 4))
				buffer.writeu8(Dst, BOffset + 8, bit32.bor(bit32.lshift(bit32.band(P5, 0x7F), 1), bit32.rshift(P4, 12)))
				buffer.writeu8(Dst, BOffset + 9, bit32.bor(bit32.lshift(bit32.band(P6, 0x3), 6), bit32.rshift(P5, 7)))
				buffer.writeu8(Dst, BOffset + 10, bit32.rshift(P6, 2))
				buffer.writeu8(Dst, BOffset + 11, bit32.bor(bit32.lshift(bit32.band(P7, 0x1F), 3), bit32.rshift(P6, 10)))
				buffer.writeu8(Dst, BOffset + 12, bit32.rshift(P7, 5))
			end
		elseif Sbw == 18 then
			for J = 0, 63 do
				local POffset = SrcOffset + J * 16
				local BOffset = DstOffset + J * 9

				local P0 = bit32.band(buffer.readu32(Src, POffset + 0), 0x3FFFF)
				local P1 = bit32.band(buffer.readu32(Src, POffset + 4), 0x3FFFF)
				local P2 = bit32.band(buffer.readu32(Src, POffset + 8), 0x3FFFF)
				local P3 = bit32.band(buffer.readu32(Src, POffset + 12), 0x3FFFF)

				buffer.writeu8(Dst, BOffset + 0, bit32.band(P0, 0xFF))
				buffer.writeu8(Dst, BOffset + 1, bit32.band(bit32.rshift(P0, 8), 0xFF))
				buffer.writeu8(Dst, BOffset + 2, bit32.bor(bit32.rshift(P0, 16), bit32.lshift(bit32.band(P1, 0x3F), 2)))
				buffer.writeu8(Dst, BOffset + 3, bit32.band(bit32.rshift(P1, 6), 0xFF))
				buffer.writeu8(Dst, BOffset + 4, bit32.bor(bit32.rshift(P1, 14), bit32.lshift(bit32.band(P2, 0xF), 4)))
				buffer.writeu8(Dst, BOffset + 5, bit32.band(bit32.rshift(P2, 4), 0xFF))
				buffer.writeu8(Dst, BOffset + 6, bit32.bor(bit32.rshift(P2, 12), bit32.lshift(bit32.band(P3, 0x3), 6)))
				buffer.writeu8(Dst, BOffset + 7, bit32.band(bit32.rshift(P3, 2), 0xFF))
				buffer.writeu8(Dst, BOffset + 8, bit32.rshift(P3, 10))
			end
		elseif Sbw == 20 then
			for J = 0, 63 do
				local POffset = SrcOffset + J * 16
				local BOffset = DstOffset + J * 10

				local P0 = bit32.band(buffer.readu32(Src, POffset + 0), 0xFFFFF)
				local P1 = bit32.band(buffer.readu32(Src, POffset + 4), 0xFFFFF)
				local P2 = bit32.band(buffer.readu32(Src, POffset + 8), 0xFFFFF)
				local P3 = bit32.band(buffer.readu32(Src, POffset + 12), 0xFFFFF)

				buffer.writeu8(Dst, BOffset + 0, bit32.band(P0, 0xFF))
				buffer.writeu8(Dst, BOffset + 1, bit32.band(bit32.rshift(P0, 8), 0xFF))
				buffer.writeu8(Dst, BOffset + 2, bit32.bor(bit32.rshift(P0, 16), bit32.lshift(bit32.band(P1, 0xF), 4)))
				buffer.writeu8(Dst, BOffset + 3, bit32.band(bit32.rshift(P1, 4), 0xFF))
				buffer.writeu8(Dst, BOffset + 4, bit32.band(bit32.rshift(P1, 12), 0xFF))
				buffer.writeu8(Dst, BOffset + 5, bit32.band(P2, 0xFF))
				buffer.writeu8(Dst, BOffset + 6, bit32.band(bit32.rshift(P2, 8), 0xFF))
				buffer.writeu8(Dst, BOffset + 7, bit32.bor(bit32.rshift(P2, 16), bit32.lshift(bit32.band(P3, 0xF), 4)))
				buffer.writeu8(Dst, BOffset + 8, bit32.band(bit32.rshift(P3, 4), 0xFF))
				buffer.writeu8(Dst, BOffset + 9, bit32.rshift(P3, 12))
			end
		else
			local PolyBuffer = buffer.create(N * 4)
			local ByteBuffer = buffer.create(PolyByteLength)
			buffer.copy(PolyBuffer, 0, Src, SrcOffset, N * 4)
			BitPacking.Encode(PolyBuffer, ByteBuffer, Sbw)
			buffer.copy(Dst, DstOffset, ByteBuffer, 0, PolyByteLength)
		end
	end
end

function PolyVec.Decode(Src: buffer, Dst: buffer, K: number, Sbw: number)
	local PolyByteLength = math.floor((N * Sbw) / 8)
	local Num = N

	for I = 0, K - 1 do
		local SrcOffset = I * PolyByteLength
		local DstOffset = I * Num * 4

		if Sbw == 3 then
			for J = 0, 31 do
				local BOffset = SrcOffset + J * 3
				local POffset = DstOffset + J * 32

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)

				buffer.writeu32(Dst, POffset + 0, bit32.band(B0, 0x7))
				buffer.writeu32(Dst, POffset + 4, bit32.band(bit32.rshift(B0, 3), 0x7))
				buffer.writeu32(Dst, POffset + 8, bit32.bor(bit32.rshift(B0, 6), bit32.lshift(bit32.band(B1, 0x1), 2)))
				buffer.writeu32(Dst, POffset + 12, bit32.band(bit32.rshift(B1, 1), 0x7))
				buffer.writeu32(Dst, POffset + 16, bit32.band(bit32.rshift(B1, 4), 0x7))
				buffer.writeu32(Dst, POffset + 20, bit32.bor(bit32.rshift(B1, 7), bit32.lshift(bit32.band(B2, 0x3), 1)))
				buffer.writeu32(Dst, POffset + 24, bit32.band(bit32.rshift(B2, 2), 0x7))
				buffer.writeu32(Dst, POffset + 28, bit32.rshift(B2, 5))
			end
		elseif Sbw == 4 then
			for J = 0, 127 do
				local B = buffer.readu8(Src, SrcOffset + J)
				local POffset = DstOffset + J * 8
				buffer.writeu32(Dst, POffset, bit32.band(B, 0xF))
				buffer.writeu32(Dst, POffset + 4, bit32.rshift(B, 4))
			end
		elseif Sbw == 6 then
			for J = 0, 63 do
				local BOffset = SrcOffset + J * 3
				local POffset = DstOffset + J * 16

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)

				buffer.writeu32(Dst, POffset + 0, bit32.band(B0, 0x3F))
				buffer.writeu32(Dst, POffset + 4, bit32.bor(bit32.rshift(B0, 6), bit32.lshift(bit32.band(B1, 0xF), 2)))
				buffer.writeu32(Dst, POffset + 8, bit32.bor(bit32.rshift(B1, 4), bit32.lshift(bit32.band(B2, 0x3), 4)))
				buffer.writeu32(Dst, POffset + 12, bit32.rshift(B2, 2))
			end
		elseif Sbw == 10 then
			for J = 0, 63 do
				local BOffset = SrcOffset + J * 5
				local POffset = DstOffset + J * 16

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)
				local B3 = buffer.readu8(Src, BOffset + 3)
				local B4 = buffer.readu8(Src, BOffset + 4)

				buffer.writeu32(Dst, POffset + 0, bit32.bor(B0, bit32.lshift(bit32.band(B1, 0x3), 8)))
				buffer.writeu32(Dst, POffset + 4, bit32.bor(bit32.rshift(B1, 2), bit32.lshift(bit32.band(B2, 0xF), 6)))
				buffer.writeu32(Dst, POffset + 8, bit32.bor(bit32.rshift(B2, 4), bit32.lshift(bit32.band(B3, 0x3F), 4)))
				buffer.writeu32(Dst, POffset + 12, bit32.bor(bit32.rshift(B3, 6), bit32.lshift(B4, 2)))
			end
		elseif Sbw == 13 then
			for J = 0, 31 do
				local BOffset = SrcOffset + J * 13
				local POffset = DstOffset + J * 32

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)
				local B3 = buffer.readu8(Src, BOffset + 3)
				local B4 = buffer.readu8(Src, BOffset + 4)
				local B5 = buffer.readu8(Src, BOffset + 5)
				local B6 = buffer.readu8(Src, BOffset + 6)
				local B7 = buffer.readu8(Src, BOffset + 7)
				local B8 = buffer.readu8(Src, BOffset + 8)
				local B9 = buffer.readu8(Src, BOffset + 9)
				local B10 = buffer.readu8(Src, BOffset + 10)
				local B11 = buffer.readu8(Src, BOffset + 11)
				local B12 = buffer.readu8(Src, BOffset + 12)

				buffer.writeu32(Dst, POffset + 0, bit32.bor(B0, bit32.lshift(bit32.band(B1, 0x1F), 8)))
				buffer.writeu32(Dst, POffset + 4, bit32.bor(bit32.rshift(B1, 5), bit32.lshift(B2, 3), bit32.lshift(bit32.band(B3, 0x3), 11)))
				buffer.writeu32(Dst, POffset + 8, bit32.bor(bit32.rshift(B3, 2), bit32.lshift(bit32.band(B4, 0x7F), 6)))
				buffer.writeu32(Dst, POffset + 12, bit32.bor(bit32.rshift(B4, 7), bit32.lshift(B5, 1), bit32.lshift(bit32.band(B6, 0xF), 9)))
				buffer.writeu32(Dst, POffset + 16, bit32.bor(bit32.rshift(B6, 4), bit32.lshift(B7, 4), bit32.lshift(bit32.band(B8, 0x1), 12)))
				buffer.writeu32(Dst, POffset + 20, bit32.bor(bit32.rshift(B8, 1), bit32.lshift(bit32.band(B9, 0x3F), 7)))
				buffer.writeu32(Dst, POffset + 24, bit32.bor(bit32.rshift(B9, 6), bit32.lshift(B10, 2), bit32.lshift(bit32.band(B11, 0x7), 10)))
				buffer.writeu32(Dst, POffset + 28, bit32.bor(bit32.rshift(B11, 3), bit32.lshift(B12, 5)))
			end
		elseif Sbw == 18 then
			for J = 0, 63 do
				local BOffset = SrcOffset + J * 9
				local POffset = DstOffset + J * 16

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)
				local B3 = buffer.readu8(Src, BOffset + 3)
				local B4 = buffer.readu8(Src, BOffset + 4)
				local B5 = buffer.readu8(Src, BOffset + 5)
				local B6 = buffer.readu8(Src, BOffset + 6)
				local B7 = buffer.readu8(Src, BOffset + 7)
				local B8 = buffer.readu8(Src, BOffset + 8)

				buffer.writeu32(Dst, POffset + 0, bit32.bor(B0, bit32.lshift(B1, 8), bit32.lshift(bit32.band(B2, 0x3), 16)))
				buffer.writeu32(Dst, POffset + 4, bit32.bor(bit32.rshift(B2, 2), bit32.lshift(B3, 6), bit32.lshift(bit32.band(B4, 0xF), 14)))
				buffer.writeu32(Dst, POffset + 8, bit32.bor(bit32.rshift(B4, 4), bit32.lshift(B5, 4), bit32.lshift(bit32.band(B6, 0x3F), 12)))
				buffer.writeu32(Dst, POffset + 12, bit32.bor(bit32.rshift(B6, 6), bit32.lshift(B7, 2), bit32.lshift(B8, 10)))
			end
		elseif Sbw == 20 then
			for J = 0, 63 do
				local BOffset = SrcOffset + J * 10
				local POffset = DstOffset + J * 16

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)
				local B3 = buffer.readu8(Src, BOffset + 3)
				local B4 = buffer.readu8(Src, BOffset + 4)
				local B5 = buffer.readu8(Src, BOffset + 5)
				local B6 = buffer.readu8(Src, BOffset + 6)
				local B7 = buffer.readu8(Src, BOffset + 7)
				local B8 = buffer.readu8(Src, BOffset + 8)
				local B9 = buffer.readu8(Src, BOffset + 9)

				buffer.writeu32(Dst, POffset + 0, bit32.bor(B0, bit32.lshift(B1, 8), bit32.lshift(bit32.band(B2, 0xF), 16)))
				buffer.writeu32(Dst, POffset + 4, bit32.bor(bit32.rshift(B2, 4), bit32.lshift(B3, 4), bit32.lshift(B4, 12)))
				buffer.writeu32(Dst, POffset + 8, bit32.bor(B5, bit32.lshift(B6, 8), bit32.lshift(bit32.band(B7, 0xF), 16)))
				buffer.writeu32(Dst, POffset + 12, bit32.bor(bit32.rshift(B7, 4), bit32.lshift(B8, 4), bit32.lshift(B9, 12)))
			end
		else
			local ByteBuffer = buffer.create(PolyByteLength)
			local PolyBuffer = buffer.create(N * 4)
			buffer.copy(ByteBuffer, 0, Src, SrcOffset, PolyByteLength)
			BitPacking.Decode(ByteBuffer, PolyBuffer, Sbw)
			buffer.copy(Dst, DstOffset, PolyBuffer, 0, N * 4)
		end
	end
end

function PolyVec.HighBits(Src: buffer, Dst: buffer, K: number, Alpha: number)
	local T0 = bit32.rshift(Alpha, 1)
	local T1 = Q - 1
	local Modulus = Q
	local Num = N
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local R = buffer.readu32(Src, JOffset)

			local T2 = R + T0 - 1
			local T3 = math.floor(T2 / Alpha)
			local T4 = T3 * Alpha

			local R0 = if R >= T4 then R - T4 else R - T4 + Modulus
			local T5 = if R >= R0 then R - R0 else R - R0 + Modulus

			local Flag = (T5 == T1)
			local R1 = if Flag then 0 else T3

			buffer.writeu32(Dst, JOffset, R1)
		end
	end
end

function PolyVec.LowBits(Src: buffer, Dst: buffer, K: number, Alpha: number)
	local T0 = bit32.rshift(Alpha, 1)
	local T1 = Q - 1
	
	local Modulus = Q
	local Num = N
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local R = buffer.readu32(Src, JOffset)

			local T2 = R + T0 - 1
			local T3 = math.floor(T2 / Alpha)
			local T4 = T3 * Alpha

			local R0 = if R >= T4 then R - T4 else R - T4 + Modulus
			local T5 = if R >= R0 then R - R0 else R - R0 + Modulus

			local Flag = (T5 == T1)
			local R0_ = if Flag then (if R0 >= 1 then R0 - 1 else R0 - 1 + Modulus) else R0

			buffer.writeu32(Dst, JOffset, R0_)
		end
	end
end

function PolyVec.MultiplyByPoly(PolyBuffer: buffer, SrcVec: buffer, DstVec: buffer, K: number)
	local Modulus = Q
	local Num = N
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local PolyValue = buffer.readu32(PolyBuffer, J * 4)
			local SrcValue = buffer.readu32(SrcVec, JOffset)

			local Product = (PolyValue * SrcValue) % Modulus

			buffer.writeu32(DstVec, JOffset, Product)
		end
	end
end

function PolyVec.InfinityNorm(Vec: buffer, K: number): number
	local Result = 0
	local QBy2 = math.floor(Q / 2)
	local Modulus = Q
	local Num = N
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local PolyValue = buffer.readu32(Vec, JOffset)

			local CurrentValue = if PolyValue > QBy2 then (if PolyValue == 0 then 0 else Modulus - PolyValue) else PolyValue
			if CurrentValue > Result then
				Result = CurrentValue
			end
		end
	end

	return Result
end

function PolyVec.MakeHint(PolyA: buffer, PolyB: buffer, PolyC: buffer, K: number, Alpha: number)
	local T0 = bit32.rshift(Alpha, 1)
	local T1 = Q - 1

	local Num = N
	local Modulus = Q
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local Z = buffer.readu32(PolyA, JOffset)
			local R = buffer.readu32(PolyB, JOffset)

			local T2_R = R + T0 - 1
			local T3_R = math.floor(T2_R / Alpha)
			local T4_R = T3_R * Alpha
			local R0_R = if R >= T4_R then R - T4_R else R - T4_R + Modulus
			local T5_R = if R >= R0_R then R - R0_R else R - R0_R + Modulus
			local Flag_R = (T5_R == T1)
			local R1 = if Flag_R then 0 else T3_R

			local Sum = R + Z
			Sum = if Sum >= Modulus then Sum - Modulus else Sum

			local T2_V = Sum + T0 - 1
			local T3_V = math.floor(T2_V / Alpha)
			local T4_V = T3_V * Alpha
			local R0_V = if Sum >= T4_V then Sum - T4_V else Sum - T4_V + Modulus
			local T5_V = if Sum >= R0_V then Sum - R0_V else Sum - R0_V + Modulus
			local Flag_V = (T5_V == T1)
			local V1 = if Flag_V then 0 else T3_V

			local Hint = if R1 ~= V1 then 1 else 0
			buffer.writeu32(PolyC, JOffset, Hint)
		end
	end
end

function PolyVec.UseHint(PolyH: buffer, PolyR: buffer, PolyRZ: buffer, K: number, Alpha: number)
	local M = math.floor((Q - 1) / Alpha)
	local T0 = bit32.rshift(Alpha, 1)
	local T1 = Q - T0
	local T1_Q = Q - 1
	local Modulus = Q

	for I = 0, K - 1 do
		local Offset = I * N * 4

		for J = 0, N - 1 do
			local JOffset = Offset + J * 4
			local H = buffer.readu32(PolyH, JOffset)
			local R = buffer.readu32(PolyR, JOffset)

			local T2 = R + T0 - 1
			local T3 = math.floor(T2 / Alpha)
			local T4 = T3 * Alpha
			
			local R0 = if R >= T4 then R - T4 else R - T4 + Modulus
			
			local T5 = if R >= R0 then R - R0 else R - R0 + Modulus
			local Flag = (T5 == T1_Q)
			
			local R1 = if Flag then 0 else T3
			local R0_ = if Flag then (if R0 >= 1 then R0 - 1 else R0 - 1 + Modulus) else R0

			if H == 1 then
				if R0_ > 0 and R0_ < T1 then
					R1 += 1
				else
					R1 -= 1
				end
			end

			buffer.writeu32(PolyRZ, JOffset, (R1 % M + M) % M)
		end
	end
end

function PolyVec.Count1s(Vec: buffer, K: number): number
	local Count = 0

	for I = 0, K * N - 1 do
		local Value = buffer.readu32(Vec, I * 4)
		Count += Value
	end

	return Count
end

function PolyVec.LeftShift(Vec: buffer, K: number, D: number)
	local Num = N
	local Modulus = Q
	
	for I = 0, K - 1 do
		local Offset = I * Num * 4

		for J = 0, Num - 1 do
			local JOffset = Offset + J * 4
			local PolyValue = buffer.readu32(Vec, JOffset)

			local Shifted = bit32.lshift(PolyValue, D)
			local Result = if Shifted >= Modulus then Shifted % Modulus else Shifted

			buffer.writeu32(Vec, JOffset, Result)
		end
	end
end

function PolyVec.Copy(Src: buffer, Dst: buffer, K: number)
	buffer.copy(Dst, 0, Src, 0, K * N * 4)
end

return PolyVec]]></ProtectedString>
								<string name="ScriptGuid">{253B9C33-DF68-4843-A857-36494C183828}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PolyVec</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAF10C475B33E4F8DB3DECAA494CA1DCA">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2
--!native

local SHA3 = {}

local LOW_ROUND, HIGH_ROUND = buffer.create(96), buffer.create(96) do
	local HighFactorKeccak = 0
	local ShiftRegister = 29
	local function GetNextBit(): number
		local Result = ShiftRegister % 2
		ShiftRegister = bit32.bxor((ShiftRegister - Result) // 2, 142 * Result)

		return Result
	end

	for Index = 0, 23 do
		local LowValue = 0
		local Multiplier: number

		for _ = 1, 6 do
			Multiplier = if Multiplier then Multiplier * Multiplier * 2 else 1
			LowValue += GetNextBit() * Multiplier
		end

		local HighValue = GetNextBit() * Multiplier
		buffer.writeu32(HIGH_ROUND, Index * 4, HighValue)
		buffer.writeu32(LOW_ROUND, Index * 4, LowValue + HighValue * HighFactorKeccak)
	end
end

local LANES_LOW = buffer.create(100)
local LANES_HIGH = buffer.create(100)

local function Keccak(LanesLow: buffer, LanesHigh: buffer, InputBuffer: buffer, Offset: number, Size: number, BlockSizeInBytes: number): ()
	local QuadWordsQuantity = BlockSizeInBytes // 8
	local RCHigh, RCLow = HIGH_ROUND, LOW_ROUND

	for Position = Offset, Offset + Size - 1, BlockSizeInBytes do
		for Index = 0, (QuadWordsQuantity - 1) * 4, 4 do
			local BufferPos = Position + Index * 2

			buffer.writeu32(LanesLow, Index, bit32.bxor(
				buffer.readu32(LanesLow, Index),
				buffer.readu32(InputBuffer, BufferPos)
				))

			buffer.writeu32(LanesHigh, Index, bit32.bxor(
				buffer.readu32(LanesHigh, Index),
				buffer.readu32(InputBuffer, BufferPos + 4)
				))
		end

		local Lane01Low, Lane01High = buffer.readu32(LanesLow, 0), buffer.readu32(LanesHigh, 0)
		local Lane02Low, Lane02High = buffer.readu32(LanesLow, 4), buffer.readu32(LanesHigh, 4)
		local Lane03Low, Lane03High = buffer.readu32(LanesLow, 8), buffer.readu32(LanesHigh, 8)

		local Lane04Low, Lane04High = buffer.readu32(LanesLow, 12), buffer.readu32(LanesHigh, 12)
		local Lane05Low, Lane05High = buffer.readu32(LanesLow, 16), buffer.readu32(LanesHigh, 16)
		local Lane06Low, Lane06High = buffer.readu32(LanesLow, 20), buffer.readu32(LanesHigh, 20)

		local Lane07Low, Lane07High = buffer.readu32(LanesLow, 24), buffer.readu32(LanesHigh, 24)
		local Lane08Low, Lane08High = buffer.readu32(LanesLow, 28), buffer.readu32(LanesHigh, 28)
		local Lane09Low, Lane09High = buffer.readu32(LanesLow, 32), buffer.readu32(LanesHigh, 32)

		local Lane10Low, Lane10High = buffer.readu32(LanesLow, 36), buffer.readu32(LanesHigh, 36)
		local Lane11Low, Lane11High = buffer.readu32(LanesLow, 40), buffer.readu32(LanesHigh, 40)
		local Lane12Low, Lane12High = buffer.readu32(LanesLow, 44), buffer.readu32(LanesHigh, 44)

		local Lane13Low, Lane13High = buffer.readu32(LanesLow, 48), buffer.readu32(LanesHigh, 48)
		local Lane14Low, Lane14High = buffer.readu32(LanesLow, 52), buffer.readu32(LanesHigh, 52)
		local Lane15Low, Lane15High = buffer.readu32(LanesLow, 56), buffer.readu32(LanesHigh, 56)

		local Lane16Low, Lane16High = buffer.readu32(LanesLow, 60), buffer.readu32(LanesHigh, 60)
		local Lane17Low, Lane17High = buffer.readu32(LanesLow, 64), buffer.readu32(LanesHigh, 64)
		local Lane18Low, Lane18High = buffer.readu32(LanesLow, 68), buffer.readu32(LanesHigh, 68)

		local Lane19Low, Lane19High = buffer.readu32(LanesLow, 72), buffer.readu32(LanesHigh, 72)
		local Lane20Low, Lane20High = buffer.readu32(LanesLow, 76), buffer.readu32(LanesHigh, 76)
		local Lane21Low, Lane21High = buffer.readu32(LanesLow, 80), buffer.readu32(LanesHigh, 80)

		local Lane22Low, Lane22High = buffer.readu32(LanesLow, 84), buffer.readu32(LanesHigh, 84)
		local Lane23Low, Lane23High = buffer.readu32(LanesLow, 88), buffer.readu32(LanesHigh, 88)
		local Lane24Low, Lane24High = buffer.readu32(LanesLow, 92), buffer.readu32(LanesHigh, 92)

		local Lane25Low, Lane25High = buffer.readu32(LanesLow, 96), buffer.readu32(LanesHigh, 96)

		for RoundIndex = 0, 92, 4 do
			local Column1Low, Column1High = bit32.bxor(Lane01Low, Lane06Low, Lane11Low, Lane16Low, Lane21Low), bit32.bxor(Lane01High, Lane06High, Lane11High, Lane16High, Lane21High)
			local Column2Low, Column2High = bit32.bxor(Lane02Low, Lane07Low, Lane12Low, Lane17Low, Lane22Low), bit32.bxor(Lane02High, Lane07High, Lane12High, Lane17High, Lane22High)
			local Column3Low, Column3High = bit32.bxor(Lane03Low, Lane08Low, Lane13Low, Lane18Low, Lane23Low), bit32.bxor(Lane03High, Lane08High, Lane13High, Lane18High, Lane23High)
			local Column4Low, Column4High = bit32.bxor(Lane04Low, Lane09Low, Lane14Low, Lane19Low, Lane24Low), bit32.bxor(Lane04High, Lane09High, Lane14High, Lane19High, Lane24High)
			local Column5Low, Column5High = bit32.bxor(Lane05Low, Lane10Low, Lane15Low, Lane20Low, Lane25Low), bit32.bxor(Lane05High, Lane10High, Lane15High, Lane20High, Lane25High)

			local DeltaLow, DeltaHigh = bit32.bxor(Column1Low, Column3Low * 2 + Column3High // 2147483648), bit32.bxor(Column1High, Column3High * 2 + Column3Low // 2147483648)
			local Temp0Low, Temp0High = bit32.bxor(DeltaLow, Lane02Low), bit32.bxor(DeltaHigh, Lane02High)
			local Temp1Low, Temp1High = bit32.bxor(DeltaLow, Lane07Low), bit32.bxor(DeltaHigh, Lane07High)
			local Temp2Low, Temp2High = bit32.bxor(DeltaLow, Lane12Low), bit32.bxor(DeltaHigh, Lane12High)
			local Temp3Low, Temp3High = bit32.bxor(DeltaLow, Lane17Low), bit32.bxor(DeltaHigh, Lane17High)
			local Temp4Low, Temp4High = bit32.bxor(DeltaLow, Lane22Low), bit32.bxor(DeltaHigh, Lane22High)

			Lane02Low = Temp1Low // 1048576 + (Temp1High * 4096); Lane02High = Temp1High // 1048576 + (Temp1Low * 4096)
			Lane07Low = Temp3Low // 524288 + (Temp3High * 8192); Lane07High = Temp3High // 524288 + (Temp3Low * 8192)
			Lane12Low = Temp0Low * 2 + Temp0High // 2147483648; Lane12High = Temp0High * 2 + Temp0Low // 2147483648
			Lane17Low = Temp2Low * 1024 + Temp2High // 4194304; Lane17High = Temp2High * 1024 + Temp2Low // 4194304
			Lane22Low = Temp4Low * 4 + Temp4High // 1073741824; Lane22High = Temp4High * 4 + Temp4Low // 1073741824

			DeltaLow = bit32.bxor(Column2Low, Column4Low * 2 + Column4High // 2147483648); DeltaHigh = bit32.bxor(Column2High, Column4High * 2 + Column4Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane03Low); Temp0High = bit32.bxor(DeltaHigh, Lane03High)
			Temp1Low = bit32.bxor(DeltaLow, Lane08Low); Temp1High = bit32.bxor(DeltaHigh, Lane08High)
			Temp2Low = bit32.bxor(DeltaLow, Lane13Low); Temp2High = bit32.bxor(DeltaHigh, Lane13High)
			Temp3Low = bit32.bxor(DeltaLow, Lane18Low); Temp3High = bit32.bxor(DeltaHigh, Lane18High)
			Temp4Low = bit32.bxor(DeltaLow, Lane23Low); Temp4High = bit32.bxor(DeltaHigh, Lane23High)

			Lane03Low = Temp2Low // 2097152 + (Temp2High * 2048); Lane03High = Temp2High // 2097152 + (Temp2Low * 2048)
			Lane08Low = Temp4Low // 8 + bit32.bor(Temp4High * 536870912, 0); Lane08High = Temp4High // 8 + bit32.bor(Temp4Low * 536870912, 0)
			Lane13Low = Temp1Low * 64 + Temp1High // 67108864; Lane13High = Temp1High * 64 + Temp1Low // 67108864
			Lane18Low = (Temp3Low * 32768) + Temp3High // 131072; Lane18High = (Temp3High * 32768) + Temp3Low // 131072
			Lane23Low = Temp0Low // 4 + bit32.bor(Temp0High * 1073741824, 0); Lane23High = Temp0High // 4 + bit32.bor(Temp0Low * 1073741824, 0)

			DeltaLow = bit32.bxor(Column3Low, Column5Low * 2 + Column5High // 2147483648); DeltaHigh = bit32.bxor(Column3High, Column5High * 2 + Column5Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane04Low); Temp0High = bit32.bxor(DeltaHigh, Lane04High)
			Temp1Low = bit32.bxor(DeltaLow, Lane09Low); Temp1High = bit32.bxor(DeltaHigh, Lane09High)
			Temp2Low = bit32.bxor(DeltaLow, Lane14Low); Temp2High = bit32.bxor(DeltaHigh, Lane14High)
			Temp3Low = bit32.bxor(DeltaLow, Lane19Low); Temp3High = bit32.bxor(DeltaHigh, Lane19High)
			Temp4Low = bit32.bxor(DeltaLow, Lane24Low); Temp4High = bit32.bxor(DeltaHigh, Lane24High)

			Lane04Low = bit32.bor(Temp3Low * 2097152, 0) + Temp3High // 2048; Lane04High = bit32.bor(Temp3High * 2097152, 0) + Temp3Low // 2048
			Lane09Low = bit32.bor(Temp0Low * 268435456, 0) + Temp0High // 16; Lane09High = bit32.bor(Temp0High * 268435456, 0) + Temp0Low // 16
			Lane14Low = bit32.bor(Temp2Low * 33554432, 0) + Temp2High // 128; Lane14High = bit32.bor(Temp2High * 33554432, 0) + Temp2Low // 128
			Lane19Low = Temp4Low // 256 + bit32.bor(Temp4High * 16777216, 0); Lane19High = Temp4High // 256 + bit32.bor(Temp4Low * 16777216, 0)
			Lane24Low = Temp1Low // 512 + bit32.bor(Temp1High * 8388608, 0); Lane24High = Temp1High // 512 + bit32.bor(Temp1Low * 8388608, 0)
			DeltaLow = bit32.bxor(Column4Low, Column1Low * 2 + Column1High // 2147483648); DeltaHigh = bit32.bxor(Column4High, Column1High * 2 + Column1Low // 2147483648)

			Temp0Low = bit32.bxor(DeltaLow, Lane05Low); Temp0High = bit32.bxor(DeltaHigh, Lane05High)
			Temp1Low = bit32.bxor(DeltaLow, Lane10Low); Temp1High = bit32.bxor(DeltaHigh, Lane10High)
			Temp2Low = bit32.bxor(DeltaLow, Lane15Low); Temp2High = bit32.bxor(DeltaHigh, Lane15High)
			Temp3Low = bit32.bxor(DeltaLow, Lane20Low); Temp3High = bit32.bxor(DeltaHigh, Lane20High)
			Temp4Low = bit32.bxor(DeltaLow, Lane25Low); Temp4High = bit32.bxor(DeltaHigh, Lane25High)

			Lane05Low = (Temp4Low * 16384) + Temp4High // 262144; Lane05High = (Temp4High * 16384) + Temp4Low // 262144
			Lane10Low = bit32.bor(Temp1Low * 1048576, 0) + Temp1High // 4096; Lane10High = bit32.bor(Temp1High * 1048576, 0) + Temp1Low // 4096
			Lane15Low = Temp3Low * 256 + Temp3High // 16777216; Lane15High = Temp3High * 256 + Temp3Low // 16777216
			Lane20Low = bit32.bor(Temp0Low * 134217728, 0) + Temp0High // 32; Lane20High = bit32.bor(Temp0High * 134217728, 0) + Temp0Low // 32
			Lane25Low = Temp2Low // 33554432 + Temp2High * 128; Lane25High = Temp2High // 33554432 + Temp2Low * 128

			DeltaLow = bit32.bxor(Column5Low, Column2Low * 2 + Column2High // 2147483648); DeltaHigh = bit32.bxor(Column5High, Column2High * 2 + Column2Low // 2147483648)
			Temp1Low = bit32.bxor(DeltaLow, Lane06Low); Temp1High = bit32.bxor(DeltaHigh, Lane06High)
			Temp2Low = bit32.bxor(DeltaLow, Lane11Low); Temp2High = bit32.bxor(DeltaHigh, Lane11High)
			Temp3Low = bit32.bxor(DeltaLow, Lane16Low); Temp3High = bit32.bxor(DeltaHigh, Lane16High)
			Temp4Low = bit32.bxor(DeltaLow, Lane21Low); Temp4High = bit32.bxor(DeltaHigh, Lane21High)
			Lane06Low = Temp2Low * 8 + Temp2High // 536870912; Lane06High = Temp2High * 8 + Temp2Low // 536870912
			Lane11Low = (Temp4Low * 262144) + Temp4High // 16384; Lane11High = (Temp4High * 262144) + Temp4Low // 16384
			Lane16Low = Temp1Low // 268435456 + Temp1High * 16; Lane16High = Temp1High // 268435456 + Temp1Low * 16
			Lane21Low = Temp3Low // 8388608 + Temp3High * 512; Lane21High = Temp3High // 8388608 + Temp3Low * 512
			Lane01Low = bit32.bxor(DeltaLow, Lane01Low); Lane01High = bit32.bxor(DeltaHigh, Lane01High)

			Lane01Low, Lane02Low, Lane03Low, Lane04Low, Lane05Low = bit32.bxor(Lane01Low, bit32.band(-1 - Lane02Low, Lane03Low)), bit32.bxor(Lane02Low, bit32.band(-1 - Lane03Low, Lane04Low)), bit32.bxor(Lane03Low, bit32.band(-1 - Lane04Low, Lane05Low)), bit32.bxor(Lane04Low, bit32.band(-1 - Lane05Low, Lane01Low)), bit32.bxor(Lane05Low, bit32.band(-1 - Lane01Low, Lane02Low)) :: number
			Lane01High, Lane02High, Lane03High, Lane04High, Lane05High = bit32.bxor(Lane01High, bit32.band(-1 - Lane02High, Lane03High)), bit32.bxor(Lane02High, bit32.band(-1 - Lane03High, Lane04High)), bit32.bxor(Lane03High, bit32.band(-1 - Lane04High, Lane05High)), bit32.bxor(Lane04High, bit32.band(-1 - Lane05High, Lane01High)), bit32.bxor(Lane05High, bit32.band(-1 - Lane01High, Lane02High)) :: number
			Lane06Low, Lane07Low, Lane08Low, Lane09Low, Lane10Low = bit32.bxor(Lane09Low, bit32.band(-1 - Lane10Low, Lane06Low)), bit32.bxor(Lane10Low, bit32.band(-1 - Lane06Low, Lane07Low)), bit32.bxor(Lane06Low, bit32.band(-1 - Lane07Low, Lane08Low)), bit32.bxor(Lane07Low, bit32.band(-1 - Lane08Low, Lane09Low)), bit32.bxor(Lane08Low, bit32.band(-1 - Lane09Low, Lane10Low)) :: number
			Lane06High, Lane07High, Lane08High, Lane09High, Lane10High = bit32.bxor(Lane09High, bit32.band(-1 - Lane10High, Lane06High)), bit32.bxor(Lane10High, bit32.band(-1 - Lane06High, Lane07High)), bit32.bxor(Lane06High, bit32.band(-1 - Lane07High, Lane08High)), bit32.bxor(Lane07High, bit32.band(-1 - Lane08High, Lane09High)), bit32.bxor(Lane08High, bit32.band(-1 - Lane09High, Lane10High)) :: number
			Lane11Low, Lane12Low, Lane13Low, Lane14Low, Lane15Low = bit32.bxor(Lane12Low, bit32.band(-1 - Lane13Low, Lane14Low)), bit32.bxor(Lane13Low, bit32.band(-1 - Lane14Low, Lane15Low)), bit32.bxor(Lane14Low, bit32.band(-1 - Lane15Low, Lane11Low)), bit32.bxor(Lane15Low, bit32.band(-1 - Lane11Low, Lane12Low)), bit32.bxor(Lane11Low, bit32.band(-1 - Lane12Low, Lane13Low)) :: number
			Lane11High, Lane12High, Lane13High, Lane14High, Lane15High = bit32.bxor(Lane12High, bit32.band(-1 - Lane13High, Lane14High)), bit32.bxor(Lane13High, bit32.band(-1 - Lane14High, Lane15High)), bit32.bxor(Lane14High, bit32.band(-1 - Lane15High, Lane11High)), bit32.bxor(Lane15High, bit32.band(-1 - Lane11High, Lane12High)), bit32.bxor(Lane11High, bit32.band(-1 - Lane12High, Lane13High)) :: number
			Lane16Low, Lane17Low, Lane18Low, Lane19Low, Lane20Low = bit32.bxor(Lane20Low, bit32.band(-1 - Lane16Low, Lane17Low)), bit32.bxor(Lane16Low, bit32.band(-1 - Lane17Low, Lane18Low)), bit32.bxor(Lane17Low, bit32.band(-1 - Lane18Low, Lane19Low)), bit32.bxor(Lane18Low, bit32.band(-1 - Lane19Low, Lane20Low)), bit32.bxor(Lane19Low, bit32.band(-1 - Lane20Low, Lane16Low)) :: number
			Lane16High, Lane17High, Lane18High, Lane19High, Lane20High = bit32.bxor(Lane20High, bit32.band(-1 - Lane16High, Lane17High)), bit32.bxor(Lane16High, bit32.band(-1 - Lane17High, Lane18High)), bit32.bxor(Lane17High, bit32.band(-1 - Lane18High, Lane19High)), bit32.bxor(Lane18High, bit32.band(-1 - Lane19High, Lane20High)), bit32.bxor(Lane19High, bit32.band(-1 - Lane20High, Lane16High)) :: number
			Lane21Low, Lane22Low, Lane23Low, Lane24Low, Lane25Low = bit32.bxor(Lane23Low, bit32.band(-1 - Lane24Low, Lane25Low)), bit32.bxor(Lane24Low, bit32.band(-1 - Lane25Low, Lane21Low)), bit32.bxor(Lane25Low, bit32.band(-1 - Lane21Low, Lane22Low)), bit32.bxor(Lane21Low, bit32.band(-1 - Lane22Low, Lane23Low)), bit32.bxor(Lane22Low, bit32.band(-1 - Lane23Low, Lane24Low)) :: number
			Lane21High, Lane22High, Lane23High, Lane24High, Lane25High = bit32.bxor(Lane23High, bit32.band(-1 - Lane24High, Lane25High)), bit32.bxor(Lane24High, bit32.band(-1 - Lane25High, Lane21High)), bit32.bxor(Lane25High, bit32.band(-1 - Lane21High, Lane22High)), bit32.bxor(Lane21High, bit32.band(-1 - Lane22High, Lane23High)), bit32.bxor(Lane22High, bit32.band(-1 - Lane23High, Lane24High)) :: number

			Lane01Low = bit32.bxor(Lane01Low, buffer.readu32(RCLow, RoundIndex))
			Lane01High = bit32.bxor(Lane01High, buffer.readu32(RCHigh, RoundIndex))
		end

		buffer.writeu32(LanesLow, 0, Lane01Low); buffer.writeu32(LanesHigh, 0, Lane01High)
		buffer.writeu32(LanesLow, 4, Lane02Low); buffer.writeu32(LanesHigh, 4, Lane02High)
		buffer.writeu32(LanesLow, 8, Lane03Low); buffer.writeu32(LanesHigh, 8, Lane03High)
		buffer.writeu32(LanesLow, 12, Lane04Low); buffer.writeu32(LanesHigh, 12, Lane04High)
		buffer.writeu32(LanesLow, 16, Lane05Low); buffer.writeu32(LanesHigh, 16, Lane05High)
		buffer.writeu32(LanesLow, 20, Lane06Low); buffer.writeu32(LanesHigh, 20, Lane06High)
		buffer.writeu32(LanesLow, 24, Lane07Low); buffer.writeu32(LanesHigh, 24, Lane07High)
		buffer.writeu32(LanesLow, 28, Lane08Low); buffer.writeu32(LanesHigh, 28, Lane08High)
		buffer.writeu32(LanesLow, 32, Lane09Low); buffer.writeu32(LanesHigh, 32, Lane09High)
		buffer.writeu32(LanesLow, 36, Lane10Low); buffer.writeu32(LanesHigh, 36, Lane10High)
		buffer.writeu32(LanesLow, 40, Lane11Low); buffer.writeu32(LanesHigh, 40, Lane11High)
		buffer.writeu32(LanesLow, 44, Lane12Low); buffer.writeu32(LanesHigh, 44, Lane12High)
		buffer.writeu32(LanesLow, 48, Lane13Low); buffer.writeu32(LanesHigh, 48, Lane13High)
		buffer.writeu32(LanesLow, 52, Lane14Low); buffer.writeu32(LanesHigh, 52, Lane14High)
		buffer.writeu32(LanesLow, 56, Lane15Low); buffer.writeu32(LanesHigh, 56, Lane15High)
		buffer.writeu32(LanesLow, 60, Lane16Low); buffer.writeu32(LanesHigh, 60, Lane16High)
		buffer.writeu32(LanesLow, 64, Lane17Low); buffer.writeu32(LanesHigh, 64, Lane17High)
		buffer.writeu32(LanesLow, 68, Lane18Low); buffer.writeu32(LanesHigh, 68, Lane18High)
		buffer.writeu32(LanesLow, 72, Lane19Low); buffer.writeu32(LanesHigh, 72, Lane19High)
		buffer.writeu32(LanesLow, 76, Lane20Low); buffer.writeu32(LanesHigh, 76, Lane20High)
		buffer.writeu32(LanesLow, 80, Lane21Low); buffer.writeu32(LanesHigh, 80, Lane21High)
		buffer.writeu32(LanesLow, 84, Lane22Low); buffer.writeu32(LanesHigh, 84, Lane22High)
		buffer.writeu32(LanesLow, 88, Lane23Low); buffer.writeu32(LanesHigh, 88, Lane23High)
		buffer.writeu32(LanesLow, 92, Lane24Low); buffer.writeu32(LanesHigh, 92, Lane24High)
		buffer.writeu32(LanesLow, 96, Lane25Low); buffer.writeu32(LanesHigh, 96, Lane25High)
	end
end

local function ProcessSponge(Message: buffer, CapacityBits: number, OutputBytes: number, DomainSeparator: number): buffer
	local RateBytes = (1600 - CapacityBits) // 8
	buffer.fill(LANES_LOW, 0, 0, 100)
	buffer.fill(LANES_HIGH, 0, 0, 100)

	local LanesLow = LANES_LOW
	local LanesHigh = LANES_HIGH

	local MessageLength: number = buffer.len(Message)
	local PaddedLength: number = MessageLength + 1

	local Remainder = PaddedLength % RateBytes
	if Remainder ~= 0 then
		PaddedLength += (RateBytes - Remainder)
	end

	local PaddedMessage = buffer.create(PaddedLength)

	if MessageLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
	end

	if PaddedLength - MessageLength == 1 then
		buffer.writeu8(PaddedMessage, MessageLength, bit32.bor(DomainSeparator, 0x80))
	else
		buffer.writeu8(PaddedMessage, MessageLength, DomainSeparator)
		if PaddedLength - MessageLength > 2 then
			buffer.fill(PaddedMessage, MessageLength + 1, 0, PaddedLength - MessageLength - 2)
		end
		buffer.writeu8(PaddedMessage, PaddedLength - 1, 0x80)
	end

	Keccak(LanesLow, LanesHigh, PaddedMessage, 0, PaddedLength, RateBytes)

	local Output = buffer.create(OutputBytes)
	local OutputOffset = 0

	local ZeroBuffer = buffer.create(RateBytes)
	while OutputOffset < OutputBytes do
		local BytesThisRound = math.min(RateBytes, OutputBytes - OutputOffset)

		for ByteIndex = 0, BytesThisRound - 1 do
			local AbsoluteIndex = OutputOffset + ByteIndex
			if AbsoluteIndex < OutputBytes then
				local Lane = ByteIndex // 8
				local ByteInLane = ByteIndex % 8
				local LaneOffset = Lane * 4

				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), ByteInLane * 8, 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), (ByteInLane - 4) * 8, 8)
				end
				buffer.writeu8(Output, AbsoluteIndex, Value)
			end
		end

		OutputOffset += BytesThisRound

		if OutputOffset < OutputBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
		end
	end

	return Output
end

function SHA3.SHAKE128(Message: buffer, OutputBytes: number): buffer
	return ProcessSponge(Message, 256, OutputBytes, 0x1F)
end

function SHA3.SHAKE256(Message: buffer, OutputBytes: number): buffer
	return ProcessSponge(Message, 512, OutputBytes, 0x1F)
end

return SHA3]]></ProtectedString>
								<string name="ScriptGuid">{19925930-A991-4F66-B456-FA5285B5E60D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SHA3</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7416EDD743ED46F4B17CB6DFD0F36B50">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	ML-DSA Sampling
	
	Example usage:
		local Sampling = require(script)
		
		local Rho = buffer.create(32)
		local Matrix = buffer.create(4 * 4 * 256 * 4)
		Sampling.ExpandA(Rho, Matrix, 4, 4)
--]=]

--!strict
--!optimize 2
--!native

local XOF = require("./XOF")
local Params = require("./Params")

local N = 256
local Q = 8380417

local Sampling = {}

local WORKSPACE_MSG_34 = buffer.create(34)
local WORKSPACE_MSG_66 = buffer.create(66)

function Sampling.ExpandA(Rho: buffer, Mat: buffer, K: number, L: number)
	buffer.copy(WORKSPACE_MSG_34, 0, Rho, 0, 32)

	local Message = WORKSPACE_MSG_34
	local Num = N
	local Modulus = Q
	local XOF = XOF

	for I = 0, K - 1 do
		for J = 0, L - 1 do
			local Offset = (I * L + J) * Num * 4

			buffer.writeu8(Message, 32, J)
			buffer.writeu8(Message, 33, I)

			XOF.Reset128()
			XOF.Absorb128(Message)

			local CoeffCount = 0
			local ChunkSize = 504

			while CoeffCount < Num do
				local TotalOutput = XOF.Squeeze128(ChunkSize)
				local ByteOffset = 0
				local OutputLen = buffer.len(TotalOutput)

				while CoeffCount < Num and ByteOffset + 5 < OutputLen do
					local Chunk = buffer.readu32(TotalOutput, ByteOffset)
					local B3 = buffer.readu8(TotalOutput, ByteOffset + 4)
					local B4 = buffer.readu8(TotalOutput, ByteOffset + 5)

					local T3 = bit32.band(Chunk, 0x7FFFFF)
					if T3 < Modulus then
						buffer.writeu32(Mat, Offset + CoeffCount * 4, T3)
						CoeffCount += 1
					end

					local T4 = bit32.bor(
						bit32.rshift(Chunk, 24),
						bit32.lshift(B3, 8),
						bit32.lshift(bit32.band(B4, 0x7F), 16)
					)
					if T4 < Modulus and CoeffCount < Num then
						buffer.writeu32(Mat, Offset + CoeffCount * 4, T4)
						CoeffCount += 1
					end

					ByteOffset += 6
				end

				while CoeffCount < Num and ByteOffset + 2 < OutputLen do
					local T0 = bit32.band(buffer.readu8(TotalOutput, ByteOffset + 2), 0x7F)
					local T1 = buffer.readu8(TotalOutput, ByteOffset + 1)
					local T2 = buffer.readu8(TotalOutput, ByteOffset)

					local T3 = bit32.bor(
						bit32.lshift(T0, 16),
						bit32.lshift(T1, 8),
						T2
					)

					if T3 < Modulus then
						buffer.writeu32(Mat, Offset + CoeffCount * 4, T3)
						CoeffCount += 1
					end

					ByteOffset += 3
				end
			end
		end
	end
end

function Sampling.ExpandS(RhoPrime: buffer, Vec: buffer, Eta: number, K: number, StartNonce: number)
	if not Params.CheckEta(Eta) or not Params.CheckNonce(StartNonce) then
		error("Invalid parameters for ExpandS")
	end

	buffer.copy(WORKSPACE_MSG_66, 0, RhoPrime, 0, 64)

	local Message = WORKSPACE_MSG_66
	local Num = N
	local Modulus = Q

	for I = 0, K - 1 do
		local Offset = I * Num * 4
		local NewNonce = StartNonce + I

		buffer.writeu8(Message, 64, bit32.band(NewNonce, 0xFF))
		buffer.writeu8(Message, 65, bit32.band(bit32.rshift(NewNonce, 8), 0xFF))

		XOF.Reset256()
		XOF.Absorb256(Message)

		local CoeffCount = 0
		local ChunkSize = if Eta == 2 then 136 else 272

		while CoeffCount < Num do
			local TotalOutput = XOF.Squeeze256(ChunkSize)
			local ByteOffset = 0
			local OutputLen = buffer.len(TotalOutput)

			if Eta == 2 then
				while CoeffCount < Num and ByteOffset + 3 < OutputLen do
					local Chunk = buffer.readu32(TotalOutput, ByteOffset)

					local T0 = bit32.band(Chunk, 0x0F)
					local T1 = bit32.band(bit32.rshift(Chunk, 4), 0x0F)
					local T2 = bit32.band(bit32.rshift(Chunk, 8), 0x0F)
					local T3 = bit32.band(bit32.rshift(Chunk, 12), 0x0F)
					local T4 = bit32.band(bit32.rshift(Chunk, 16), 0x0F)
					local T5 = bit32.band(bit32.rshift(Chunk, 20), 0x0F)
					local T6 = bit32.band(bit32.rshift(Chunk, 24), 0x0F)
					local T7 = bit32.band(bit32.rshift(Chunk, 28), 0x0F)

					if T0 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T0 % 5) + (if (T0 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if T1 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T1 % 5) + (if (T1 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if T2 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T2 % 5) + (if (T2 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if T3 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T3 % 5) + (if (T3 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if T4 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T4 % 5) + (if (T4 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if T5 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T5 % 5) + (if (T5 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if T6 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T6 % 5) + (if (T6 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if T7 < 15 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T7 % 5) + (if (T7 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end

					ByteOffset += 4
				end
			else
				while CoeffCount < Num and ByteOffset + 3 < OutputLen do
					local Chunk = buffer.readu32(TotalOutput, ByteOffset)

					local T0 = bit32.band(Chunk, 0x0F)
					local T1 = bit32.band(bit32.rshift(Chunk, 4), 0x0F)
					local T2 = bit32.band(bit32.rshift(Chunk, 8), 0x0F)
					local T3 = bit32.band(bit32.rshift(Chunk, 12), 0x0F)
					local T4 = bit32.band(bit32.rshift(Chunk, 16), 0x0F)
					local T5 = bit32.band(bit32.rshift(Chunk, 20), 0x0F)
					local T6 = bit32.band(bit32.rshift(Chunk, 24), 0x0F)
					local T7 = bit32.band(bit32.rshift(Chunk, 28), 0x0F)

					if T0 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T0 + (if T0 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if T1 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T1 + (if T1 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if T2 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T2 + (if T2 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if T3 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T3 + (if T3 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if T4 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T4 + (if T4 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if T5 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T5 + (if T5 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if T6 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T6 + (if T6 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if T7 < 9 and CoeffCount < Num then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T7 + (if T7 > 4 then Modulus else 0))
						CoeffCount += 1
					end

					ByteOffset += 4
				end
			end

			while CoeffCount < Num and ByteOffset < OutputLen do
				local Byte = buffer.readu8(TotalOutput, ByteOffset)
				local T0 = bit32.band(Byte, 0x0F)
				local T1 = bit32.band(bit32.rshift(Byte, 4), 0x0F)

				if Eta == 2 then
					if T0 < 15 then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T0 % 5) + (if (T0 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
					if CoeffCount < Num and T1 < 15 then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 2 - (T1 % 5) + (if (T1 % 5) > 2 then Modulus else 0))
						CoeffCount += 1
					end
				else
					if T0 < 9 then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T0 + (if T0 > 4 then Modulus else 0))
						CoeffCount += 1
					end
					if CoeffCount < Num and T1 < 9 then
						buffer.writeu32(Vec, Offset + CoeffCount * 4, 4 - T1 + (if T1 > 4 then Modulus else 0))
						CoeffCount += 1
					end
				end

				ByteOffset += 1
			end
		end
	end
end

function Sampling.ExpandMask(Seed: buffer, Nonce: number, Vec: buffer, Gamma1: number, L: number)
	if not Params.CheckGamma1(Gamma1) then
		error("Invalid Gamma1 parameter")
	end

	local Gamma1BitWidth = if Gamma1 == 131072 then 18 else 20
	local BufSize = math.floor((N * Gamma1BitWidth) / 8)

	buffer.copy(WORKSPACE_MSG_66, 0, Seed, 0, 64)

	local Message = WORKSPACE_MSG_66
	local Num = N
	local Modulus = Q
	local G1 = Gamma1

	for I = 0, L - 1 do
		local Offset = I * Num * 4
		local NewNonce = Nonce + I

		buffer.writeu8(Message, 64, bit32.band(NewNonce, 0xFF))
		buffer.writeu8(Message, 65, bit32.band(bit32.rshift(NewNonce, 8), 0xFF))

		XOF.Reset256()
		XOF.Absorb256(Message)

		local Src = XOF.Squeeze256(BufSize)

		if Gamma1BitWidth == 18 then
			for J = 0, 63 do
				local BOffset = J * 9
				local POffset = Offset + J * 16

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)
				local B3 = buffer.readu8(Src, BOffset + 3)
				local B4 = buffer.readu8(Src, BOffset + 4)
				local B5 = buffer.readu8(Src, BOffset + 5)
				local B6 = buffer.readu8(Src, BOffset + 6)
				local B7 = buffer.readu8(Src, BOffset + 7)
				local B8 = buffer.readu8(Src, BOffset + 8)

				local V0 = bit32.bor(B0, bit32.lshift(B1, 8), bit32.lshift(bit32.band(B2, 0x3), 16))
				local V1 = bit32.bor(bit32.rshift(B2, 2), bit32.lshift(B3, 6), bit32.lshift(bit32.band(B4, 0xF), 14))
				local V2 = bit32.bor(bit32.rshift(B4, 4), bit32.lshift(B5, 4), bit32.lshift(bit32.band(B6, 0x3F), 12))
				local V3 = bit32.bor(bit32.rshift(B6, 6), bit32.lshift(B7, 2), bit32.lshift(B8, 10))

				local D0 = G1 - V0
				local D1 = G1 - V1
				local D2 = G1 - V2
				local D3 = G1 - V3

				buffer.writeu32(Vec, POffset + 0, if D0 < 0 then D0 + Modulus else D0)
				buffer.writeu32(Vec, POffset + 4, if D1 < 0 then D1 + Modulus else D1)
				buffer.writeu32(Vec, POffset + 8, if D2 < 0 then D2 + Modulus else D2)
				buffer.writeu32(Vec, POffset + 12, if D3 < 0 then D3 + Modulus else D3)
			end
		else
			for J = 0, 63 do
				local BOffset = J * 10
				local POffset = Offset + J * 16

				local B0 = buffer.readu8(Src, BOffset + 0)
				local B1 = buffer.readu8(Src, BOffset + 1)
				local B2 = buffer.readu8(Src, BOffset + 2)
				local B3 = buffer.readu8(Src, BOffset + 3)
				local B4 = buffer.readu8(Src, BOffset + 4)
				local B5 = buffer.readu8(Src, BOffset + 5)
				local B6 = buffer.readu8(Src, BOffset + 6)
				local B7 = buffer.readu8(Src, BOffset + 7)
				local B8 = buffer.readu8(Src, BOffset + 8)
				local B9 = buffer.readu8(Src, BOffset + 9)

				local V0 = bit32.bor(B0, bit32.lshift(B1, 8), bit32.lshift(bit32.band(B2, 0xF), 16))
				local V1 = bit32.bor(bit32.rshift(B2, 4), bit32.lshift(B3, 4), bit32.lshift(B4, 12))
				local V2 = bit32.bor(B5, bit32.lshift(B6, 8), bit32.lshift(bit32.band(B7, 0xF), 16))
				local V3 = bit32.bor(bit32.rshift(B7, 4), bit32.lshift(B8, 4), bit32.lshift(B9, 12))

				local D0 = G1 - V0
				local D1 = G1 - V1
				local D2 = G1 - V2
				local D3 = G1 - V3

				buffer.writeu32(Vec, POffset + 0, if D0 < 0 then D0 + Modulus else D0)
				buffer.writeu32(Vec, POffset + 4, if D1 < 0 then D1 + Modulus else D1)
				buffer.writeu32(Vec, POffset + 8, if D2 < 0 then D2 + Modulus else D2)
				buffer.writeu32(Vec, POffset + 12, if D3 < 0 then D3 + Modulus else D3)
			end
		end
	end
end

function Sampling.SampleInBall(Seed: buffer, Poly: buffer, Tau: number, Lambda: number)
	if not Params.CheckTau(Tau) then
		error("Invalid Tau parameter")
	end

	buffer.fill(Poly, 0, 0, N * 4)

	XOF.Reset256()
	XOF.Absorb256(Seed)

	local TauBits = XOF.Squeeze256(8)
	local TauBitsLow = buffer.readu32(TauBits, 0)
	local TauBitsHigh = buffer.readu32(TauBits, 4)

	local From = N - Tau
	local I = From
	local ChunkSize = 136
	local Modulus = Q

	while I < N do
		local RandomBytes = XOF.Squeeze256(ChunkSize)
		local ByteOffset = 0
		local OutputLen = buffer.len(RandomBytes)

		while I < N and ByteOffset + 3 < OutputLen do
			local Chunk = buffer.readu32(RandomBytes, ByteOffset)

			for B = 0, 3 do
				if I >= N then break end

				local J = bit32.band(bit32.rshift(Chunk, B * 8), 0xFF)

				if J <= I then
					local TauBit = I - From
					local S
					if TauBit < 32 then
						S = bit32.band(bit32.rshift(TauBitsLow, TauBit), 1)
					else
						S = bit32.band(bit32.rshift(TauBitsHigh, TauBit - 32), 1)
					end

					buffer.writeu32(Poly, I * 4, buffer.readu32(Poly, J * 4))
					buffer.writeu32(Poly, J * 4, if S == 0 then 1 else Modulus - 1)

					I += 1
				end
			end

			ByteOffset += 4
		end

		while I < N and ByteOffset < OutputLen do
			local J = buffer.readu8(RandomBytes, ByteOffset)

			if J <= I then
				local TauBit = I - From
				local S
				if TauBit < 32 then
					S = bit32.band(bit32.rshift(TauBitsLow, TauBit), 1)
				else
					S = bit32.band(bit32.rshift(TauBitsHigh, TauBit - 32), 1)
				end

				buffer.writeu32(Poly, I * 4, buffer.readu32(Poly, J * 4))
				buffer.writeu32(Poly, J * 4, if S == 0 then 1 else Modulus - 1)

				I += 1
			end

			ByteOffset += 1
		end
	end
end

return Sampling]]></ProtectedString>
								<string name="ScriptGuid">{60BDA055-DD57-4760-A9C1-72D14E5F5739}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Sampling</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX53044D8B31CC4E66A3D5ED840DCA7305">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Utility functions for ML-DSA key and signature sizes
	
	 ML-DSA parameters.

	Example usage:
		local Utils = require(script)
		
		local PubKeySize = Utils.PubKeyLen(4, 13) -- 1312 bytes for ML-DSA-44
		local SecKeySize = Utils.SecKeyLen(4, 4, 2, 13) -- 2560 bytes
		local SigSize = Utils.SigLen(4, 4, 131072, 80, 128) -- Variable
--]=]

--!strict
--!optimize 2
--!native

local Q_BIT_WIDTH = 23

local Utils = {}

local function BitWidth(Value: number): number
	if Value == 0 then
		return 0
	end

	local Width = 0
	local TempValue = Value

	while TempValue > 0 do
		Width += 1
		TempValue = bit32.rshift(TempValue, 1)
	end

	return Width
end

function Utils.PubKeyLen(K: number, D: number): number
	local T1Bw = Q_BIT_WIDTH - D
	local PkLen = 32 + K * 32 * T1Bw
	
	return PkLen
end

function Utils.SecKeyLen(K: number, L: number, Eta: number, D: number): number
	local EtaBw = BitWidth(2 * Eta)
	local SkLen = 32 + 32 + 64 + 32 * (EtaBw * (K + L) + K * D)
	
	return SkLen
end

function Utils.SigLen(K: number, L: number, Gamma1: number, Omega: number, Lambda: number): number
	local Gamma1Bw = BitWidth(Gamma1)
	local SigLen = math.floor((2 * Lambda) / 8) + (32 * L * Gamma1Bw) + (Omega + K)
	
	return SigLen
end

function Utils.BitWidth(Value: number): number
	return BitWidth(Value)
end

return Utils]]></ProtectedString>
								<string name="ScriptGuid">{A2C47992-8BDF-42E0-BBBC-E0E31B7DD55F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Utils</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX591593C7BFDC4068ABDA56B212B8D227">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Stateful SHAKE XOF (Extensible Output Function)
	
	Non-OOP implementation with reusable state buffers.
	For ML-DSA sampling functions that use rejection sampling.
	
	Example usage:
		local XOF = require(script)
		
		XOF.Reset128()
		XOF.Absorb128(message)
		local Chunk1 = XOF.Squeeze128(168)
		local Chunk2 = XOF.Squeeze128(168)
--]=]

--!strict
--!optimize 2
--!native

local RATE_128 = 168
local RATE_256 = 136

local LanesLow128 = buffer.create(100)
local LanesHigh128 = buffer.create(100)
local SqueezeOffset128 = 0

local LanesLow256 = buffer.create(100)
local LanesHigh256 = buffer.create(100)
local SqueezeOffset256 = 0

local ZeroBuffer128 = buffer.create(RATE_128)
local ZeroBuffer256 = buffer.create(RATE_256)

local PaddedBuffer128 = buffer.create(RATE_128)
local PaddedBuffer256 = buffer.create(RATE_256)

local SqueezeBuffer128_168 = buffer.create(168)
local SqueezeBuffer256_128 = buffer.create(128)
local SqueezeBuffer256_192 = buffer.create(192)

local LOW_ROUND, HIGH_ROUND = buffer.create(96), buffer.create(96) do
	local HighFactorKeccak = 0
	local ShiftRegister = 29
	local function GetNextBit(): number
		local Result = ShiftRegister % 2
		ShiftRegister = bit32.bxor((ShiftRegister - Result) // 2, 142 * Result)
		return Result
	end

	for Index = 0, 23 do
		local LowValue = 0
		local Multiplier: number

		for _ = 1, 6 do
			Multiplier = if Multiplier then Multiplier * Multiplier * 2 else 1
			LowValue += GetNextBit() * Multiplier
		end

		local HighValue = GetNextBit() * Multiplier
		buffer.writeu32(HIGH_ROUND, Index * 4, HighValue)
		buffer.writeu32(LOW_ROUND, Index * 4, LowValue + HighValue * HighFactorKeccak)
	end
end

local function Keccak(LanesLow: buffer, LanesHigh: buffer, InputBuffer: buffer, Offset: number, Size: number, BlockSizeInBytes: number): ()
	local QuadWordsQuantity = BlockSizeInBytes // 8
	local RCHigh, RCLow = HIGH_ROUND, LOW_ROUND

	for Position = Offset, Offset + Size - 1, BlockSizeInBytes do
		for Index = 0, (QuadWordsQuantity - 1) * 4, 4 do
			local BufferPos = Position + Index * 2

			buffer.writeu32(LanesLow, Index, bit32.bxor(
				buffer.readu32(LanesLow, Index),
				buffer.readu32(InputBuffer, BufferPos)
				))

			buffer.writeu32(LanesHigh, Index, bit32.bxor(
				buffer.readu32(LanesHigh, Index),
				buffer.readu32(InputBuffer, BufferPos + 4)
				))
		end

		local Lane01Low, Lane01High = buffer.readu32(LanesLow, 0), buffer.readu32(LanesHigh, 0)
		local Lane02Low, Lane02High = buffer.readu32(LanesLow, 4), buffer.readu32(LanesHigh, 4)
		local Lane03Low, Lane03High = buffer.readu32(LanesLow, 8), buffer.readu32(LanesHigh, 8)

		local Lane04Low, Lane04High = buffer.readu32(LanesLow, 12), buffer.readu32(LanesHigh, 12)
		local Lane05Low, Lane05High = buffer.readu32(LanesLow, 16), buffer.readu32(LanesHigh, 16)
		local Lane06Low, Lane06High = buffer.readu32(LanesLow, 20), buffer.readu32(LanesHigh, 20)

		local Lane07Low, Lane07High = buffer.readu32(LanesLow, 24), buffer.readu32(LanesHigh, 24)
		local Lane08Low, Lane08High = buffer.readu32(LanesLow, 28), buffer.readu32(LanesHigh, 28)
		local Lane09Low, Lane09High = buffer.readu32(LanesLow, 32), buffer.readu32(LanesHigh, 32)

		local Lane10Low, Lane10High = buffer.readu32(LanesLow, 36), buffer.readu32(LanesHigh, 36)
		local Lane11Low, Lane11High = buffer.readu32(LanesLow, 40), buffer.readu32(LanesHigh, 40)
		local Lane12Low, Lane12High = buffer.readu32(LanesLow, 44), buffer.readu32(LanesHigh, 44)

		local Lane13Low, Lane13High = buffer.readu32(LanesLow, 48), buffer.readu32(LanesHigh, 48)
		local Lane14Low, Lane14High = buffer.readu32(LanesLow, 52), buffer.readu32(LanesHigh, 52)
		local Lane15Low, Lane15High = buffer.readu32(LanesLow, 56), buffer.readu32(LanesHigh, 56)

		local Lane16Low, Lane16High = buffer.readu32(LanesLow, 60), buffer.readu32(LanesHigh, 60)
		local Lane17Low, Lane17High = buffer.readu32(LanesLow, 64), buffer.readu32(LanesHigh, 64)
		local Lane18Low, Lane18High = buffer.readu32(LanesLow, 68), buffer.readu32(LanesHigh, 68)

		local Lane19Low, Lane19High = buffer.readu32(LanesLow, 72), buffer.readu32(LanesHigh, 72)
		local Lane20Low, Lane20High = buffer.readu32(LanesLow, 76), buffer.readu32(LanesHigh, 76)
		local Lane21Low, Lane21High = buffer.readu32(LanesLow, 80), buffer.readu32(LanesHigh, 80)

		local Lane22Low, Lane22High = buffer.readu32(LanesLow, 84), buffer.readu32(LanesHigh, 84)
		local Lane23Low, Lane23High = buffer.readu32(LanesLow, 88), buffer.readu32(LanesHigh, 88)
		local Lane24Low, Lane24High = buffer.readu32(LanesLow, 92), buffer.readu32(LanesHigh, 92)

		local Lane25Low, Lane25High = buffer.readu32(LanesLow, 96), buffer.readu32(LanesHigh, 96)

		for RoundIndex = 0, 92, 4 do
			local Column1Low, Column1High = bit32.bxor(Lane01Low, Lane06Low, Lane11Low, Lane16Low, Lane21Low), bit32.bxor(Lane01High, Lane06High, Lane11High, Lane16High, Lane21High)
			local Column2Low, Column2High = bit32.bxor(Lane02Low, Lane07Low, Lane12Low, Lane17Low, Lane22Low), bit32.bxor(Lane02High, Lane07High, Lane12High, Lane17High, Lane22High)
			local Column3Low, Column3High = bit32.bxor(Lane03Low, Lane08Low, Lane13Low, Lane18Low, Lane23Low), bit32.bxor(Lane03High, Lane08High, Lane13High, Lane18High, Lane23High)
			local Column4Low, Column4High = bit32.bxor(Lane04Low, Lane09Low, Lane14Low, Lane19Low, Lane24Low), bit32.bxor(Lane04High, Lane09High, Lane14High, Lane19High, Lane24High)
			local Column5Low, Column5High = bit32.bxor(Lane05Low, Lane10Low, Lane15Low, Lane20Low, Lane25Low), bit32.bxor(Lane05High, Lane10High, Lane15High, Lane20High, Lane25High)

			local DeltaLow, DeltaHigh = bit32.bxor(Column1Low, Column3Low * 2 + Column3High // 2147483648), bit32.bxor(Column1High, Column3High * 2 + Column3Low // 2147483648)
			local Temp0Low, Temp0High = bit32.bxor(DeltaLow, Lane02Low), bit32.bxor(DeltaHigh, Lane02High)
			local Temp1Low, Temp1High = bit32.bxor(DeltaLow, Lane07Low), bit32.bxor(DeltaHigh, Lane07High)
			local Temp2Low, Temp2High = bit32.bxor(DeltaLow, Lane12Low), bit32.bxor(DeltaHigh, Lane12High)
			local Temp3Low, Temp3High = bit32.bxor(DeltaLow, Lane17Low), bit32.bxor(DeltaHigh, Lane17High)
			local Temp4Low, Temp4High = bit32.bxor(DeltaLow, Lane22Low), bit32.bxor(DeltaHigh, Lane22High)

			Lane02Low = Temp1Low // 1048576 + (Temp1High * 4096); Lane02High = Temp1High // 1048576 + (Temp1Low * 4096)
			Lane07Low = Temp3Low // 524288 + (Temp3High * 8192); Lane07High = Temp3High // 524288 + (Temp3Low * 8192)
			Lane12Low = Temp0Low * 2 + Temp0High // 2147483648; Lane12High = Temp0High * 2 + Temp0Low // 2147483648
			Lane17Low = Temp2Low * 1024 + Temp2High // 4194304; Lane17High = Temp2High * 1024 + Temp2Low // 4194304
			Lane22Low = Temp4Low * 4 + Temp4High // 1073741824; Lane22High = Temp4High * 4 + Temp4Low // 1073741824

			DeltaLow = bit32.bxor(Column2Low, Column4Low * 2 + Column4High // 2147483648); DeltaHigh = bit32.bxor(Column2High, Column4High * 2 + Column4Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane03Low); Temp0High = bit32.bxor(DeltaHigh, Lane03High)
			Temp1Low = bit32.bxor(DeltaLow, Lane08Low); Temp1High = bit32.bxor(DeltaHigh, Lane08High)
			Temp2Low = bit32.bxor(DeltaLow, Lane13Low); Temp2High = bit32.bxor(DeltaHigh, Lane13High)
			Temp3Low = bit32.bxor(DeltaLow, Lane18Low); Temp3High = bit32.bxor(DeltaHigh, Lane18High)
			Temp4Low = bit32.bxor(DeltaLow, Lane23Low); Temp4High = bit32.bxor(DeltaHigh, Lane23High)

			Lane03Low = Temp2Low // 2097152 + (Temp2High * 2048); Lane03High = Temp2High // 2097152 + (Temp2Low * 2048)
			Lane08Low = Temp4Low // 8 + bit32.bor(Temp4High * 536870912, 0); Lane08High = Temp4High // 8 + bit32.bor(Temp4Low * 536870912, 0)
			Lane13Low = Temp1Low * 64 + Temp1High // 67108864; Lane13High = Temp1High * 64 + Temp1Low // 67108864
			Lane18Low = (Temp3Low * 32768) + Temp3High // 131072; Lane18High = (Temp3High * 32768) + Temp3Low // 131072
			Lane23Low = Temp0Low // 4 + bit32.bor(Temp0High * 1073741824, 0); Lane23High = Temp0High // 4 + bit32.bor(Temp0Low * 1073741824, 0)

			DeltaLow = bit32.bxor(Column3Low, Column5Low * 2 + Column5High // 2147483648); DeltaHigh = bit32.bxor(Column3High, Column5High * 2 + Column5Low // 2147483648)
			Temp0Low = bit32.bxor(DeltaLow, Lane04Low); Temp0High = bit32.bxor(DeltaHigh, Lane04High)
			Temp1Low = bit32.bxor(DeltaLow, Lane09Low); Temp1High = bit32.bxor(DeltaHigh, Lane09High)
			Temp2Low = bit32.bxor(DeltaLow, Lane14Low); Temp2High = bit32.bxor(DeltaHigh, Lane14High)
			Temp3Low = bit32.bxor(DeltaLow, Lane19Low); Temp3High = bit32.bxor(DeltaHigh, Lane19High)
			Temp4Low = bit32.bxor(DeltaLow, Lane24Low); Temp4High = bit32.bxor(DeltaHigh, Lane24High)

			Lane04Low = bit32.bor(Temp3Low * 2097152, 0) + Temp3High // 2048; Lane04High = bit32.bor(Temp3High * 2097152, 0) + Temp3Low // 2048
			Lane09Low = bit32.bor(Temp0Low * 268435456, 0) + Temp0High // 16; Lane09High = bit32.bor(Temp0High * 268435456, 0) + Temp0Low // 16
			Lane14Low = bit32.bor(Temp2Low * 33554432, 0) + Temp2High // 128; Lane14High = bit32.bor(Temp2High * 33554432, 0) + Temp2Low // 128
			Lane19Low = Temp4Low // 256 + bit32.bor(Temp4High * 16777216, 0); Lane19High = Temp4High // 256 + bit32.bor(Temp4Low * 16777216, 0)
			Lane24Low = Temp1Low // 512 + bit32.bor(Temp1High * 8388608, 0); Lane24High = Temp1High // 512 + bit32.bor(Temp1Low * 8388608, 0)
			DeltaLow = bit32.bxor(Column4Low, Column1Low * 2 + Column1High // 2147483648); DeltaHigh = bit32.bxor(Column4High, Column1High * 2 + Column1Low // 2147483648)

			Temp0Low = bit32.bxor(DeltaLow, Lane05Low); Temp0High = bit32.bxor(DeltaHigh, Lane05High)
			Temp1Low = bit32.bxor(DeltaLow, Lane10Low); Temp1High = bit32.bxor(DeltaHigh, Lane10High)
			Temp2Low = bit32.bxor(DeltaLow, Lane15Low); Temp2High = bit32.bxor(DeltaHigh, Lane15High)
			Temp3Low = bit32.bxor(DeltaLow, Lane20Low); Temp3High = bit32.bxor(DeltaHigh, Lane20High)
			Temp4Low = bit32.bxor(DeltaLow, Lane25Low); Temp4High = bit32.bxor(DeltaHigh, Lane25High)

			Lane05Low = (Temp4Low * 16384) + Temp4High // 262144; Lane05High = (Temp4High * 16384) + Temp4Low // 262144
			Lane10Low = bit32.bor(Temp1Low * 1048576, 0) + Temp1High // 4096; Lane10High = bit32.bor(Temp1High * 1048576, 0) + Temp1Low // 4096
			Lane15Low = Temp3Low * 256 + Temp3High // 16777216; Lane15High = Temp3High * 256 + Temp3Low // 16777216
			Lane20Low = bit32.bor(Temp0Low * 134217728, 0) + Temp0High // 32; Lane20High = bit32.bor(Temp0High * 134217728, 0) + Temp0Low // 32
			Lane25Low = Temp2Low // 33554432 + Temp2High * 128; Lane25High = Temp2High // 33554432 + Temp2Low * 128

			DeltaLow = bit32.bxor(Column5Low, Column2Low * 2 + Column2High // 2147483648); DeltaHigh = bit32.bxor(Column5High, Column2High * 2 + Column2Low // 2147483648)
			Temp1Low = bit32.bxor(DeltaLow, Lane06Low); Temp1High = bit32.bxor(DeltaHigh, Lane06High)
			Temp2Low = bit32.bxor(DeltaLow, Lane11Low); Temp2High = bit32.bxor(DeltaHigh, Lane11High)
			Temp3Low = bit32.bxor(DeltaLow, Lane16Low); Temp3High = bit32.bxor(DeltaHigh, Lane16High)
			Temp4Low = bit32.bxor(DeltaLow, Lane21Low); Temp4High = bit32.bxor(DeltaHigh, Lane21High)
			Lane06Low = Temp2Low * 8 + Temp2High // 536870912; Lane06High = Temp2High * 8 + Temp2Low // 536870912
			Lane11Low = (Temp4Low * 262144) + Temp4High // 16384; Lane11High = (Temp4High * 262144) + Temp4Low // 16384
			Lane16Low = Temp1Low // 268435456 + Temp1High * 16; Lane16High = Temp1High // 268435456 + Temp1Low * 16
			Lane21Low = Temp3Low // 8388608 + Temp3High * 512; Lane21High = Temp3High // 8388608 + Temp3Low * 512
			Lane01Low = bit32.bxor(DeltaLow, Lane01Low); Lane01High = bit32.bxor(DeltaHigh, Lane01High)

			Lane01Low, Lane02Low, Lane03Low, Lane04Low, Lane05Low = bit32.bxor(Lane01Low, bit32.band(-1 - Lane02Low, Lane03Low)), bit32.bxor(Lane02Low, bit32.band(-1 - Lane03Low, Lane04Low)), bit32.bxor(Lane03Low, bit32.band(-1 - Lane04Low, Lane05Low)), bit32.bxor(Lane04Low, bit32.band(-1 - Lane05Low, Lane01Low)), bit32.bxor(Lane05Low, bit32.band(-1 - Lane01Low, Lane02Low)) :: number
			Lane01High, Lane02High, Lane03High, Lane04High, Lane05High = bit32.bxor(Lane01High, bit32.band(-1 - Lane02High, Lane03High)), bit32.bxor(Lane02High, bit32.band(-1 - Lane03High, Lane04High)), bit32.bxor(Lane03High, bit32.band(-1 - Lane04High, Lane05High)), bit32.bxor(Lane04High, bit32.band(-1 - Lane05High, Lane01High)), bit32.bxor(Lane05High, bit32.band(-1 - Lane01High, Lane02High)) :: number
			Lane06Low, Lane07Low, Lane08Low, Lane09Low, Lane10Low = bit32.bxor(Lane09Low, bit32.band(-1 - Lane10Low, Lane06Low)), bit32.bxor(Lane10Low, bit32.band(-1 - Lane06Low, Lane07Low)), bit32.bxor(Lane06Low, bit32.band(-1 - Lane07Low, Lane08Low)), bit32.bxor(Lane07Low, bit32.band(-1 - Lane08Low, Lane09Low)), bit32.bxor(Lane08Low, bit32.band(-1 - Lane09Low, Lane10Low)) :: number
			Lane06High, Lane07High, Lane08High, Lane09High, Lane10High = bit32.bxor(Lane09High, bit32.band(-1 - Lane10High, Lane06High)), bit32.bxor(Lane10High, bit32.band(-1 - Lane06High, Lane07High)), bit32.bxor(Lane06High, bit32.band(-1 - Lane07High, Lane08High)), bit32.bxor(Lane07High, bit32.band(-1 - Lane08High, Lane09High)), bit32.bxor(Lane08High, bit32.band(-1 - Lane09High, Lane10High)) :: number
			Lane11Low, Lane12Low, Lane13Low, Lane14Low, Lane15Low = bit32.bxor(Lane12Low, bit32.band(-1 - Lane13Low, Lane14Low)), bit32.bxor(Lane13Low, bit32.band(-1 - Lane14Low, Lane15Low)), bit32.bxor(Lane14Low, bit32.band(-1 - Lane15Low, Lane11Low)), bit32.bxor(Lane15Low, bit32.band(-1 - Lane11Low, Lane12Low)), bit32.bxor(Lane11Low, bit32.band(-1 - Lane12Low, Lane13Low)) :: number
			Lane11High, Lane12High, Lane13High, Lane14High, Lane15High = bit32.bxor(Lane12High, bit32.band(-1 - Lane13High, Lane14High)), bit32.bxor(Lane13High, bit32.band(-1 - Lane14High, Lane15High)), bit32.bxor(Lane14High, bit32.band(-1 - Lane15High, Lane11High)), bit32.bxor(Lane15High, bit32.band(-1 - Lane11High, Lane12High)), bit32.bxor(Lane11High, bit32.band(-1 - Lane12High, Lane13High)) :: number
			Lane16Low, Lane17Low, Lane18Low, Lane19Low, Lane20Low = bit32.bxor(Lane20Low, bit32.band(-1 - Lane16Low, Lane17Low)), bit32.bxor(Lane16Low, bit32.band(-1 - Lane17Low, Lane18Low)), bit32.bxor(Lane17Low, bit32.band(-1 - Lane18Low, Lane19Low)), bit32.bxor(Lane18Low, bit32.band(-1 - Lane19Low, Lane20Low)), bit32.bxor(Lane19Low, bit32.band(-1 - Lane20Low, Lane16Low)) :: number
			Lane16High, Lane17High, Lane18High, Lane19High, Lane20High = bit32.bxor(Lane20High, bit32.band(-1 - Lane16High, Lane17High)), bit32.bxor(Lane16High, bit32.band(-1 - Lane17High, Lane18High)), bit32.bxor(Lane17High, bit32.band(-1 - Lane18High, Lane19High)), bit32.bxor(Lane18High, bit32.band(-1 - Lane19High, Lane20High)), bit32.bxor(Lane19High, bit32.band(-1 - Lane20High, Lane16High)) :: number
			Lane21Low, Lane22Low, Lane23Low, Lane24Low, Lane25Low = bit32.bxor(Lane23Low, bit32.band(-1 - Lane24Low, Lane25Low)), bit32.bxor(Lane24Low, bit32.band(-1 - Lane25Low, Lane21Low)), bit32.bxor(Lane25Low, bit32.band(-1 - Lane21Low, Lane22Low)), bit32.bxor(Lane21Low, bit32.band(-1 - Lane22Low, Lane23Low)), bit32.bxor(Lane22Low, bit32.band(-1 - Lane23Low, Lane24Low)) :: number
			Lane21High, Lane22High, Lane23High, Lane24High, Lane25High = bit32.bxor(Lane23High, bit32.band(-1 - Lane24High, Lane25High)), bit32.bxor(Lane24High, bit32.band(-1 - Lane25High, Lane21High)), bit32.bxor(Lane25High, bit32.band(-1 - Lane21High, Lane22High)), bit32.bxor(Lane21High, bit32.band(-1 - Lane22High, Lane23High)), bit32.bxor(Lane22High, bit32.band(-1 - Lane23High, Lane24High)) :: number

			Lane01Low = bit32.bxor(Lane01Low, buffer.readu32(RCLow, RoundIndex))
			Lane01High = bit32.bxor(Lane01High, buffer.readu32(RCHigh, RoundIndex))
		end

		buffer.writeu32(LanesLow, 0, Lane01Low); buffer.writeu32(LanesHigh, 0, Lane01High)
		buffer.writeu32(LanesLow, 4, Lane02Low); buffer.writeu32(LanesHigh, 4, Lane02High)
		buffer.writeu32(LanesLow, 8, Lane03Low); buffer.writeu32(LanesHigh, 8, Lane03High)
		buffer.writeu32(LanesLow, 12, Lane04Low); buffer.writeu32(LanesHigh, 12, Lane04High)
		buffer.writeu32(LanesLow, 16, Lane05Low); buffer.writeu32(LanesHigh, 16, Lane05High)
		buffer.writeu32(LanesLow, 20, Lane06Low); buffer.writeu32(LanesHigh, 20, Lane06High)
		buffer.writeu32(LanesLow, 24, Lane07Low); buffer.writeu32(LanesHigh, 24, Lane07High)
		buffer.writeu32(LanesLow, 28, Lane08Low); buffer.writeu32(LanesHigh, 28, Lane08High)
		buffer.writeu32(LanesLow, 32, Lane09Low); buffer.writeu32(LanesHigh, 32, Lane09High)
		buffer.writeu32(LanesLow, 36, Lane10Low); buffer.writeu32(LanesHigh, 36, Lane10High)
		buffer.writeu32(LanesLow, 40, Lane11Low); buffer.writeu32(LanesHigh, 40, Lane11High)
		buffer.writeu32(LanesLow, 44, Lane12Low); buffer.writeu32(LanesHigh, 44, Lane12High)
		buffer.writeu32(LanesLow, 48, Lane13Low); buffer.writeu32(LanesHigh, 48, Lane13High)
		buffer.writeu32(LanesLow, 52, Lane14Low); buffer.writeu32(LanesHigh, 52, Lane14High)
		buffer.writeu32(LanesLow, 56, Lane15Low); buffer.writeu32(LanesHigh, 56, Lane15High)
		buffer.writeu32(LanesLow, 60, Lane16Low); buffer.writeu32(LanesHigh, 60, Lane16High)
		buffer.writeu32(LanesLow, 64, Lane17Low); buffer.writeu32(LanesHigh, 64, Lane17High)
		buffer.writeu32(LanesLow, 68, Lane18Low); buffer.writeu32(LanesHigh, 68, Lane18High)
		buffer.writeu32(LanesLow, 72, Lane19Low); buffer.writeu32(LanesHigh, 72, Lane19High)
		buffer.writeu32(LanesLow, 76, Lane20Low); buffer.writeu32(LanesHigh, 76, Lane20High)
		buffer.writeu32(LanesLow, 80, Lane21Low); buffer.writeu32(LanesHigh, 80, Lane21High)
		buffer.writeu32(LanesLow, 84, Lane22Low); buffer.writeu32(LanesHigh, 84, Lane22High)
		buffer.writeu32(LanesLow, 88, Lane23Low); buffer.writeu32(LanesHigh, 88, Lane23High)
		buffer.writeu32(LanesLow, 92, Lane24Low); buffer.writeu32(LanesHigh, 92, Lane24High)
		buffer.writeu32(LanesLow, 96, Lane25Low); buffer.writeu32(LanesHigh, 96, Lane25High)
	end
end

local XOF = {}

function XOF.Reset128()
	buffer.fill(LanesLow128, 0, 0, 100)
	buffer.fill(LanesHigh128, 0, 0, 100)
	SqueezeOffset128 = 0
end

function XOF.Reset256()
	buffer.fill(LanesLow256, 0, 0, 100)
	buffer.fill(LanesHigh256, 0, 0, 100)
	SqueezeOffset256 = 0
end

function XOF.Absorb128(Message: buffer)
	local MessageLength = buffer.len(Message)
	local RateBytes = RATE_128

	local PaddedMessage = PaddedBuffer128
	buffer.fill(PaddedMessage, 0, 0, RateBytes)

	if MessageLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
	end

	if RateBytes - MessageLength == 1 then
		buffer.writeu8(PaddedMessage, MessageLength, 0x9F)
	else
		buffer.writeu8(PaddedMessage, MessageLength, 0x1F)
		buffer.writeu8(PaddedMessage, RateBytes - 1, 0x80)
	end

	Keccak(LanesLow128, LanesHigh128, PaddedMessage, 0, RateBytes, RateBytes)
end

function XOF.Absorb256(Message: buffer)
	local MessageLength = buffer.len(Message)
	local RateBytes = RATE_256

	local PaddedMessage = PaddedBuffer256
	buffer.fill(PaddedMessage, 0, 0, RateBytes)

	if MessageLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, 0, MessageLength)
	end

	if RateBytes - MessageLength == 1 then
		buffer.writeu8(PaddedMessage, MessageLength, 0x9F)
	else
		buffer.writeu8(PaddedMessage, MessageLength, 0x1F)
		buffer.writeu8(PaddedMessage, RateBytes - 1, 0x80)
	end

	Keccak(LanesLow256, LanesHigh256, PaddedMessage, 0, RateBytes, RateBytes)
end

function XOF.Squeeze128Into(Output: buffer, OutputBytes: number, OutputOffset: number?)
	local OutOffset = OutputOffset or 0
	local RateBytes = RATE_128
	local LanesLow = LanesLow128
	local LanesHigh = LanesHigh128
	local SqueezeOffset = SqueezeOffset128
	local ZeroBuffer = ZeroBuffer128

	local Written = 0
	while Written < OutputBytes do
		if SqueezeOffset >= RateBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
			SqueezeOffset = 0
		end

		local BytesThisRound = RateBytes - SqueezeOffset
		if BytesThisRound > OutputBytes - Written then
			BytesThisRound = OutputBytes - Written
		end

		local ByteIndex = 0
		while ByteIndex < BytesThisRound do
			local AbsoluteIndex = SqueezeOffset + ByteIndex
			local Lane = bit32.rshift(AbsoluteIndex, 3)
			local ByteInLane = bit32.band(AbsoluteIndex, 7)
			local LaneOffset = bit32.lshift(Lane, 2)

			if ByteInLane == 0 and ByteIndex + 8 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				buffer.writeu32(Output, OutOffset + Written + ByteIndex + 4, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 8
			elseif ByteInLane == 0 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				ByteIndex += 4
			elseif ByteInLane == 4 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 4
			else
				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), bit32.lshift(ByteInLane, 3), 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), bit32.lshift(ByteInLane - 4, 3), 8)
				end
				buffer.writeu8(Output, OutOffset + Written + ByteIndex, Value)
				ByteIndex += 1
			end
		end

		Written += BytesThisRound
		SqueezeOffset += BytesThisRound
	end

	SqueezeOffset128 = SqueezeOffset
end

function XOF.Squeeze128(OutputBytes: number): buffer
	local Output = if OutputBytes == 168 then SqueezeBuffer128_168 else buffer.create(OutputBytes)
	XOF.Squeeze128Into(Output, OutputBytes, 0)
	return Output
end

function XOF.Squeeze256Into(Output: buffer, OutputBytes: number, OutputOffset: number?)
	local OutOffset = OutputOffset or 0
	local RateBytes = RATE_256
	local LanesLow = LanesLow256
	local LanesHigh = LanesHigh256
	local SqueezeOffset = SqueezeOffset256
	local ZeroBuffer = ZeroBuffer256

	local Written = 0
	while Written < OutputBytes do
		if SqueezeOffset >= RateBytes then
			Keccak(LanesLow, LanesHigh, ZeroBuffer, 0, RateBytes, RateBytes)
			SqueezeOffset = 0
		end

		local BytesThisRound = RateBytes - SqueezeOffset
		if BytesThisRound > OutputBytes - Written then
			BytesThisRound = OutputBytes - Written
		end

		local ByteIndex = 0
		while ByteIndex < BytesThisRound do
			local AbsoluteIndex = SqueezeOffset + ByteIndex
			local Lane = bit32.rshift(AbsoluteIndex, 3)
			local ByteInLane = bit32.band(AbsoluteIndex, 7)
			local LaneOffset = bit32.lshift(Lane, 2)

			if ByteInLane == 0 and ByteIndex + 8 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				buffer.writeu32(Output, OutOffset + Written + ByteIndex + 4, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 8
			elseif ByteInLane == 0 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesLow, LaneOffset))
				ByteIndex += 4
			elseif ByteInLane == 4 and ByteIndex + 4 <= BytesThisRound then
				buffer.writeu32(Output, OutOffset + Written + ByteIndex, buffer.readu32(LanesHigh, LaneOffset))
				ByteIndex += 4
			else
				local Value
				if ByteInLane < 4 then
					Value = bit32.extract(buffer.readu32(LanesLow, LaneOffset), bit32.lshift(ByteInLane, 3), 8)
				else
					Value = bit32.extract(buffer.readu32(LanesHigh, LaneOffset), bit32.lshift(ByteInLane - 4, 3), 8)
				end
				buffer.writeu8(Output, OutOffset + Written + ByteIndex, Value)
				ByteIndex += 1
			end
		end

		Written += BytesThisRound
		SqueezeOffset += BytesThisRound
	end

	SqueezeOffset256 = SqueezeOffset
end

function XOF.Squeeze256(OutputBytes: number): buffer
	local Output = if OutputBytes == 128 then SqueezeBuffer256_128 
		elseif OutputBytes == 192 then SqueezeBuffer256_192 
		else buffer.create(OutputBytes)
	XOF.Squeeze256Into(Output, OutputBytes, 0)
	return Output
end

return XOF]]></ProtectedString>
								<string name="ScriptGuid">{1B80D96C-5454-4940-A35C-4260109CDA21}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">XOF</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX403F8945226F4217ACF862D0AF14D321">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Cryptographically Secure RNG
	
	Usage:
		local RandomFloat = CSPRNG.Random()
		local RandomInt = CSPRNG.RandomInt(1, 100)
		local RandomNumber = CSPRNG.RandomNumber(0.5, 10.5)
		local RandomBytes = CSPRNG.RandomBytes(32)
		local RandomHex = CSPRNG.RandomHex(16)
		local FastString = CSPRNG.RandomString(16, false)
		local FastBuffer = CSPRNG.RandomString(32, true)
		
		local Ed25519Clamped = CSPRNG.Ed25519ClampedBytes(SomeBuffer)
		local Ed25519Random = CSPRNG.Ed25519Random()
		
		CSPRNG.AddEntropyProvider(function)
		CSPRNG.RemoveEntropyProvider(function)
		CSPRNG.Reseed()
		
		CSPRNG.BytesLeft
--]=]

--!strict
--!optimize 2
--!native

local Conversions = require("@self/Conversions")
local ChaCha20 = require("@self/ChaCha20")
local Blake3 = require("@self/Blake3")

export type EntropyProvider = (BytesLeft: number) -> buffer?

type CSPRNGModule = {
	BlockExpansion: boolean,

	SizeTarget: number,
	RekeyAfter: number,

	Key: buffer,
	Nonce: buffer,
	Buffer: buffer,

	Counter: number,
	BufferPosition: number,
	BufferSize: number,
	BytesLeft: number,

	EntropyProviders: { EntropyProvider },

	Reseed: (CustomEntropy: buffer?) -> (),
	AddEntropyProvider: (ProviderFunction: EntropyProvider) -> (),
	RemoveEntropyProvider: (ProviderFunction: EntropyProvider) -> (),

	Random: () -> number,
	RandomInt: (Min: number, Max: number?) -> number,
	RandomNumber: (Min: number, Max: number?) -> number,
	RandomBytes: (Count: number) -> buffer,
	RandomString: (Length: number, AsBuffer: boolean?) -> string | buffer,
	RandomHex: (Length: number) -> string,
	Ed25519ClampedBytes: (Input: buffer) -> buffer,
	Ed25519Random: () -> buffer,
}

local BLOCK_SIZE = 64
local KEY_SIZE = 32
local NONCE_SIZE = 12

local CSPRNG: CSPRNGModule = {
	BlockExpansion = true,
	SizeTarget = 2048,
	RekeyAfter = 1024,

	Key = buffer.create(0),
	Nonce = buffer.create(0),
	Buffer = buffer.create(0),

	Counter = 0,
	BufferPosition = 0,
	BufferSize = 0,
	BytesLeft = 0,

	EntropyProviders = {}
} :: CSPRNGModule

local INPUT_BUFFER = buffer.create(BLOCK_SIZE)
local REKEY_THRESHOLD = math.max(math.floor(CSPRNG.RekeyAfter), 2)
local SIZE_TARGET_CLAMPED = math.clamp(math.floor(CSPRNG.SizeTarget), 64, 4294967295)

local function Reset()
	CSPRNG.Key = buffer.create(0)
	CSPRNG.Nonce = buffer.create(0)
	CSPRNG.Buffer = buffer.create(0)

	CSPRNG.Counter = 0
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = 0
end

local function GatherEntropy(CustomEntropy: buffer?): number
	local EntropyBuffers = buffer.create(1024)
	local Offset = 0

	local function WriteToBuffer(Source: buffer)
		local Size = buffer.len(Source)
		buffer.copy(EntropyBuffers, Offset, Source, 0, Size)
		Offset += Size
	end

	local CurrentTime = 1.234
	if tick then
		CurrentTime = tick()
		local TimeBuffer = buffer.create(8)
		buffer.writef64(TimeBuffer, 0, CurrentTime)
		WriteToBuffer(TimeBuffer)
	end

	local ClockTime = os.clock()
	local ClockBuffer = buffer.create(8)
	buffer.writef64(ClockBuffer, 0, ClockTime)
	WriteToBuffer(ClockBuffer)

	local UnixTime = os.time()
	local UnixBuffer = buffer.create(8)
	buffer.writeu32(UnixBuffer, 0, UnixTime % 0x100000000)
	buffer.writeu32(UnixBuffer, 4, math.floor(UnixTime / 0x100000000))
	WriteToBuffer(UnixBuffer)

	local DateTimeMillis = 5.678
	if DateTime then
		DateTimeMillis = DateTime.now().UnixTimestampMillis
		local DateTimeBuffer = buffer.create(8)
		buffer.writef64(DateTimeBuffer, 0, DateTimeMillis)
		WriteToBuffer(DateTimeBuffer)

		local DateTimePrecisionBuffer = buffer.create(16)
		buffer.writef32(DateTimePrecisionBuffer, 0, DateTimeMillis / 1000)
		buffer.writef32(DateTimePrecisionBuffer, 4, (DateTimeMillis % 1000) / 100)
		buffer.writef32(DateTimePrecisionBuffer, 8, DateTimeMillis / 86400000)
		buffer.writef32(DateTimePrecisionBuffer, 12, (DateTimeMillis * 0.001) % 1)
		WriteToBuffer(DateTimePrecisionBuffer)
	else
		WriteToBuffer(buffer.create(24))
	end

	local FracTimeBuffer = buffer.create(16)
	buffer.writef32(FracTimeBuffer, 0, ClockTime / 100)
	buffer.writef32(FracTimeBuffer, 4, CurrentTime / 1000)
	buffer.writef32(FracTimeBuffer, 8, (ClockTime * 12345.6789) % 1)
	buffer.writef32(FracTimeBuffer, 12, (CurrentTime * 98765.4321) % 1)
	WriteToBuffer(FracTimeBuffer)

	local NoiseBuffer = buffer.create(32)
	for Index = 0, 7 do
		local Noise1 = math.noise(ClockTime + Index, UnixTime + Index, ClockTime + UnixTime + Index)
		local Noise2 = math.noise(CurrentTime + Index * 0.1, DateTimeMillis * 0.0001 + Index, ClockTime * 1.5 + Index)
		local Noise3 = math.noise(UnixTime * 0.01 + Index, ClockTime + DateTimeMillis * 0.001, CurrentTime + Index * 2)
		local Noise4 = math.noise(DateTimeMillis * 0.00001 + Index, UnixTime + ClockTime + Index, CurrentTime * 0.1 + Index)

		buffer.writef32(NoiseBuffer, Index * 4, Noise1 + Noise2 + Noise3 + Noise4)
	end
	WriteToBuffer(NoiseBuffer)

	local BenchmarkTimings = buffer.create(32)
	for Index = 0, 7 do
		local StartTime = os.clock()
		local Sum = 0

		local Iterations = 50 + (Index * 25)
		for Iteration = 1, Iterations do
			Sum += Iteration * Iteration + math.sin(Iteration / 10) * math.cos(Iteration / 7)
		end

		local EndTime = os.clock()
		local TimingDelta = EndTime - StartTime
		buffer.writef32(BenchmarkTimings, Index * 4, TimingDelta * 1000000)
	end
	WriteToBuffer(BenchmarkTimings)

	local AllocTimings = buffer.create(24)
	for Index = 0, 5 do
		local AllocStart = os.clock()

		for AllocIndex = 1, 20 do
			local _TempBuf = buffer.create(64 + AllocIndex)
		end

		local AllocEnd = os.clock()
		buffer.writef32(AllocTimings, Index * 4, (AllocEnd - AllocStart) * 10000000)
	end
	WriteToBuffer(AllocTimings)

	local MicroTime = math.floor(CurrentTime * 1000000)
	local MicroTimeBuffer = buffer.create(8)
	buffer.writeu32(MicroTimeBuffer, 0, MicroTime % 0x100000000)
	buffer.writeu32(MicroTimeBuffer, 4, math.floor(MicroTime / 0x100000000))
	WriteToBuffer(MicroTimeBuffer)

	if game then
		if game.JobId and #game.JobId > 0 then
			local JobIdBuffer = buffer.fromstring(game.JobId)
			WriteToBuffer(JobIdBuffer)
		end

		if game.PlaceId then
			local PlaceIdBuffer = buffer.create(8)
			buffer.writeu32(PlaceIdBuffer, 0, game.PlaceId % 0x100000000)
			buffer.writeu32(PlaceIdBuffer, 4, math.floor(game.PlaceId / 0x100000000))
			WriteToBuffer(PlaceIdBuffer)
		end

		if workspace and workspace.DistributedGameTime then
			local DistTimeBuffer = buffer.create(8)
			buffer.writef64(DistTimeBuffer, 0, workspace.DistributedGameTime)
			WriteToBuffer(DistTimeBuffer)

			local DistMicroTime = math.floor(workspace.DistributedGameTime * 1000000)
			local DistMicroBuffer = buffer.create(8)
			buffer.writeu32(DistMicroBuffer, 0, DistMicroTime % 0x100000000)
			buffer.writeu32(DistMicroBuffer, 4, math.floor(DistMicroTime / 0x100000000))
			WriteToBuffer(DistMicroBuffer)
		end
	end

	local AddressEntropy = buffer.create(128)
	for Index = 0, 7 do
		local TempTable = {}
		local TempFunc = function() end
		local TempBuffer = buffer.create(0)
		local TempUserdata = newproxy()

		local TableAddr = string.gsub(tostring(TempTable), "table: ", "")
		local FuncAddr = string.gsub(tostring(TempFunc), "function: ", "")
		local BufferAddr = string.gsub(tostring(TempBuffer), "buffer: ", "")
		local UserdataAddr = string.gsub(tostring(TempUserdata), "userdata: ", "")

		local TableHash = 0
		local ThreadHash = 0
		local FuncHash = 0
		local BufferHash = 0
		local UserdataHash = 0

		for AddrIndex = 1, #TableAddr do
			TableHash = bit32.bxor(TableHash, string.byte(TableAddr, AddrIndex)) * 31
		end

		if coroutine then
			local ThreadAddr = string.gsub(tostring(coroutine.create(function() end)), "thread: ", "")
			for AddrIndex = 1, #ThreadAddr do
				ThreadHash = bit32.bxor(ThreadHash, string.byte(ThreadAddr, AddrIndex)) * 31
			end
		end

		for AddrIndex = 1, #FuncAddr do
			FuncHash = bit32.bxor(FuncHash, string.byte(FuncAddr, AddrIndex)) * 37
		end
		for AddrIndex = 1, #BufferAddr do
			BufferHash = bit32.bxor(BufferHash, string.byte(BufferAddr, AddrIndex)) * 41
		end
		for AddrIndex = 1, #UserdataAddr do
			UserdataHash = bit32.bxor(UserdataHash, string.byte(UserdataAddr, AddrIndex)) * 43
		end

		buffer.writeu32(AddressEntropy, Index * 16, TableHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 4, ThreadHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 8, FuncHash)
		buffer.writeu32(AddressEntropy, Index * 16 + 12, bit32.bxor(BufferHash, UserdataHash))
	end
	WriteToBuffer(AddressEntropy)

	local function AddExtraEntropy(Entropy: buffer?, Warn: boolean, Provider: string?)
		if not Entropy then
			return
		end

		local BytesLeft = 1024 - Offset

		if BytesLeft > 0 then
			local Extra = buffer.len(Entropy) - BytesLeft
			local Truncated = math.min(BytesLeft, buffer.len(Entropy))

			if Extra > 0 and Warn and Provider then
				warn(`CSPRNG: {Provider} returned {Extra} bytes more than available and was truncated to {Truncated} bytes`)
			end

			buffer.copy(EntropyBuffers, Offset, Entropy, 0, Truncated)
		end
	end

	for Index, Provider in CSPRNG.EntropyProviders do
		local BytesLeft = 1024 - Offset
		if BytesLeft > 0 then
			local Success: boolean, ExtraEntropy: buffer? = pcall(Provider, BytesLeft)
			if not Success then
				warn(`CSPRNG Provider errored with {ExtraEntropy}`)
			end

			AddExtraEntropy(ExtraEntropy, true, `Entropy Provider #{Index}`)
		end
	end

	if CustomEntropy then
		AddExtraEntropy(CustomEntropy, false)
	end

	local KeyMaterial = Blake3(EntropyBuffers, KEY_SIZE + NONCE_SIZE)

	CSPRNG.Key = buffer.create(KEY_SIZE)
	buffer.copy(CSPRNG.Key, 0, KeyMaterial, 0, KEY_SIZE)

	CSPRNG.Nonce = buffer.create(NONCE_SIZE)
	buffer.copy(CSPRNG.Nonce, 0, KeyMaterial, KEY_SIZE, NONCE_SIZE)

	return buffer.len(EntropyBuffers) - Offset
end

local function GenerateBlock()
	buffer.fill(INPUT_BUFFER, 0, 0, BLOCK_SIZE)
	local ChaChaOutput = ChaCha20(INPUT_BUFFER, CSPRNG.Key, CSPRNG.Nonce, CSPRNG.Counter, 20)

	CSPRNG.Buffer = if CSPRNG.BlockExpansion then Blake3(ChaChaOutput, SIZE_TARGET_CLAMPED) else ChaChaOutput
	CSPRNG.BufferPosition = 0
	CSPRNG.BufferSize = buffer.len(CSPRNG.Buffer)
	CSPRNG.Counter += 1

	if CSPRNG.Counter % REKEY_THRESHOLD == 0 then
		GatherEntropy() 
		CSPRNG.Counter = 0
	end
end

local function GetBytes(Count: number): buffer
	local Result = buffer.create(Count)
	local ResultPosition = 0

	while ResultPosition < Count do
		if CSPRNG.BufferPosition >= CSPRNG.BufferSize then
			GenerateBlock()
		end

		local BytesNeeded = Count - ResultPosition
		local BytesAvailable = CSPRNG.BufferSize - CSPRNG.BufferPosition
		local BytesToCopy = math.min(BytesNeeded, BytesAvailable)

		buffer.copy(Result, ResultPosition, CSPRNG.Buffer, CSPRNG.BufferPosition, BytesToCopy)
		ResultPosition += BytesToCopy
		CSPRNG.BufferPosition += BytesToCopy
	end

	return Result
end

local function GetFloat(): number
	if CSPRNG.BufferPosition + 8 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value1 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	local Value2 = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition + 4)
	CSPRNG.BufferPosition += 8

	local High = bit32.rshift(Value1, 5)
	local Low = bit32.rshift(Value2, 6)

	return (High * 67108864.0 + Low) / 9007199254740992.0
end

local function GetIntRange(Min: number, Max: number): number
	local Range = Max - Min + 1
	local MaxUInt32 = 0xFFFFFFFF
	local Limit = MaxUInt32 - (MaxUInt32 % Range)

	if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
		GenerateBlock()
	end

	local Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
	CSPRNG.BufferPosition += 4

	if bit32.band(Range, Range - 1) == 0 then
		return Min + bit32.band(Value, Range - 1)
	else
		while Value > Limit do
			if CSPRNG.BufferPosition + 4 > CSPRNG.BufferSize then
				GenerateBlock()
			end
			Value = buffer.readu32(CSPRNG.Buffer, CSPRNG.BufferPosition)
			CSPRNG.BufferPosition += 4
		end

		return Min + (Value % Range)
	end
end

local function GetNumberRange(Min: number, Max: number): number
	if Min > Max then
		Min, Max = Max, Min
	end

	local Range = Max - Min
	if Range <= 0 then
		return Min
	end

	return Min + (GetFloat() * Range)
end

local function GetRandomString(Length: number, AsBuffer: boolean?): string | buffer
	local Characters = buffer.create(Length)

	for Index = 0, Length - 1 do
		buffer.writeu8(Characters, Index, GetIntRange(36, 122))
	end

	return if AsBuffer
		then Characters
		else buffer.tostring(Characters)
end

local function GetEd25519RandomBytes(): buffer
	local Output = buffer.create(32)

	for Index = 0, 31 do
		buffer.writeu8(Output, Index, GetIntRange(0, 255))
	end

	return Output
end

local function GetEd25519ClampedBytes(Input: buffer): buffer
	local Output = buffer.create(32)
	buffer.copy(Output, 0, Input, 0, 32)

	local FirstByte = buffer.readu8(Output, 0)
	FirstByte = bit32.band(FirstByte, 0xF8)
	buffer.writeu8(Output, 0, FirstByte)

	local LastByte = buffer.readu8(Output, 31)
	LastByte = bit32.band(LastByte, 0x7F)
	LastByte = bit32.bor(LastByte, 0x40)
	buffer.writeu8(Output, 31, LastByte)

	local HasVariation = false
	local FirstMiddleByte = buffer.readu8(Output, 1)
	for Index = 2, 30 do
		if buffer.readu8(Output, Index) ~= FirstMiddleByte then
			HasVariation = true
			break
		end
	end

	if not HasVariation then
		buffer.writeu8(Output, 15, bit32.bxor(FirstMiddleByte, 0x55))
	end

	return Output
end

local function GetHexString(Length: number): string
	local BytesNeeded = Length / 2
	local Bytes = GetBytes(BytesNeeded)
	local Hex = Conversions.ToHex(Bytes)

	return Hex
end

function CSPRNG.AddEntropyProvider(ProviderFunction: EntropyProvider)
	table.insert(CSPRNG.EntropyProviders, ProviderFunction)
end

function CSPRNG.RemoveEntropyProvider(ProviderFunction: EntropyProvider)
	for Index = #CSPRNG.EntropyProviders, 1, -1 do
		if CSPRNG.EntropyProviders[Index] == ProviderFunction then
			table.remove(CSPRNG.EntropyProviders, Index)
			break
		end
	end
end

function CSPRNG.Random(): number
	return GetFloat()
end

function CSPRNG.RandomInt(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) can't be less than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 1
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetIntRange(ActualMin, ActualMax)
end

function CSPRNG.RandomNumber(Min: number, Max: number?): number
	if Max and type(Max) ~= "number" then
		error(`Max must be a number or nil, got {typeof(Max)}`, 2)
	end

	if type(Min) ~= "number" then
		error(`Min must be a number, got {typeof(Min)}`, 2)
	end

	if Max and Max < Min then
		error(`Max ({Max}) must be bigger than Min ({Min})`, 2)
	end

	if Max and Max == Min then
		error(`Max ({Max}) can't be equal to Min ({Min})`, 2)
	end

	local ActualMax: number
	local ActualMin: number

	if Max == nil then
		ActualMax = Min
		ActualMin = 0
	else
		ActualMax = Max
		ActualMin = Min
	end

	return GetNumberRange(ActualMin, ActualMax)
end

function CSPRNG.RandomBytes(Count: number): buffer
	if type(Count) ~= "number" then
		error(`Count must be a number, got {typeof(Count)}`, 2)
	end

	if Count <= 0 then
		error(`Count must be bigger than 0, got {Count}`, 2)
	end

	if Count % 1 ~= 0 then
		error("Count must be an integer", 2)
	end

	return GetBytes(Count)
end

function CSPRNG.RandomString(Length: number, AsBuffer: boolean?): string | buffer
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if AsBuffer ~= nil and type(AsBuffer) ~= "boolean" then
		error(`AsBuffer must be a boolean or nil, got {typeof(AsBuffer)}`, 2)
	end

	return GetRandomString(Length, AsBuffer)
end

function CSPRNG.RandomHex(Length: number): string
	if type(Length) ~= "number" then
		error(`Length must be a number, got {typeof(Length)}`, 2)
	end

	if Length <= 0 then
		error(`Length must be bigger than 0, got {Length}`, 2)
	end

	if Length % 1 ~= 0 then
		error("Length must be an integer", 2)
	end

	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`, 2)
	end

	return GetHexString(Length)
end

function CSPRNG.Ed25519ClampedBytes(Input: buffer): buffer
	if type(Input) ~= "buffer" then
		error(`Input must be a buffer, got {typeof(Input)}`, 2)
	end

	return GetEd25519ClampedBytes(Input)
end

function CSPRNG.Ed25519Random(): buffer
	return GetEd25519ClampedBytes(GetEd25519RandomBytes())
end

function CSPRNG.Reseed(CustomEntropy: buffer?)
	if CustomEntropy ~= nil and type(CustomEntropy) ~= "buffer" then
		error(`CustomEntropy must be a buffer or nil, got {typeof(CustomEntropy)}`, 2)
	end

	Reset()
	GatherEntropy(CustomEntropy)
end

CSPRNG.BytesLeft = GatherEntropy()
GenerateBlock()

return CSPRNG]]></ProtectedString>
								<string name="ScriptGuid">{3C15CB49-2F8B-4797-9577-F490E1B0CE04}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CSPRNG</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX9C82AAF553AB4F7FBD28A71D1C767DE8">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Blake3
	
	Sizes:
		Key: 32 bytes
		Output: variable
	
	Return type: string (hex)
	Example usage:
		local Message = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		
		--------Standard Hash--------
		local Hash = Blake3.Digest(Message, 32)
		
		--------Keyed Hash--------
		local KeyedHash = Blake3.DigestKeyed(Key, Message, 32)
		
		--------Key Derivation--------
		local Context = buffer.fromstring("my context")
		local KeyDeriver = Blake3.DeriveKey(Context)
		local DerivedKey = KeyDeriver(Message, 32)
--]=]

--!strict
--!optimize 2
--!native

local BLOCK_SIZE = 64
local CV_SIZE = 32
local EXTENDED_CV_SIZE = 64
local MAX_STACK_DEPTH = 64
local STACK_BUFFER_SIZE = MAX_STACK_DEPTH * CV_SIZE

local CHUNK_START = 0x01
local CHUNK_END = 0x02
local PARENT_FLAG = 0x04
local ROOT_FLAG = 0x08

local INITIAL_VECTORS = buffer.create(CV_SIZE) do
	local IV = {
		0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
		0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
	}
	for Index, Value in ipairs(IV) do
		buffer.writeu32(INITIAL_VECTORS, (Index - 1) * 4, Value)
	end
end

local function Compress(Hash: buffer, MessageBlock: buffer, Counter: number, V14: number, V15: number, IsFull: boolean?): buffer
	local Hash00 = buffer.readu32(Hash, 0)
	local Hash01 = buffer.readu32(Hash, 4)
	local Hash02 = buffer.readu32(Hash, 8)
	local Hash03 = buffer.readu32(Hash, 12)
	local Hash04 = buffer.readu32(Hash, 16)
	local Hash05 = buffer.readu32(Hash, 20)
	local Hash06 = buffer.readu32(Hash, 24)
	local Hash07 = buffer.readu32(Hash, 28)

	local V00, V01, V02, V03 = Hash00, Hash01, Hash02, Hash03
	local V04, V05, V06, V07 = Hash04, Hash05, Hash06, Hash07
	local V08, V09, V10, V11 = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a

	local V12 = Counter % (2 ^ 32)
	local V13 = (Counter - V12) * (2 ^ -32)

	local M00 = buffer.readu32(MessageBlock, 0)
	local M01 = buffer.readu32(MessageBlock, 4)
	local M02 = buffer.readu32(MessageBlock, 8)
	local M03 = buffer.readu32(MessageBlock, 12)
	local M04 = buffer.readu32(MessageBlock, 16)
	local M05 = buffer.readu32(MessageBlock, 20)
	local M06 = buffer.readu32(MessageBlock, 24)
	local M07 = buffer.readu32(MessageBlock, 28)
	local M08 = buffer.readu32(MessageBlock, 32)
	local M09 = buffer.readu32(MessageBlock, 36)
	local M10 = buffer.readu32(MessageBlock, 40)
	local M11 = buffer.readu32(MessageBlock, 44)
	local M12 = buffer.readu32(MessageBlock, 48)
	local M13 = buffer.readu32(MessageBlock, 52)
	local M14 = buffer.readu32(MessageBlock, 56)
	local M15 = buffer.readu32(MessageBlock, 60)

	local Temp
	for Index = 1, 7 do
		V00 += V04 + M00; V12 = bit32.lrotate(bit32.bxor(V12, V00), 16)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 20)
		V00 += V04 + M01; V12 = bit32.lrotate(bit32.bxor(V12, V00), 24)
		V08 += V12; V04 = bit32.lrotate(bit32.bxor(V04, V08), 25)

		V01 += V05 + M02; V13 = bit32.lrotate(bit32.bxor(V13, V01), 16)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 20)
		V01 += V05 + M03; V13 = bit32.lrotate(bit32.bxor(V13, V01), 24)
		V09 += V13; V05 = bit32.lrotate(bit32.bxor(V05, V09), 25)

		V02 += V06 + M04; V14 = bit32.lrotate(bit32.bxor(V14, V02), 16)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 20)
		V02 += V06 + M05; V14 = bit32.lrotate(bit32.bxor(V14, V02), 24)
		V10 += V14; V06 = bit32.lrotate(bit32.bxor(V06, V10), 25)

		V03 += V07 + M06; V15 = bit32.lrotate(bit32.bxor(V15, V03), 16)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 20)
		V03 += V07 + M07; V15 = bit32.lrotate(bit32.bxor(V15, V03), 24)
		V11 += V15; V07 = bit32.lrotate(bit32.bxor(V07, V11), 25)

		V00 += V05 + M08; V15 = bit32.lrotate(bit32.bxor(V15, V00), 16)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 20)
		V00 += V05 + M09; V15 = bit32.lrotate(bit32.bxor(V15, V00), 24)
		V10 += V15; V05 = bit32.lrotate(bit32.bxor(V05, V10), 25)

		V01 += V06 + M10; V12 = bit32.lrotate(bit32.bxor(V12, V01), 16)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 20)
		V01 += V06 + M11; V12 = bit32.lrotate(bit32.bxor(V12, V01), 24)
		V11 += V12; V06 = bit32.lrotate(bit32.bxor(V06, V11), 25)

		V02 += V07 + M12; V13 = bit32.lrotate(bit32.bxor(V13, V02), 16)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 20)
		V02 += V07 + M13; V13 = bit32.lrotate(bit32.bxor(V13, V02), 24)
		V08 += V13; V07 = bit32.lrotate(bit32.bxor(V07, V08), 25)

		V03 += V04 + M14; V14 = bit32.lrotate(bit32.bxor(V14, V03), 16)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 20)
		V03 += V04 + M15; V14 = bit32.lrotate(bit32.bxor(V14, V03), 24)
		V09 += V14; V04 = bit32.lrotate(bit32.bxor(V04, V09), 25)

		if Index ~= 7 then
			Temp = M02
			M02 = M03
			M03 = M10
			M10 = M12
			M12 = M09
			M09 = M11
			M11 = M05
			M05 = M00
			M00 = Temp

			Temp = M06
			M06 = M04
			M04 = M07
			M07 = M13
			M13 = M14
			M14 = M15
			M15 = M08
			M08 = M01
			M01 = Temp
		end
	end

	if IsFull then
		local Result = buffer.create(EXTENDED_CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		buffer.writeu32(Result, 32, bit32.bxor(V08, Hash00))
		buffer.writeu32(Result, 36, bit32.bxor(V09, Hash01))
		buffer.writeu32(Result, 40, bit32.bxor(V10, Hash02))
		buffer.writeu32(Result, 44, bit32.bxor(V11, Hash03))
		buffer.writeu32(Result, 48, bit32.bxor(V12, Hash04))
		buffer.writeu32(Result, 52, bit32.bxor(V13, Hash05))
		buffer.writeu32(Result, 56, bit32.bxor(V14, Hash06))
		buffer.writeu32(Result, 60, bit32.bxor(V15, Hash07))

		return Result
	else
		local Result = buffer.create(CV_SIZE)
		buffer.writeu32(Result, 0, bit32.bxor(V00, V08))
		buffer.writeu32(Result, 4, bit32.bxor(V01, V09))
		buffer.writeu32(Result, 8, bit32.bxor(V02, V10))
		buffer.writeu32(Result, 12, bit32.bxor(V03, V11))
		buffer.writeu32(Result, 16, bit32.bxor(V04, V12))
		buffer.writeu32(Result, 20, bit32.bxor(V05, V13))
		buffer.writeu32(Result, 24, bit32.bxor(V06, V14))
		buffer.writeu32(Result, 28, bit32.bxor(V07, V15))

		return Result
	end
end

local function ProcessMessage(InitialHashVector: buffer, Flags: number, Message: buffer, Length: number): buffer
	local MessageLength = buffer.len(Message)
	local StateCvs = buffer.create(STACK_BUFFER_SIZE)
	local StackSize = 0
	local StateCv = buffer.create(CV_SIZE)
	buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)

	local StateCounter = 0
	local StateChunkNumber = 0
	local StateEndFlag = 0
	local StateStartFlag = CHUNK_START

	local BlockBuffer = buffer.create(BLOCK_SIZE)

	for BlockOffset = 0, MessageLength - BLOCK_SIZE - 1, BLOCK_SIZE do
		buffer.copy(BlockBuffer, 0, Message, BlockOffset, BLOCK_SIZE)
		local StateFlags = Flags + StateStartFlag + StateEndFlag

		StateCv = Compress(StateCv, BlockBuffer, StateCounter, BLOCK_SIZE, StateFlags)
		StateStartFlag = 0
		StateChunkNumber += 1

		if StateChunkNumber == 15 then
			StateEndFlag = CHUNK_END
		elseif StateChunkNumber == 16 then
			local MergeCv = StateCv
			local MergeAmount = StateCounter + 1

			while MergeAmount % 2 == 0 do
				StackSize = StackSize - 1
				local PopCv = buffer.create(CV_SIZE)
				buffer.copy(PopCv, 0, StateCvs, StackSize * CV_SIZE, CV_SIZE)

				local Block = buffer.create(EXTENDED_CV_SIZE)
				buffer.copy(Block, 0, PopCv, 0, CV_SIZE)
				buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

				MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
				MergeAmount = MergeAmount / 2
			end

			buffer.copy(StateCvs, StackSize * CV_SIZE, MergeCv, 0, CV_SIZE)
			StackSize = StackSize + 1
			buffer.copy(StateCv, 0, InitialHashVector, 0, CV_SIZE)
			StateStartFlag = CHUNK_START

			StateCounter += 1
			StateChunkNumber = 0
			StateEndFlag = 0
		end
	end

	local LastLength = MessageLength == 0 and 0 or ((MessageLength - 1) % BLOCK_SIZE + 1)
	local PaddedMessage = buffer.create(BLOCK_SIZE)

	if LastLength > 0 then
		buffer.copy(PaddedMessage, 0, Message, MessageLength - LastLength, LastLength)
	end

	local OutputCv: buffer
	local OutputBlock: buffer
	local OutputLength: number
	local OutputFlags: number

	if StateCounter > 0 then
		local StateFlags = Flags + StateStartFlag + CHUNK_END
		local MergeCv = Compress(StateCv, PaddedMessage, StateCounter, LastLength, StateFlags)

		for Index = StackSize, 2, -1 do
			local StackCv = buffer.create(CV_SIZE)
			buffer.copy(StackCv, 0, StateCvs, (Index - 1) * CV_SIZE, CV_SIZE)

			local Block = buffer.create(EXTENDED_CV_SIZE)
			buffer.copy(Block, 0, StackCv, 0, CV_SIZE)
			buffer.copy(Block, CV_SIZE, MergeCv, 0, CV_SIZE)

			MergeCv = Compress(InitialHashVector, Block, 0, BLOCK_SIZE, Flags + PARENT_FLAG)
		end

		OutputCv = InitialHashVector
		local FirstStackCv = buffer.create(CV_SIZE)
		buffer.copy(FirstStackCv, 0, StateCvs, 0, CV_SIZE)

		OutputBlock = buffer.create(EXTENDED_CV_SIZE)
		buffer.copy(OutputBlock, 0, FirstStackCv, 0, CV_SIZE)
		buffer.copy(OutputBlock, CV_SIZE, MergeCv, 0, CV_SIZE)

		OutputLength = BLOCK_SIZE
		OutputFlags = Flags + ROOT_FLAG + PARENT_FLAG
	else
		OutputCv = StateCv
		OutputBlock = PaddedMessage
		OutputLength = LastLength
		OutputFlags = Flags + StateStartFlag + CHUNK_END + ROOT_FLAG
	end

	local Output = buffer.create(Length)
	local OutputOffset = 0

	for Index = 0, Length // BLOCK_SIZE do
		local MessageDigest = Compress(OutputCv, OutputBlock, Index, OutputLength, OutputFlags, true)

		local BytesToCopy = math.min(BLOCK_SIZE, Length - OutputOffset)
		buffer.copy(Output, OutputOffset, MessageDigest, 0, BytesToCopy)
		OutputOffset += BytesToCopy

		if OutputOffset >= Length then
			break
		end
	end

	return Output
end

return function(Message: buffer, Length: number?): buffer
	return ProcessMessage(INITIAL_VECTORS, 0, Message, Length or 32)
end]]></ProtectedString>
									<string name="ScriptGuid">{51DF5D69-007C-497A-8BEC-1655BE521A9E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Blake3</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCEAC5EC2B8164C93A3616B36B2194525">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: ChaCha20
	
	Sizes:
		Nonce: 12 bytes
		Key: 16/32 bytes
	
	Return type: buffer
	Example usage:
		local Data = buffer.fromstring("Hello World")
		local Key = buffer.fromstring(string.rep("k", 32))
		local Nonce = buffer.fromstring(string.rep("n", 12))
		
		--------Usage Case 1--------
		local Encrypted = ChaCha20(Data, Key, Nonce)
		
		--------Usage Case 2--------
		local Decrypted = ChaCha20(Encrypted, Key, Nonce)
--]=]

--!strict
--!native
--!optimize 2

local DWORD = 4
local BLOCK_SIZE = 64
local STATE_SIZE = 16

local CHACHA20_NONCE_SIZE = 12
local CHACHA20_KEY_SIZE_16 = 16
local CHACHA20_KEY_SIZE_32 = 32

local SIGMA_CONSTANTS = buffer.create(16) do
	local SigmaBytes = { string.byte("expand 32-byte k", 1, -1) }
	for Index, ByteValue in SigmaBytes do
		buffer.writeu8(SIGMA_CONSTANTS, Index - 1, ByteValue)
	end
end

local TAU_CONSTANTS = buffer.create(16) do
	local TauBytes = { string.byte("expand 16-byte k", 1, -1) }
	for Index, ByteValue in TauBytes do
		buffer.writeu8(TAU_CONSTANTS, Index - 1, ByteValue)
	end
end

local function ProcessBlock(InitialState: buffer, Rounds: number)
	local S0: number, S1: number, S2: number, S3: number, S4: number, S5: number, S6: number, S7: number, S8: number, S9: number, S10: number, S11: number, S12: number, S13: number, S14: number, S15: number =
		buffer.readu32(InitialState, 0), buffer.readu32(InitialState, 4),
		buffer.readu32(InitialState, 8), buffer.readu32(InitialState, 12),
		buffer.readu32(InitialState, 16), buffer.readu32(InitialState, 20),
		buffer.readu32(InitialState, 24), buffer.readu32(InitialState, 28),
		buffer.readu32(InitialState, 32), buffer.readu32(InitialState, 36),
		buffer.readu32(InitialState, 40), buffer.readu32(InitialState, 44),
		buffer.readu32(InitialState, 48), buffer.readu32(InitialState, 52),
		buffer.readu32(InitialState, 56), buffer.readu32(InitialState, 60)

	for Round = 1, Rounds do
		local IsOddRound = Round % 2 == 1

		if IsOddRound then
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 16)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 12)
			S0 = bit32.bor(S0 + S4, 0); S12 = bit32.lrotate(bit32.bxor(S12, S0), 8)
			S8 = bit32.bor(S8 + S12, 0); S4 = bit32.lrotate(bit32.bxor(S4, S8), 7)

			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 16)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 12)
			S1 = bit32.bor(S1 + S5, 0); S13 = bit32.lrotate(bit32.bxor(S13, S1), 8)
			S9 = bit32.bor(S9 + S13, 0); S5 = bit32.lrotate(bit32.bxor(S5, S9), 7)

			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 16)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 12)
			S2 = bit32.bor(S2 + S6, 0); S14 = bit32.lrotate(bit32.bxor(S14, S2), 8)
			S10 = bit32.bor(S10 + S14, 0); S6 = bit32.lrotate(bit32.bxor(S6, S10), 7)

			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 16)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 12)
			S3 = bit32.bor(S3 + S7, 0); S15 = bit32.lrotate(bit32.bxor(S15, S3), 8)
			S11 = bit32.bor(S11 + S15, 0); S7 = bit32.lrotate(bit32.bxor(S7, S11), 7)
		else
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 16)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 12)
			S0 = bit32.bor(S0 + S5, 0); S15 = bit32.lrotate(bit32.bxor(S15, S0), 8)
			S10 = bit32.bor(S10 + S15, 0); S5 = bit32.lrotate(bit32.bxor(S5, S10), 7)

			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 16)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 12)
			S1 = bit32.bor(S1 + S6, 0); S12 = bit32.lrotate(bit32.bxor(S12, S1), 8)
			S11 = bit32.bor(S11 + S12, 0); S6 = bit32.lrotate(bit32.bxor(S6, S11), 7)

			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 16)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 12)
			S2 = bit32.bor(S2 + S7, 0); S13 = bit32.lrotate(bit32.bxor(S13, S2), 8)
			S8 = bit32.bor(S8 + S13, 0); S7 = bit32.lrotate(bit32.bxor(S7, S8), 7)

			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 16)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 12)
			S3 = bit32.bor(S3 + S4, 0); S14 = bit32.lrotate(bit32.bxor(S14, S3), 8)
			S9 = bit32.bor(S9 + S14, 0); S4 = bit32.lrotate(bit32.bxor(S4, S9), 7)
		end
	end

	buffer.writeu32(InitialState, 0, buffer.readu32(InitialState, 0) + S0)
	buffer.writeu32(InitialState, 4, buffer.readu32(InitialState, 4) + S1)
	buffer.writeu32(InitialState, 8, buffer.readu32(InitialState, 8) + S2)
	buffer.writeu32(InitialState, 12, buffer.readu32(InitialState, 12) + S3)
	buffer.writeu32(InitialState, 16, buffer.readu32(InitialState, 16) + S4)
	buffer.writeu32(InitialState, 20, buffer.readu32(InitialState, 20) + S5)
	buffer.writeu32(InitialState, 24, buffer.readu32(InitialState, 24) + S6)
	buffer.writeu32(InitialState, 28, buffer.readu32(InitialState, 28) + S7)
	buffer.writeu32(InitialState, 32, buffer.readu32(InitialState, 32) + S8)
	buffer.writeu32(InitialState, 36, buffer.readu32(InitialState, 36) + S9)
	buffer.writeu32(InitialState, 40, buffer.readu32(InitialState, 40) + S10)
	buffer.writeu32(InitialState, 44, buffer.readu32(InitialState, 44) + S11)
	buffer.writeu32(InitialState, 48, buffer.readu32(InitialState, 48) + S12)
	buffer.writeu32(InitialState, 52, buffer.readu32(InitialState, 52) + S13)
	buffer.writeu32(InitialState, 56, buffer.readu32(InitialState, 56) + S14)
	buffer.writeu32(InitialState, 60, buffer.readu32(InitialState, 60) + S15)
end

local function InitializeState(Key: buffer, Nonce: buffer, Counter: number): buffer
	local KeyLength = buffer.len(Key)
	local State = buffer.create(STATE_SIZE * DWORD)

	local Constants = KeyLength == 32 and SIGMA_CONSTANTS or TAU_CONSTANTS

	buffer.copy(State, 0, Constants, 0, 16)

	buffer.copy(State, 16, Key, 0, math.min(KeyLength, 16))
	if KeyLength == 32 then
		buffer.copy(State, 32, Key, 16, 16)
	else
		buffer.copy(State, 32, Key, 0, 16)
	end

	buffer.writeu32(State, 48, Counter)
	buffer.copy(State, 52, Nonce, 0, 12)

	return State
end

local function ChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?): buffer
	if Data == nil then
		error("Data cannot be nil", 2)
	end

	if typeof(Data) ~= "buffer" then
		error(`Data must be a buffer, got {typeof(Data)}`, 2)
	end

	if Key == nil then
		error("Key cannot be nil", 2)
	end

	if typeof(Key) ~= "buffer" then
		error(`Key must be a buffer, got {typeof(Key)}`, 2)
	end

	local KeyLength = buffer.len(Key)
	if KeyLength ~= CHACHA20_KEY_SIZE_16 and KeyLength ~= CHACHA20_KEY_SIZE_32 then
		error(`Key must be {CHACHA20_KEY_SIZE_16} or {CHACHA20_KEY_SIZE_32} bytes long, got {KeyLength} bytes`, 2)
	end

	if Nonce == nil then
		error("Nonce cannot be nil", 2)
	end

	if typeof(Nonce) ~= "buffer" then
		error(`Nonce must be a buffer, got {typeof(Nonce)}`, 2)
	end

	local NonceLength = buffer.len(Nonce)
	if NonceLength ~= CHACHA20_NONCE_SIZE then
		error(`Nonce must be exactly {CHACHA20_NONCE_SIZE} bytes long, got {NonceLength} bytes`, 2)
	end

	if Counter then
		if typeof(Counter) ~= "number" then
			error(`Counter must be a number, got {typeof(Counter)}`, 2)
		end

		if Counter < 0 then
			error(`Counter cannot be negative, got {Counter}`, 2)
		end

		if Counter ~= math.floor(Counter) then
			error(`Counter must be an integer, got {Counter}`, 2)
		end

		if Counter >= 2^32 then
			error(`Counter must be less than 2^32, got {Counter}`, 2)
		end
	end

	if Rounds then
		if typeof(Rounds) ~= "number" then
			error(`Rounds must be a number, got {typeof(Rounds)}`, 2)
		end

		if Rounds <= 0 then
			error(`Rounds must be positive, got {Rounds}`, 2)
		end

		if Rounds ~= math.floor(Rounds) then
			error(`Rounds must be an integer, got {Rounds}`, 2)
		end

		if Rounds % 2 ~= 0 then
			error(`Rounds must be even, got {Rounds}`, 2)
		end
	end

	local BlockCounter = Counter or 1
	local BlockRounds = Rounds or 20

	local DataLength = buffer.len(Data)
	if DataLength == 0 then
		return buffer.create(0)
	end

	local Output = buffer.create(DataLength)

	local DataOffset = 0

	local State = InitializeState(Key, Nonce, BlockCounter)
	local StateBackup = buffer.create(64)
	buffer.copy(StateBackup, 0, State, 0)

	while DataOffset < DataLength do
		ProcessBlock(State, BlockRounds)

		local BytesToProcess = math.min(BLOCK_SIZE, DataLength - DataOffset)

		for Index = 0, BytesToProcess - 1 do
			local DataByte = buffer.readu8(Data, DataOffset + Index)
			local KeystreamByte = buffer.readu8(State, Index)
			buffer.writeu8(Output, DataOffset + Index, bit32.bxor(DataByte, KeystreamByte))
		end

		DataOffset += BytesToProcess
		BlockCounter += 1
		buffer.copy(State, 0, StateBackup, 0)
		buffer.writeu32(State, 48, BlockCounter)
	end

	return Output
end

return ChaCha20]]></ProtectedString>
									<string name="ScriptGuid">{20DD82E4-819E-468A-A0F6-7C71006A7468}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ChaCha20</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0F9337C7BE374175B155CF6F21C8B08B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[
	Cryptography library: Conversions
	
	Return type: string / buffer
	Example Usage:
		local HexString = Conversions.ToHex(buffer.fromstring("Hello World"))
		local OriginalBuffer = Conversions.FromHex("48656c6c6f20576f726c64")
--]=]

--!strict
--!optimize 2
--!native

local ENCODE_LOOKUP = buffer.create(256 * 2) do
	local HexChars = "0123456789abcdef"
	for Byte = 0, 255 do
		local HighNibble = bit32.rshift(Byte, 4)
		local LowNibble = Byte % 16

		local HighChar = string.byte(HexChars, HighNibble + 1)
		local LowChar = string.byte(HexChars, LowNibble + 1)

		local Combined = HighChar + bit32.lshift(LowChar, 8)
		buffer.writeu16(ENCODE_LOOKUP, Byte * 2, Combined)
	end
end

local DECODE_LOOKUP = buffer.create(65536 * 2) do
	for High = 0, 255 do
		for Low = 0, 255 do
			local HighNibble = 0
			local LowNibble = 0

			if High >= 48 and High <= 57 then
				HighNibble = High - 48
			elseif High >= 65 and High <= 70 then
				HighNibble = High - 55
			elseif High >= 97 and High <= 102 then
				HighNibble = High - 87
			else
				HighNibble = 0
			end

			if Low >= 48 and Low <= 57 then
				LowNibble = Low - 48
			elseif Low >= 65 and Low <= 70 then
				LowNibble = Low - 55
			elseif Low >= 97 and Low <= 102 then
				LowNibble = Low - 87
			else
				LowNibble = 0
			end

			local Combined = bit32.lshift(HighNibble, 4) + LowNibble
			local Index = bit32.lshift(Low, 8) + High
			buffer.writeu16(DECODE_LOOKUP, Index * 2, Combined)
		end
	end
end

local Conversions = {}

function Conversions.ToHex(Buffer: buffer): string
	local Length = buffer.len(Buffer)
	local Hex = buffer.create(Length * 2)

	local Lookup = ENCODE_LOOKUP

	local Leftover = Length % 8
	local HexCursor = 0

	for Index = 0, Length - Leftover - 1, 8 do
		local Hex1 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		local Hex2 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 1) * 2)
		local Hex3 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 2) * 2)
		local Hex4 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 3) * 2)
		local Hex5 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 4) * 2)
		local Hex6 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 5) * 2)
		local Hex7 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 6) * 2)
		local Hex8 = buffer.readu16(Lookup, buffer.readu8(Buffer, Index + 7) * 2)

		buffer.writeu16(Hex, HexCursor, Hex1)
		buffer.writeu16(Hex, HexCursor + 2, Hex2)
		buffer.writeu16(Hex, HexCursor + 4, Hex3)
		buffer.writeu16(Hex, HexCursor + 6, Hex4)
		buffer.writeu16(Hex, HexCursor + 8, Hex5)
		buffer.writeu16(Hex, HexCursor + 10, Hex6)
		buffer.writeu16(Hex, HexCursor + 12, Hex7)
		buffer.writeu16(Hex, HexCursor + 14, Hex8)

		HexCursor += 16
	end

	for Index = Length - Leftover, Length - 1 do
		local HexPair = buffer.readu16(Lookup, buffer.readu8(Buffer, Index) * 2)
		buffer.writeu16(Hex, HexCursor, HexPair)
		HexCursor += 2
	end

	return buffer.tostring(Hex)
end

function Conversions.FromHex(Hex: string | buffer): buffer
	local BufferHex = if type(Hex) == "string" then buffer.fromstring(Hex) else Hex
	local Length = buffer.len(BufferHex)
	if Length % 2 ~= 0 then
		error(`Length must be even, got {Length}`)
	end

	local Buffer = buffer.create(bit32.rshift(Length, 1))
	local Leftover = Length % 16
	local BufferCursor = 0
	local Lookup = DECODE_LOOKUP

	for Index = 0, Length - Leftover - 1, 16 do
		local Pair1 = buffer.readu16(BufferHex, Index)
		local Pair2 = buffer.readu16(BufferHex, Index + 2)
		local Pair3 = buffer.readu16(BufferHex, Index + 4)
		local Pair4 = buffer.readu16(BufferHex, Index + 6)
		local Pair5 = buffer.readu16(BufferHex, Index + 8)
		local Pair6 = buffer.readu16(BufferHex, Index + 10)
		local Pair7 = buffer.readu16(BufferHex, Index + 12)
		local Pair8 = buffer.readu16(BufferHex, Index + 14)

		local Byte1 = buffer.readu16(Lookup, Pair1 * 2)
		local Byte2 = buffer.readu16(Lookup, Pair2 * 2)
		local Byte3 = buffer.readu16(Lookup, Pair3 * 2)
		local Byte4 = buffer.readu16(Lookup, Pair4 * 2)
		local Byte5 = buffer.readu16(Lookup, Pair5 * 2)
		local Byte6 = buffer.readu16(Lookup, Pair6 * 2)
		local Byte7 = buffer.readu16(Lookup, Pair7 * 2)
		local Byte8 = buffer.readu16(Lookup, Pair8 * 2)

		local Chunk1 = bit32.lshift(Byte4, 24) + bit32.lshift(Byte3, 16) + 
			bit32.lshift(Byte2, 8) + Byte1
		local Chunk2 = bit32.lshift(Byte8, 24) + bit32.lshift(Byte7, 16) + 
			bit32.lshift(Byte6, 8) + Byte5

		buffer.writeu32(Buffer, BufferCursor, Chunk1)
		buffer.writeu32(Buffer, BufferCursor + 4, Chunk2)
		BufferCursor += 8
	end

	for Index = Length - Leftover, Length - 1, 2 do
		local Pair = buffer.readu16(BufferHex, Index)
		local Byte = buffer.readu16(Lookup, Pair * 2)
		buffer.writeu8(Buffer, BufferCursor, Byte)
		BufferCursor += 1
	end

	return Buffer
end

return Conversions]]></ProtectedString>
									<string name="ScriptGuid">{A3309C61-CC2E-44A6-B725-A6447F4C7615}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Conversions</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXE3CA9BDBE99C462588C83D916BD99819">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!strict
-- Thanks @Sythivo :)

type BasicCases = {
	ToBe: (Expected: any) -> (),
	ToBeDefined: () -> (),
	ToBeCloseTo: (Expected: number, Precision: number) -> (),
	ToBeGreaterThan: (Expected: number) -> (),
	ToBeGreaterThanOrEqual: (Expected: number) -> (),
	ToBeLessThan: (Expected: number) -> (),
	ToBeLessThanOrEqual: (Expected: number) -> (),
	ToBeNil: () -> (),
	ToBeNan: () -> (),
	ToHaveLength: (Expected: number) -> (),
	ToBeFalsy: () -> (),
	ToBeTruthy: () -> (),
}

type ExpectCases = BasicCases & {
	Never: BasicCases,
}

type FunctionalCases = ExpectCases & {
	ToThrow: (Expected: string?) -> (),
	Never: FunctionalCases,
}

type ExpectHandler = {
	Any: (Type: string) -> any,
	Type: (
		Type: "nil"
			| "boolean"
			| "number"
			| "string"
			| "function"
			| "table"
			| "userdata"
			| "thread"
			| "buffer"
			| "vector"
	) -> any,
	Similar: (Expected: { [any]: any }) -> any,
}

type TestingLib = {
	Running: boolean,
	Failed: number,
	Count: number,
	Entry: (Callback: () -> ()) -> (),
	Complete: () -> (),
	Test: (Name: string, Callback: () -> ()) -> (),
	Describe: (Name: string, Callback: () -> ()) -> (),
	Defer: (Function: () -> ()) -> (),
	Expect: ((Value: any) -> FunctionalCases) & ExpectHandler,
	Expected: (Value: any) -> (),
	ExpectEqual: (Expected: any, Value: any) -> (),
}

type TestInfo = {
	Name: string?,
}

type StackTraceInfo = {
	Source: string,
	Name: string,
	Line: number,
	Address: string,
}

local Testing = {}

Testing.Running = true

Testing.Failed = 0
Testing.Count = 0
Testing.Start = nil :: number?

local DeferQueue = {} :: { () -> () }
local ScopeStack = {} :: { string }
local TestStack = {} :: { string }

local function NonEmptyString(Value: any?): boolean
	return type(Value) == "string" and #Value > 1
end

local function WriteStackTrace(Source: string, Name: string, Line: number, Address: string): StackTraceInfo
	return {
		Source = Source,
		Name = Name,
		Line = Line,
		Address = Address,
	}
end

local function SecondsToMicroseconds(Seconds: number): number
	return math.floor(Seconds * 1000000)
end

local function FormatTime(Microseconds: number): string
	if Microseconds >= 1000000 then
		return string.format("%.2fs", Microseconds / 1000000)
	elseif Microseconds >= 1000 then
		return string.format("%.2fms", Microseconds / 1000)
	else
		return string.format("%.0fs", Microseconds)
	end
end

local function RunTest(Function: () -> (), Info: TestInfo)
	Testing.Count += 1
	if Testing.Count % 90 == 0 then
		task.wait()
	end

	if not Testing.Start then
		Testing.Start = os.clock()
	end

	local Ok, Error
	local StackTrace = {}
	local TimeStart = os.clock()
	local ThisSource = debug.info(function() end, "s")

	Ok = xpcall(Function, function(ErrorMessage)
		local LastName = debug.info(1, "n")
		local WasIntentional = debug.info(2, "n") == "error"
		local ShortSource, SourceScript

		for Index = 1, 30 do
			local DebugFunction, Name, Line, Source = debug.info(Index + 1, "fnls")
			if not DebugFunction then
				break
			end

			local LineNumber = LastName
			if #StackTrace > 0 or NonEmptyString(Name) then
				LastName = Name
			end
			if Line < 0 then
				continue
			end

			if Source == ThisSource and WasIntentional then
				continue
			end

			local ShortenedSource = ShortSource or Source

			if not ShortSource then
				local SourceEnv = getfenv(DebugFunction)
				if SourceEnv and SourceEnv.script then
					SourceScript = SourceEnv.script :: Instance

					ShortenedSource = `{SourceScript.Parent}.{SourceScript}`
					ShortSource = ShortenedSource
				end
			end

			table.insert(StackTrace, WriteStackTrace(ShortenedSource, LineNumber :: string, Line, tostring(DebugFunction)))
		end

		Error = ErrorMessage
		if ShortSource and SourceScript then
			Error = (Error :: string):gsub((SourceScript :: Instance):GetFullName(), ShortSource)
		end
	end)

	local TimeLength = SecondsToMicroseconds(os.clock() - TimeStart)
	local ScopePadded = if #ScopeStack > 0 then " " else ""
	local Scope = `{ScopePadded}{table.concat(ScopeStack, "/")}`
	Scope ..= ` ({Info.Name})`

	for Index = #DeferQueue, 1, -1 do
		local Value = DeferQueue[Index]
		local Success = pcall(Value)
		if not Success then
			print(`Deferred function failed`)
		end
	end
	table.clear(DeferQueue)

	local TestType = Ok and "PASS" or "FAIL"
	if Ok then
		print(`{TestType}{Scope} [{FormatTime(TimeLength)}]`)
	else
		Testing.Failed += 1
		warn(`{TestType}{Scope} [{FormatTime(TimeLength)}]`)
		warn(`@ error: {Error}`)

		local Size = #StackTrace
		for StackIndex, StackValue in StackTrace do
			local NameHasValue = NonEmptyString(StackValue.Name)
			if StackIndex == Size then
				warn(
					` {StackValue.Source}:{StackValue.Line}: {StackValue.Address:sub(11)}{NameHasValue and ` called {StackValue.Name}` or ""}`
				)
			else
				warn(
					` {StackValue.Source}:{StackValue.Line}: {StackValue.Address:sub(11)}{NameHasValue and ` called {StackValue.Name}` or ""}`
				)
			end
		end
	end
end

function Testing.Describe(Name: string, Function: (...any) -> ...any): ()
	local Line = debug.info(2, "l")
	table.insert(ScopeStack, Name)

	local Ok, Error = pcall(Function :: any)
	table.remove(ScopeStack)
	if not Ok then
		Testing.Failed += 1
		print(`{Line}: Describe("{Name}", ...):`)
		print(`{Error}`)
	end
end

function Testing.Test(Name: string, Function: (...any) -> ...any, Timeout: number?): ()
	table.insert(TestStack, Name)
	RunTest(Function, {
		Name = Name,
		Timeout = Timeout,
	})
	table.remove(TestStack)
end

function Testing.Entry(Function: (...any) -> ...any): ()
	Testing.Count = 0
	Testing.Failed = 0

	Function()

	local Time = os.clock() - (Testing.Start or os.clock())
	local Count = Testing.Count
	local Failed = Testing.Failed
	if Failed > 0 then
		print(` Tests: {Failed} failed, {Count} total`)
	else
		print(` Tests: {Count} total`)
	end

	print(` Time: {math.ceil(Time * 1000) / 1000} s`)
end

function Testing.Complete(): ()
	local Time = os.clock() - (Testing.Start or os.clock())
	local Count = Testing.Count
	local Failed = Testing.Failed
	if Failed > 0 then
		print(` Tests: {Failed} failed, {Count} total`)
	else
		print(` Tests: {Count} total`)
	end

	print(` Time: {math.ceil(Time * 1000) / 1000} s`)
end

function Testing.Defer(Function: () -> ())
	table.insert(DeferQueue, Function)
end

local function AssertExpect(Flipped: boolean, Value: boolean, Format: string, ...: any)
	if Flipped then
		Value = not Value
	end

	if not Value then
		error(string.format(Format :: any, ...), 4)
	end
end

local Conditional = {}
Conditional.__index = Conditional

function Conditional.New(Name: string, Function: (Value: any) -> (boolean, any?, string?), Any: any?)
	return setmetatable({
		Test = Function,
		Name = Name,
		Value = Any,
	}, Conditional)
end

function Conditional.Is(Any)
	return type(Any) == "table" and getmetatable(Any) == Conditional
end

type Conditional = typeof(Conditional.New("", function(_)
	return true, ""
end))

function Conditional.__call(self: Conditional, ...)
	return self.Test(...)
end

function Conditional.__tostring(self: Conditional)
	return self.Name
end

type ConditionState = {
	Received: any,
	Flipped: boolean,
	Shared: { [string]: any },
}

local function FlipTag(Flipped: boolean)
	return if Flipped then "not " else ""
end

local ReadableControl = {
	["\n"] = "\\n",
	["\r"] = "\\r",
	["\t"] = "\\t",
	["\v"] = "\\v",
	["\f"] = "\\f",
	["\b"] = "\\b",
	["\a"] = "\\a",
	["\\"] = "\\\\",
	['"'] = '\\"',
	["%"] = string.format("\\x%02X", 37),
}

local function Readable(Value: any)
	local Type = type(Value)
	if Type == "string" then
		local SafeValue = Value:gsub(".", function(Character: string)
			local Byte = Character:byte()
			if Byte < 32 or Byte > 126 then
				if ReadableControl[Character] then
					return ReadableControl[Character]
				else
					return string.format("\\x%02X", Byte)
				end
			elseif Character == "\\" then
				return "\\\\"
			elseif ReadableControl[Character] then
				return ReadableControl[Character]
			end

			return Character
		end)

		return `"{SafeValue}"`
	elseif Type ~= "table" then
		return tostring(Value)
	else
		return tostring(Value)
	end
end

local Conditionals = {
	ToBe = function(self: ConditionState, Expected: any)
		if Conditional.Is(Expected) then
			local Condition, Any, String = Expected(self.Received)
			if String then
				AssertExpect(self.Flipped, Condition, String, FlipTag(self.Flipped))
			else
				AssertExpect(
					self.Flipped,
					Condition,
					"Expected %s to %sbe %s",
					Any or Readable(self.Received),
					FlipTag(self.Flipped),
					Readable(Expected)
				)
			end
		else
			AssertExpect(
				self.Flipped,
				self.Received == Expected,
				"Expected %s to %sbe %s",
				Readable(self.Received),
				FlipTag(self.Flipped),
				Readable(Expected)
			)
		end
	end,

	ToBeDefined = function(self: ConditionState)
		AssertExpect(
			self.Flipped,
			self.Received ~= nil,
			"Expected %s to %sbe defined",
			Readable(self.Received),
			FlipTag(self.Flipped)
		)
	end,

	ToBeCloseTo = function(self: ConditionState, Expected, Precision: number)
		AssertExpect(
			self.Flipped,
			Expected == math.huge and self.Received == math.huge
				or Expected == -math.huge and self.Received == -math.huge
				or math.abs(self.Received - Expected) < (10 ^ -Precision) / 2,
			"Expected %s to be close to %s",
			Readable(self.Received),
			Expected
		)
	end,

	ToBeGreaterThan = function(self: ConditionState, Expected)
		AssertExpect(
			self.Flipped,
			self.Received > Expected,
			"Expected %s to %sbe greater than %s",
			Readable(self.Received),
			FlipTag(self.Flipped),
			Readable(Expected)
		)
	end,

	ToBeGreaterThanOrEqual = function(self: ConditionState, Expected)
		AssertExpect(
			self.Flipped,
			self.Received >= Expected,
			"Expected %s to %sbe greater than or equal to %s",
			Readable(self.Received),
			FlipTag(self.Flipped),
			Readable(Expected)
		)
	end,

	ToBeLessThan = function(self: ConditionState, Expected)
		AssertExpect(
			self.Flipped,
			self.Received < Expected,
			"Expected %s to %sbe less than %s",
			Readable(self.Received),
			FlipTag(self.Flipped),
			Readable(Expected)
		)
	end,

	ToBeLessThanOrEqual = function(self: ConditionState, Expected)
		AssertExpect(
			self.Flipped,
			self.Received <= Expected,
			"Expected %s to %sbe less than or equal to %s",
			Readable(self.Received),
			FlipTag(self.Flipped),
			Readable(Expected)
		)
	end,

	ToBeNil = function(self: ConditionState)
		AssertExpect(
			self.Flipped,
			self.Received == nil,
			"Expected %s to %sbe Nil",
			Readable(self.Received),
			FlipTag(self.Flipped)
		)
	end,

	ToBeNan = function(self: ConditionState)
		AssertExpect(
			self.Flipped,
			self.Received ~= self.Received and type(self.Received) == "number",
			"Expected %s to %sbe NaN",
			Readable(self.Received),
			FlipTag(self.Flipped)
		)
	end,

	ToHaveLength = function(self: ConditionState, Expected)
		AssertExpect(
			self.Flipped,
			#self.Received == Expected,
			"Expected %s to %shave length %s",
			Readable(self.Received),
			FlipTag(self.Flipped),
			Readable(Expected)
		)
	end,

	ToBeFalsy = function(self: ConditionState)
		AssertExpect(
			self.Flipped,
			not self.Received,
			"Expected %s to %sbe falsy",
			Readable(self.Received),
			FlipTag(self.Flipped)
		)
	end,

	ToBeTruthy = function(self: ConditionState)
		AssertExpect(
			self.Flipped,
			self.Received,
			"Expected %s to %sbe truthy",
			Readable(self.Received),
			FlipTag(self.Flipped)
		)
	end,

	ToThrow = function(self: ConditionState, Expected: string?)
		AssertExpect(
			false,
			type(self.Received) == "function",
			"Expected %s to %sbe a function",
			Readable(self.Received),
			FlipTag(self.Flipped)
		)
		local Success, Error = pcall(self.Received)
		if Expected ~= nil then
			AssertExpect(false, type(Error) == "string", "Expected error to be a string (got %s)", Readable(Error))
			AssertExpect(
				false,
				not Success,
				"Expected %s to %sthrow an error",
				Readable(self.Received),
				FlipTag(self.Flipped)
			)
			local Stripped = Error:match(`^.+:%d+: (.+)$`)
			if Stripped then
				AssertExpect(
					self.Flipped,
					Stripped == Expected,
					"Got error %s expected to %sthrow %s",
					Readable(Stripped),
					FlipTag(self.Flipped),
					Readable(Expected)
				)
			else
				AssertExpect(
					self.Flipped,
					Error == Expected,
					"Got error %s expected to %sthrow %s",
					Readable(Error),
					FlipTag(self.Flipped),
					Readable(Expected)
				)
			end
		else
			AssertExpect(
				self.Flipped,
				not Success,
				"Expected %s to %sthrow an error",
				Readable(self.Received),
				FlipTag(self.Flipped)
			)
		end
	end,
}

Conditionals.ToEqual = Conditionals.ToBe

type ScanResult = { string }

local function DeepScan(Any: any, Second: any, State: { [any]: any }, Key: string?): ScanResult
	if Any == Second then
		return {}
	end

	if Conditional.Is(Any) then
		if Any.Name ~= "@similar" then
			local Result, _, Reason = (Any :: any)(Second)
			if not Result then
				return { `{Key or ""}{if Reason then string.format(Reason, "") else "failed condition"}` }
			end
			return {}
		else
			Any = Any.Value
		end
	end

	if type(Any) ~= type(Second) then
		return { `{Key or ""}(type: {type(Any)}) ~= (type: {type(Second)})` }
	end

	if type(Any) == "table" then
		if State[Any] == Second then
			return {}
		end

		State[Any] = Second
		local Chunk = {}
		local KeysHit = {}
		for EntryKey, Value in Any do
			local Result = DeepScan(Value, Second[EntryKey], State, `[{Readable(EntryKey)}]: `)
			if #Result > 0 then
				KeysHit[EntryKey] = true
			end
			for _, Difference in Result do
				table.insert(Chunk, `{Difference}`)
			end
		end

		for EntryKey, Value in Second do
			local Result = DeepScan(Any[EntryKey], Value, State, `[{Readable(EntryKey)}]: `)
			if KeysHit[EntryKey] then
				continue
			end
			for _, Difference in Result do
				table.insert(Chunk, `{Difference}`)
			end
		end

		if #Chunk > 0 then
			table.insert(Chunk, 1, `{Key or ""}\{`)
			table.insert(Chunk, `\}`)
			return Chunk
		end
		return {}
	end

	return { `{Key or ""}(value: {Readable(Any)}) ~= (value: {Readable(Second)})` }
end

local Expect = setmetatable({
	Nothing = Conditional.New("nothing", function(Value)
		return Value == nil
	end),

	Any = function(TypeName: string)
		if type(TypeName) ~= "string" then
			error(`Expect.Any expected string, got {type(TypeName)}`, 2)
		end
		return Conditional.New(TypeName, function(Value)
			local Type = type(Value)
			return Type == TypeName, Type, `value is supposed to %sbe of type {TypeName}, got {Type}`
		end)
	end,

	Type = function(TypeName: string)
		if type(TypeName) ~= "string" then
			error(`Expect.Type expected string, got {type(TypeName)}`, 2)
		end
		return Conditional.New(TypeName, function(Value)
			local Type = type(Value)
			return Type == TypeName, Type, `value is supposed to %sbe of type {TypeName}, got {Type}`
		end)
	end,

	Similar = function(Table: { [any]: any })
		if type(Table) ~= "table" then
			error(`Expect.Similar expected table, got {type(Table)}`, 2)
		end
		return Conditional.New("@similar", function(Value)
			local Result = DeepScan(Table, Value, {})
			return #Result == 0, nil, `value is supposed to %sbe similar to value, got:\n{table.concat(Result, "\n")}`
		end, Table)
	end,
}, {
	__call = function(self: any, Value: any)
		local Object = {
			Never = {},
		}

		local SharedState = {}
		local NormalState = {
			Received = Value,
			Flipped = false,
			Shared = SharedState,
		}
		local NeverState = {
			Received = Value,
			Flipped = true,
			Shared = SharedState,
		}
		for Key, Function in Conditionals :: { [string]: (...any) -> () } do
			Object[Key] = function(...)
				Function(NormalState, ...)
			end
			Object.Never[Key] = function(...)
				Function(NeverState, ...)
			end
		end

		return Object
	end,
})

Testing.Expect = Expect
Testing.Expected = function(Any: any)
	if not Any then
		error("Truthy value expected", 2)
	end
end

Testing.ExpectEqual = function(Any: any, Second: any)
	if Any ~= Second then
		error(string.format("Expected %s to be equal to %s", Readable(Any), Readable(Second)), 2)
	end
end

return (Testing :: any) :: TestingLib
]]></ProtectedString>
						<string name="ScriptGuid">{35214B89-739F-499B-816E-D5D2EF2739F9}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Testing</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXEADDB1297C714F83823B8640CE056614">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	ChaCha20-Poly1305 & XChaCha20-Poly1305 Wycheproof Test Suite
	
	Test Vector Sources:
		ChaCha20: https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/chacha20_poly1305_test.json
		XChaCha20: https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/xchacha20_poly1305_test.json
	
	Test Categories:
		Ktv - Known test vectors from RFC 7539 / draft-arciszewski-xchacha
		Pseudorandom - Various input sizes
		ModifiedTag - Tampered authentication tags
		EdgeCasePoly1305 - Integer overflow edge cases
		EdgeCaseTag - Final modular addition edge cases
		InvalidNonceSize - Non-standard nonce sizes
	
	Nonce Size Restrictions:
		ChaCha20-Poly1305: 96-bit (12 bytes) per RFC 7539
		XChaCha20-Poly1305: 192-bit (24 bytes) per spec
		Tests with other nonce sizes are skipped as invalid.
	
	Empty Message Limitation:
		Tests with empty messages are skipped because it won't be supported.
--]=]

--!strict
--!optimize 2

local Http = game:GetService("HttpService")

local Testing = require("./")
local Cryptography = require("../")

local AEAD = Cryptography.Encryption.AEAD
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex

type AeadTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	key: string,
	iv: string,
	aad: string?,
	msg: string,
	ct: string,
	tag: string,
	result: string,
}

type AeadGroup = {
	type: string,
	keySize: number,
	ivSize: number,
	tagSize: number,
	source: {name: string, version: string}?,
	tests: {AeadTest},
}

type AeadData = {
	algorithm: string,
	numberOfTests: number,
	testGroups: {AeadGroup},
}

local CHACHA20_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/chacha20_poly1305_test.json"
local XCHACHA20_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/xchacha20_poly1305_test.json"

local function BuffersEqual(A: buffer, B: buffer): boolean
	if buffer.len(A) ~= buffer.len(B) then
		return false
	end

	for Index = 0, buffer.len(A) - 1 do
		if buffer.readu8(A, Index) ~= buffer.readu8(B, Index) then
			return false
		end
	end

	return true
end

local function FetchTestVectors(Url: string): AeadData
	local Response = Http:GetAsync(Url)
	return Http:JSONDecode(Response) :: AeadData
end

local function RunAeadTests(
	Data: AeadData,
	RequiredIvSize: number,
	IsXChaCha: boolean
): (number, number)
	local SkippedNonceCount = 0
	local SkippedEmptyCount = 0

	for GroupIndex, Group in ipairs(Data.testGroups) do
		local IvSize = Group.ivSize
		local KeySize = Group.keySize
		local TagSize = Group.tagSize

		if IvSize ~= RequiredIvSize then
			SkippedNonceCount += #Group.tests
			continue
		end

		local SourceName = if Group.source then Group.source.name else "unknown"

		Testing.Describe(`Group_{GroupIndex}: {KeySize}bit_Key_{IvSize}bit_IV_{TagSize}bit_Tag (Source: {SourceName})`, function()
			for _, Test in ipairs(Group.tests) do
				local TestId = Test.tcId
				local Comment = Test.comment or ""
				local ExpectedResult = Test.result
				local Msg = FromHex(Test.msg)

				if buffer.len(Msg) == 0 then
					SkippedEmptyCount += 1
					continue
				end

				local TestName = `Test_{TestId}`
				if Comment ~= "" then
					TestName = `Test_{TestId}_{Comment:sub(1, 25):gsub(" ", "_")}`
				end

				Testing.Test(TestName, function()
					local Key = FromHex(Test.key)
					local Iv = FromHex(Test.iv)
					local Aad = FromHex(Test.aad or "")
					local ExpectedCt = FromHex(Test.ct)
					local ExpectedTag = FromHex(Test.tag)

					if ExpectedResult == "valid" then
						local EncOk, Ct, Tag = pcall(function()
							if IsXChaCha then
								return AEAD.Encrypt(Msg, Key, Iv, Aad, 20, true)
							else
								return AEAD.Encrypt(Msg, Key, Iv, Aad)
							end
						end)

						Testing.Expect(EncOk).ToBe(true)
						Testing.Expect(Ct).ToBeDefined()
						Testing.Expect(Tag).ToBeDefined()

						if EncOk and Ct and Tag then
							Testing.Expect(BuffersEqual(Ct, ExpectedCt)).ToBe(true)
							Testing.Expect(BuffersEqual(Tag, ExpectedTag)).ToBe(true)

							local DecOk, Plaintext = pcall(function()
								if IsXChaCha then
									return AEAD.Decrypt(Ct, Key, Iv, Tag, Aad, 20, true)
								else
									return AEAD.Decrypt(Ct, Key, Iv, Tag, Aad)
								end
							end)

							Testing.Expect(DecOk).ToBe(true)
							Testing.Expect(Plaintext).ToBeDefined()

							if Plaintext then
								Testing.Expect(BuffersEqual(Plaintext, Msg)).ToBe(true)
							end
						end
					elseif ExpectedResult == "invalid" then
						local DecOk, Result = pcall(function()
							if IsXChaCha then
								return AEAD.Decrypt(ExpectedCt, Key, Iv, ExpectedTag, Aad, 20, true)
							else
								return AEAD.Decrypt(ExpectedCt, Key, Iv, ExpectedTag, Aad)
							end
						end)

						local DecryptionFailed = not DecOk or not Result
						Testing.Expect(DecryptionFailed).ToBe(true)
					elseif ExpectedResult == "acceptable" then
						Testing.Expect(true).ToBe(true)
					end
				end)
			end
		end)
	end

	return SkippedNonceCount, SkippedEmptyCount
end

Testing.Describe("ChaCha20-Poly1305 Wycheproof Tests", function()
	local Data = FetchTestVectors(CHACHA20_URL)
	local SkippedNonce, SkippedEmpty = RunAeadTests(Data, 96, false)

	if SkippedNonce > 0 then
		print(`[Info] Skipped {SkippedNonce} tests with non-96-bit nonces (invalid per RFC 7539)`)
	end
	if SkippedEmpty > 0 then
		print(`[Info] Skipped {SkippedEmpty} tests with empty messages (unsupported)`)
	end
end)

Testing.Describe("XChaCha20-Poly1305 Wycheproof Tests", function()
	local Data = FetchTestVectors(XCHACHA20_URL)
	local SkippedNonce, SkippedEmpty = RunAeadTests(Data, 192, true)

	if SkippedNonce > 0 then
		print(`[Info] Skipped {SkippedNonce} tests with non-192-bit nonces (invalid per spec)`)
	end
	if SkippedEmpty > 0 then
		print(`[Info] Skipped {SkippedEmpty} tests with empty messages (unsupported)`)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{D88057C0-66A4-4F3F-906C-A9AF026D7DCE}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">AEAD</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX35F22103BFEF44D78425E0FF34F47B40">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	AES-GCM Wycheproof Test Suite
	
	Test Vector Source:
		https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/aes_gcm_test.json
	
	Test Categories:
		Ktv - Known test vectors
		Pseudorandom - Various input sizes
		ModifiedTag - Tampered authentication tags
		SmallIv / LongIv / ZeroLengthIv - Non-standard IV sizes
		CounterWrap - Counter overflow edge cases
	
	IV Size Restriction (96-bit only):
		This implementation only supports 96-bit (12-byte) IVs for security reasons.
		Non 96bit IVs require GHASH compression which introduces risks:
		
		1. Authentication key leakage: If the same IV is derived from different
		 	inputs via GHASH, an attacker can recover the authentication key H.
		
		2. Counter wrap attacks: Long IVs can produce counter values near 2^32,
		 	enabling attacks that leak information about the GHASH of the IV.
		
		Idk why you would even use a different size nonce.
--]=]

--!strict
--!optimize 2

local Http = game:GetService("HttpService")

local Testing = require("./")
local Cryptography = require("../")

local AES = Cryptography.Encryption.AES
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex

type AeadTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	key: string,
	iv: string,
	aad: string?,
	msg: string,
	ct: string,
	tag: string,
	result: string,
}

type AeadGroup = {
	type: string,
	keySize: number,
	ivSize: number,
	tagSize: number,
	source: {name: string, version: string}?,
	tests: {AeadTest},
}

type AeadData = {
	algorithm: string,
	numberOfTests: number,
	testGroups: {AeadGroup},
}

local WYCHEPROOF_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/aes_gcm_test.json"

local function BuffersEqual(A: buffer, B: buffer): boolean
	if buffer.len(A) ~= buffer.len(B) then
		return false
	end

	for Index = 0, buffer.len(A) - 1 do
		if buffer.readu8(A, Index) ~= buffer.readu8(B, Index) then
			return false
		end
	end

	return true
end

local function FetchTestVectors(): AeadData
	local Response = Http:GetAsync(WYCHEPROOF_URL)
	return Http:JSONDecode(Response) :: AeadData
end

Testing.Describe("AES-GCM Wycheproof Tests", function()
	local Data = FetchTestVectors()
	local SkippedCount = 0

	for GroupIndex, Group in ipairs(Data.testGroups) do
		local KeySize = Group.keySize
		local IvSize = Group.ivSize
		local TagSize = Group.tagSize

		if IvSize ~= 96 then
			SkippedCount += #Group.tests
			continue
		end

		local SourceName = if Group.source then Group.source.name else "unknown"

		Testing.Describe(`Group_{GroupIndex}: {KeySize}bit_Key_{IvSize}bit_IV_{TagSize}bit_Tag (Source: {SourceName})`, function()
			for _, Test in ipairs(Group.tests) do
				local TestId = Test.tcId
				local Comment = Test.comment or ""
				local ExpectedResult = Test.result

				local TestName = `Test_{TestId}`
				if Comment ~= "" then
					TestName = `Test_{TestId}_{Comment:sub(1, 25):gsub(" ", "_")}`
				end

				Testing.Test(TestName, function()
					local Key = FromHex(Test.key)
					local Iv = FromHex(Test.iv)
					local Aad = FromHex(Test.aad or "")
					local Msg = FromHex(Test.msg)
					local ExpectedCt = FromHex(Test.ct)
					local ExpectedTag = FromHex(Test.tag)

					if ExpectedResult == "valid" then
						local EncOk, Ct, Tag = pcall(function()
							return AES.Encrypt(Msg, Key, Iv, Aad)
						end)

						Testing.Expect(EncOk).ToBe(true)
						Testing.Expect(Ct).ToBeDefined()
						Testing.Expect(Tag).ToBeDefined()

						if EncOk and Ct and Tag then
							Testing.Expect(BuffersEqual(Ct, ExpectedCt)).ToBe(true)
							Testing.Expect(BuffersEqual(Tag, ExpectedTag)).ToBe(true)

							local DecOk, DecSuccess, Plaintext = pcall(function()
								return AES.Decrypt(Ct, Key, Iv, Tag, Aad)
							end)

							Testing.Expect(DecOk).ToBe(true)
							Testing.Expect(DecSuccess).ToBe(true)
							Testing.Expect(Plaintext).ToBeDefined()

							if Plaintext then
								Testing.Expect(BuffersEqual(Plaintext, Msg)).ToBe(true)
							end
						end
					elseif ExpectedResult == "invalid" then
						local DecOk, DecSuccess, _ = pcall(function()
							return AES.Decrypt(ExpectedCt, Key, Iv, ExpectedTag, Aad)
						end)

						local DecryptionFailed = not DecOk or not DecSuccess
						Testing.Expect(DecryptionFailed).ToBe(true)
					elseif ExpectedResult == "acceptable" then
						Testing.Expect(true).ToBe(true)
					end
				end)
			end
		end)
	end

	if SkippedCount > 0 then
		print(`[Info] Skipped {SkippedCount} tests with non-96-bit IVs (unsupported for security reasons)`)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{C4F576CB-A7D9-4299-9FB5-4A66DEBC2313}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">AES</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXECBE55E4C34641ED981CDC4643C28DCA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: number
}

type TestVectors = {[string]: TestVector}

local Algorithm = require("../Checksums/Adler")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = 0x1 },
	["a"] = { Description = "Single Character", Expected = 0x00620062 },
	["\0"] = { Description = "Null Terminator", Expected = 0x00010001 },
	["Wikipedia"] = { Description = "Wikipedia Example", Expected = 0x11e60398 },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = 0x47d914d8 },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = 0x807416f9 },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = 0x343e2a10 },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = 0x92712d18 },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = 0x766d5a90 },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = 0xf3788410 },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = 0xb6551638 },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = 0x15d870f9 },
}
Testing.Describe("Adler Checksum Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{0D8E6C7E-9E42-4C2A-B628-F2468C383B35}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Adler</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEB482C36ADA94AAFB97EA4890C73E6F6">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string,
	Algorithm: "Encode" | "Decode"
}

type TestVectors = {[string]: TestVector}

local Algorithm = require("../Utilities/Base64")
local TestVectors: TestVectors = {
	["VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4="] = { Algorithm = "Decode", Description = "Pangramm Example [Decode]", Expected = "The quick brown fox jumps over the lazy dog." },
	["0J/RgNC40LLQtdGCLCDQvNC40YAh"] = { Algorithm = "Decode", Description = "UTF-8 Example [Decode]", Expected = ", !" },
	["YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ=="] = { Algorithm = "Decode", Description = "Block of Characters [Decode]", Expected = string.rep("a", 55) },
	["The quick brown fox jumps over the lazy dog."] = { Algorithm = "Encode", Description = "Pangramm Example [Encode]", Expected = "VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=" },
	[", !"] = { Algorithm = "Encode", Description = "UTF-8 Example [Encode]", Expected = "0J/RgNC40LLQtdGCLCDQvNC40YAh" },
	[string.rep("a", 55)] = { Algorithm = "Encode", Description = "Block of Characters [Encode]", Expected = "YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ==" },
	["SGVsbG8gV29ybGQ="] = { Algorithm = "Decode", Description = "Hello World [Decode]", Expected = "Hello World" },
	["Hello World"] = { Algorithm = "Encode", Description = "Hello World [Encode]", Expected = "SGVsbG8gV29ybGQ=" }	
}

Testing.Describe("Base64 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result
			if Info.Algorithm == "Decode" then
				Result = buffer.tostring(Algorithm.Decode(buffer.fromstring(TestString)))
			elseif Info.Algorithm == "Encode" then
				Result = buffer.tostring(Algorithm.Encode(buffer.fromstring(TestString)))
			end
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{68BF511F-A4B5-4405-92CB-59EE8D6AD2B3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Base64</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEAB23F14807043AEAC4788975F0AF879">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string,
	OutLen: number?,
	Key: string?
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/Blake2b")

local TestVectors: TestVectors = {
	["abc"] = { 
		Description = "Basic ABC Test", 
		Expected = "ba80a53f981c4d0d6a2797b69f12f6e94c212f14685ac4b74b12bb6fdbffa2d17d87c5392aab792dc252d5de4533cc9518d38aa8dbf1925ab92386edd4009923",
		OutLen = 64
	},
	["abc_60"] = { 
		Description = "ABC 60 Bytes", 
		Expected = "bdc0b8b38bd714f166d1cf227148c8de5a5ed75da184589212d8a584cccd73a02422f43c4dd1a427b8fbad742d348eb81d8cb7492efe626fce490618",
		OutLen = 60
	},
	["abc_56"] = { 
		Description = "ABC 56 Bytes", 
		Expected = "13ee23af59cf24b95795d6417d2592f96d772eb6c4866e51698ecf6d4848539251ae2ee731a28758ecbcd5cb5f3f005c202f509cc32975b1",
		OutLen = 56
	},
	["abc_52"] = { 
		Description = "ABC 52 Bytes", 
		Expected = "9a5803f1993120dfbf7af41936779ae2192dee216146b264e8080aae7dc602926e8d533565d775b43be548cb67c49aa7cde9e063",
		OutLen = 52
	},
	["abc_48"] = { 
		Description = "ABC 48 Bytes", 
		Expected = "6f56a82c8e7ef526dfe182eb5212f7db9df1317e57815dbda46083fc30f54ee6c66ba83be64b302d7cba6ce15bb556f4",
		OutLen = 48
	},
	["abc_44"] = { 
		Description = "ABC 44 Bytes", 
		Expected = "db1ccc0bf65b615c7269cf24b45ba65c665cb228ef77057ce4f9bec0b2821af9f9ffdd5441bd260ea1158084",
		OutLen = 44
	},
	["abc_40"] = { 
		Description = "ABC 40 Bytes", 
		Expected = "8ad6d6166cdc8c2ffd5f25c5e7f957513b4a0e6661e998c3744a101363ac6e352858b0d412d5c322",
		OutLen = 40
	},
	["abc_36"] = { 
		Description = "ABC 36 Bytes", 
		Expected = "b2b77f50103450a6aaed6b3b080dbe5bacde149c9587a0096149418264d1fee0b98dac2b",
		OutLen = 36
	},
	["abc_32"] = { 
		Description = "ABC 32 Bytes", 
		Expected = "bddd813c634239723171ef3fee98579b94964e3bb1cb3e427262c8c068d52319",
		OutLen = 32
	},
	["abc_28"] = { 
		Description = "ABC 28 Bytes", 
		Expected = "9bd237b02a29e43bdd6738afa5b53ff0eee178d6210b618e4511aec8",
		OutLen = 28
	},
	["abc_24"] = { 
		Description = "ABC 24 Bytes", 
		Expected = "56a17e38cc371a46b12c32f18e0c61de2a84e9c2555b114e",
		OutLen = 24
	},
	["abc_16"] = { 
		Description = "ABC 16 Bytes", 
		Expected = "cf4ab791c62b8d2b2109c90275287816",
		OutLen = 16
	},
	["abc_8"] = { 
		Description = "ABC 8 Bytes", 
		Expected = "d8bb14d833d59559",
		OutLen = 8
	},
	["abc_4"] = { 
		Description = "ABC 4 Bytes", 
		Expected = "63906248",
		OutLen = 4
	},
	["abc_2"] = { 
		Description = "ABC 2 Bytes", 
		Expected = "ae1e",
		OutLen = 2
	},
	["abc_1"] = { 
		Description = "ABC 1 Byte", 
		Expected = "6b",
		OutLen = 1
	},

	["abc_key_64"] = { 
		Description = "ABC with 64 Byte Key", 
		Expected = "c2f2d6db0908b89406dfd636c55abd50f31be6b13767a6258f61e476aca87416f876ce17bd336c3d3f6b6a2652f42b8480c3edd1ae66657f587f925b87ab8416",
		OutLen = 64,
		Key = "ba80a53f981c4d0d6a2797b69f12f6e94c212f14685ac4b74b12bb6fdbffa2d1"
	},
	["abc_key_60"] = { 
		Description = "ABC with 60 Byte Key", 
		Expected = "0a1af64a08b611489317551c2fab679ee167f522063f185dd9401abb9a98168fa28020d7a630d8f95890a9cde3d3caaee40e925b6ef4fbc6bef19b982b7afb07",
		OutLen = 64,
		Key = "bdc0b8b38bd714f166d1cf227148c8de5a5ed75da184589212d8a584cccd"
	},
	["abc_key_56"] = { 
		Description = "ABC with 56 Byte Key", 
		Expected = "5898daa9ef3e553095d750fb92c53d531350abdae57b590cd319ecc6dc8d0a41370e063344505f0016bf59b09ba5b5282f68830f5bbb40f117c74bfb678d6a5d",
		OutLen = 64,
		Key = "13ee23af59cf24b95795d6417d2592f96d772eb6c4866e51698ecf6d"
	},
	["abc_key_48"] = { 
		Description = "ABC with 48 Byte Key", 
		Expected = "be0a08a35fa7bac9f2441b52d41abc0b19981a14f1161575e70c28c18a7154edd2fb764cb45f17e87bec23a22a3454266b03777fb770be817c59ff80e349cd86",
		OutLen = 64,
		Key = "6f56a82c8e7ef526dfe182eb5212f7db9df1317e57815dbd"
	},
	["abc_key_44"] = { 
		Description = "ABC with 44 Byte Key", 
		Expected = "6dda971e92cd392f866c7442b585ca16a3b8e7e052b0cff9ce2cb63db3cd0e9bf88b3f9379d83d0e00e800d791db9b95cc375a4958effc68135e7d84d4fb98e3",
		OutLen = 64,
		Key = "db1ccc0bf65b615c7269cf24b45ba65c665cb228ef77"
	},
	["abc_key_40"] = { 
		Description = "ABC with 40 Byte Key", 
		Expected = "4bfd84ddcc52b007d929ce27feed940295fe37b8f6d28bd6ce101fd53a95bed870df7e2d88a4ac50bd7772d1b245af3d663cb6bdb6a8b1fa5eda24a859dc433d",
		OutLen = 64,
		Key = "8ad6d6166cdc8c2ffd5f25c5e7f957513b4a0e66"
	},
	["abc_key_36"] = { 
		Description = "ABC with 36 Byte Key", 
		Expected = "4d396810a9f4f1448f35f9de94610fc5067b44a3544fa746af327ccae319e7ea05b9f6d4705e1d668639db9ba636541ee582484528b6eb5310f8beff797a9e8a",
		OutLen = 64,
		Key = "b2b77f50103450a6aaed6b3b080dbe5bacde"
	},
	["abc_key_32"] = { 
		Description = "ABC with 32 Byte Key", 
		Expected = "a9ac1196ebf670f73f4764fd2d820c5c40818423a6f333fff98a6bb159aa24b20da24f44929c66c401c8a1d06d5d0f4af97633f276fabeddde3ed810c2385039",
		OutLen = 64,
		Key = "bddd813c634239723171ef3fee98579b"
	},
	["abc_key_16"] = { 
		Description = "ABC with 16 Byte Key", 
		Expected = "e1ca64e8abc97d6b08fade1e242f7c39340d74d4a9b0d3317ef9d2fbbf28a25a05fe83f4a7470e0220db8d1818f62029f57281d2aa608ebad9154a865ac2da70",
		OutLen = 64,
		Key = "cf4ab791c62b8d2b"
	},
	["abc_key_8"] = { 
		Description = "ABC with 8 Byte Key", 
		Expected = "bde1a9f80f3c88258053723754fff9d5155a5694a34669f7892c6469c0b9db6019b56b97ec25fa6b82173318fc27b67caee576cacd21e61f312bb6ea3c49c414",
		OutLen = 64,
		Key = "d8bb14d8"
	},
	["abc_key_4"] = { 
		Description = "ABC with 4 Byte Key", 
		Expected = "bef63af934a11a46a647ca0496bd03844cd52206bcf6eb95e8d1e815f7ca30415461cbeb269bfd09b8652518253fe00bb614e854a3f55900486799b474807736",
		OutLen = 64,
		Key = "6390"
	},
	["abc_key_2"] = { 
		Description = "ABC with 2 Byte Key", 
		Expected = "15cf17d6b18fcc83f2b4235492df9b98176ae9dba2de5b7ce29c8eb47b921fbbca7bd60ef779c437361a404090d30589626bf9d6edddf84027a7eef217c30bc5",
		OutLen = 64,
		Key = "ae"
	},
	["abc_key_1"] = { 
		Description = "ABC with 1 Byte Key", 
		Expected = "968ff3c3b73ad7825542c57d18f755ea5879894cf4ebd7a0720972ec627e563334f05c132cd62f3373b003564d7b87831f9fa306ae86b37ae9e8fe5977cc4836",
		OutLen = 64,
		Key = "6"
	},

	[""] = { 
		Description = "Empty String", 
		Expected = "786a02f742015903c6c6fd852552d272912f4740e15847618a86e217f71f5419d25e1031afee585313896444934eb04b903a685b1448b755d56f701afe9be2ce",
		OutLen = 64
	},
	["empty_key"] = { 
		Description = "Empty String with Key", 
		Expected = "0532e878558d08b3586bb2771609976c0d7d521e23447086aff388ff65b2d643b11b180f894ded8fad97a1bf2c4ac48caf2234d85699e44a5c40187dea2c21f5",
		OutLen = 64,
		Key = "786a02f742015903c6c6fd852552d272912f4740e15847618a86e217f71f5419"
	},

	["alphabet_448"] = { 
		Description = "448 Bit Alphabet", 
		Expected = "7285ff3e8bd768d69be62b3bf18765a325917fa9744ac2f582a20850bc2b1141ed1b3e4528595acc90772bdf2d37dc8a47130b44f33a02e8730e5ad8e166e888",
		OutLen = 64
	},
	["alphabet_448_key"] = { 
		Description = "448 Bit Alphabet with Key", 
		Expected = "e1988e2c9f4888f90e0d299a1f1ea651802c441edda1444931bad0e3f5cd0ad6840259504c54bf4bee74400ded9f7b9d824cdbbb354722b609cd8423c4e004de",
		OutLen = 64,
		Key = "7285ff3e8bd768d69be62b3bf18765a325917fa9744ac2f582a20850bc2b1141"
	},
	["alphabet_896"] = { 
		Description = "896 Bit Alphabet", 
		Expected = "ce741ac5930fe346811175c5227bb7bfcd47f42612fae46c0809514f9e0e3a11ee1773287147cdeaeedff50709aa716341fe65240f4ad6777d6bfaf9726e5e52",
		OutLen = 64
	},
	["alphabet_896_key"] = { 
		Description = "896 Bit Alphabet with Key", 
		Expected = "d64e6645fc551fcb490f6cdb97fc70679c02f38ede8ef9be5a65d2ea5fbd0e61581aada01a1af6986070659e3a4c7343f069d510aaf8246b30dd3290c8e03831",
		OutLen = 64,
		Key = "ce741ac5930fe346811175c5227bb7bfcd47f42612fae46c0809514f9e0e3a11"
	},

	["foo"] = { 
		Description = "Foo Test", 
		Expected = "ca002330e69d3e6b84a46a56a6533fd79d51d97a3bb7cad6c2ff43b354185d6dc1e723fb3db4ae0737e120378424c714bb982d9dc5bbd7a0ab318240ddd18f8d",
		OutLen = 64
	},
	["foo_key"] = { 
		Description = "Foo with Key", 
		Expected = "1863442c12970f0f698383d9c8b3864e852c01cb49dff1a4e4a7f0aea90ed73177caf460b7396aee9739c2d991e8666b232965633c2a78b548f3f7535de8d3b0",
		OutLen = 64,
		Key = "ca002330e69d3e6b84a46a56a6533fd79d51d97a3bb7cad6c2ff43b354185d6d"
	},
	["bar"] = { 
		Description = "Bar Test", 
		Expected = "76aafe37ce69887569c3c1a51f14b639191fb2180cb0c87b566529496636712868556a9adf069d59769bf7e2393d215f195d8e7694f26fc7e20d92195973add8",
		OutLen = 64
	},
	["bar_key"] = { 
		Description = "Bar with Key", 
		Expected = "aee2742827f9eeb2270fa21a8b630c59633855886791b43021d70c6fd5c8d9c590a339c629c2653c6eb8959de89a4bdac2fbde208434a1d0b6c0f363c856927e",
		OutLen = 64,
		Key = "76aafe37ce69887569c3c1a51f14b639191fb2180cb0c87b5665294966367128"
	},
	["baz"] = { 
		Description = "Baz Test", 
		Expected = "2305476f21a28dd31ba7aaa4bcbd92780ff6c3ee77d45ea025dfec737e6bc725ce391585326dc22208f77c2643ca4afa34334042858a6f250e9094c8f77c82f6",
		OutLen = 64
	},
	["baz_key"] = { 
		Description = "Baz with Key", 
		Expected = "cf757dd4a0cfec70bf13dcd160852845560b9b3e8ce8020348825dd0f0e29716a081d5703983646957008ac2f1f6fd043a9c47bfbb9480176eeddc6cb6ee1e4f",
		OutLen = 64,
		Key = "2305476f21a28dd31ba7aaa4bcbd92780ff6c3ee77d45ea025dfec737e6bc725"
	},

	["fitness_gram"] = { 
		Description = "Fitness-Gram Test", 
		Expected = "7a17312276da3e41be9ef397aa035eadffe426afa70856d11155395f5af77932021e7db7995c536a86fbf9e840763f177d7bb2287c726a70b75494b018b6700c",
		OutLen = 64
	},
	["fitness_gram_key"] = { 
		Description = "Fitness-Gram with Key", 
		Expected = "d4ad49ad88892b37a5067739e07d3af18fece632f023dd266a2027668b6628424d21cca8daa6fbffca724bb3e623526995a3a808e2e01553eda36e3ae2f74a8f",
		OutLen = 64,
		Key = "7a17312276da3e41be9ef397aa035eadffe426afa70856d11155395f5af77932"
	},

	["block_size"] = { 
		Description = "Block Size Test", 
		Expected = "cc28dceb6925b2e02a177a961a0f819f464e3fa78c34be6117ea8ac6fbe02b58e6c91a1faf5605d3be43b23414a99c0322ada77a088f3454f980be1d3df68813",
		OutLen = 64
	},
	["block_size_key"] = { 
		Description = "Block Size with Key", 
		Expected = "a58b0e2f33b9fac979f77a58e30031a0ae5ec6c8946180bb1e03aaacbed8e94585f26c62925d1877e341076cbd5ae0ece4ac114009af2b6cf0f9e3671626eae4",
		OutLen = 64,
		Key = "cc28dceb6925b2e02a177a961a0f819f464e3fa78c34be6117ea8ac6fbe02b58"
	},

	["199999_e"] = { 
		Description = "199999 E Characters", 
		Expected = "720d7925523d2ca4e39e11e91231890446abaffd09f5e69628b326e5ad0295a4c0335726da08fc56120e52f378042a8146e2e56f38187f33bd23e8ec42b88f35",
		OutLen = 64
	},
	["199999_e_key"] = { 
		Description = "199999 E Characters with Key", 
		Expected = "9ac0a89038f6d3a82b681a8ad902e9c4e520b2597c7478184639084ce4ba5ab05c16f40859269a185837b208888cf870b4e2aa0d60e8a6cb0b1e2643b69d5526",
		OutLen = 64,
		Key = "720d7925523d2ca4e39e11e91231890446abaffd09f5e69628b326e5ad0295a4"
	},
	["million_a"] = { 
		Description = "Million A Characters", 
		Expected = "98fb3efb7206fd19ebf69b6f312cf7b64e3b94dbe1a17107913975a793f177e1d077609d7fba363cbba00d05f7aa4e4fa8715d6428104c0a75643b0ff3fd3eaf",
		OutLen = 64
	},
	["million_a_key"] = { 
		Description = "Million A Characters with Key", 
		Expected = "a01e874c2a19010ac02b16ea0eba0c03c434c00aeccb45fbe05b658111eff7dd254800b26c65819e420e4173e8731b4274a6561e3c7888db2d34cc488e315480",
		OutLen = 64,
		Key = "98fb3efb7206fd19ebf69b6f312cf7b64e3b94dbe1a17107913975a793f177e1"
	},
}

local TestData = {
	["abc"] = "abc",
	["abc_60"] = "abc",
	["abc_56"] = "abc",
	["abc_52"] = "abc",
	["abc_48"] = "abc",
	["abc_44"] = "abc",
	["abc_40"] = "abc",
	["abc_36"] = "abc",
	["abc_32"] = "abc",
	["abc_28"] = "abc",
	["abc_24"] = "abc",
	["abc_16"] = "abc",
	["abc_8"] = "abc",
	["abc_4"] = "abc",
	["abc_2"] = "abc",
	["abc_1"] = "abc",
	["abc_key_64"] = "abc",
	["abc_key_60"] = "abc",
	["abc_key_56"] = "abc",
	["abc_key_48"] = "abc",
	["abc_key_44"] = "abc",
	["abc_key_40"] = "abc",
	["abc_key_36"] = "abc",
	["abc_key_32"] = "abc",
	["abc_key_16"] = "abc",
	["abc_key_8"] = "abc",
	["abc_key_4"] = "abc",
	["abc_key_2"] = "abc",
	["abc_key_1"] = "abc",
	[""] = "",
	["empty_key"] = "",
	["alphabet_448"] = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
	["alphabet_448_key"] = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
	["alphabet_896"] = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",
	["alphabet_896_key"] = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",
	["foo"] = "foo",
	["foo_key"] = "foo",
	["bar"] = "bar",
	["bar_key"] = "bar",
	["baz"] = "baz",
	["baz_key"] = "baz",
	["fitness_gram"] = "The Fitness-Gram Pacer Test is a multi-stage aerobic capacity test",
	["fitness_gram_key"] = "The Fitness-Gram Pacer Test is a multi-stage aerobic capacity test",
	["block_size"] = string.rep("!", 128),
	["block_size_key"] = string.rep("!", 128),
	["199999_e"] = string.rep("e", 199999),
	["199999_e_key"] = string.rep("e", 199999),
	["million_a"] = string.rep("a", 1e6),
	["million_a_key"] = string.rep("a", 1e6),
}

Testing.Describe("Blake2b Hashing Algorithm Tests", function()
	for TestKey, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local TestString = TestData[TestKey]
			local MessageBuffer = buffer.fromstring(TestString)
			local KeyBuffer = if Info.Key then buffer.fromstring(Info.Key) else nil
			local Result = Algorithm(MessageBuffer, Info.OutLen, KeyBuffer)

			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{E156985D-BCDB-4ADB-99E8-2E70C289D522}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Blake2b</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX82C390B8D0394701B2A64026794AC2DF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
local Algorithm = require("../Hashing/Blake3")

local New = {
	Key = "whats the Elvish word for friend",
	ContextString = "BLAKE3 2019-12-27 16:29:52 test vectors context",
	Cases = {
		{
			InputLen = 0,
			Hash = "af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262e00f03e7b69af26b7faaf09fcd333050338ddfe085b8cc869ca98b206c08243a26f5487789e8f660afe6c99ef9e0c52b92e7393024a80459cf91f476f9ffdbda7001c22e159b402631f277ca96f2defdf1078282314e763699a31c5363165421cce14d",
			KeyedHash = "92b2b75604ed3c761f9d6f62392c8a9227ad0ea3f09573e783f1498a4ed60d26b18171a2f22a4b94822c701f107153dba24918c4bae4d2945c20ece13387627d3b73cbf97b797d5e59948c7ef788f54372df45e45e4293c7dc18c1d41144a9758be58960856be1eabbe22c2653190de560ca3b2ac4aa692a9210694254c371e851bc8f",
			DeriveKey = "2cc39783c223154fea8dfb7c1b1660f2ac2dcbd1c1de8277b0b0dd39b7e50d7d905630c8be290dfcf3e6842f13bddd573c098c3f17361f1f206b8cad9d088aa4a3f746752c6b0ce6a83b0da81d59649257cdf8eb3e9f7d4998e41021fac119deefb896224ac99f860011f73609e6e0e4540f93b273e56547dfd3aa1a035ba6689d89a0"
		},
		{
			InputLen = 1,
			Hash = "2d3adedff11b61f14c886e35afa036736dcd87a74d27b5c1510225d0f592e213c3a6cb8bf623e20cdb535f8d1a5ffb86342d9c0b64aca3bce1d31f60adfa137b358ad4d79f97b47c3d5e79f179df87a3b9776ef8325f8329886ba42f07fb138bb502f4081cbcec3195c5871e6c23e2cc97d3c69a613eba131e5f1351f3f1da786545e5",
			KeyedHash = "6d7878dfff2f485635d39013278ae14f1454b8c0a3a2d34bc1ab38228a80c95b6568c0490609413006fbd428eb3fd14e7756d90f73a4725fad147f7bf70fd61c4e0cf7074885e92b0e3f125978b4154986d4fb202a3f331a3fb6cf349a3a70e49990f98fe4289761c8602c4e6ab1138d31d3b62218078b2f3ba9a88e1d08d0dd4cea11",
			DeriveKey = "b3e2e340a117a499c6cf2398a19ee0d29cca2bb7404c73063382693bf66cb06c5827b91bf889b6b97c5477f535361caefca0b5d8c4746441c57617111933158950670f9aa8a05d791daae10ac683cbef8faf897c84e6114a59d2173c3f417023a35d6983f2c7dfa57e7fc559ad751dbfb9ffab39c2ef8c4aafebc9ae973a64f0c76551"
		},
		{
			InputLen = 2,
			Hash = "7b7015bb92cf0b318037702a6cdd81dee41224f734684c2c122cd6359cb1ee63d8386b22e2ddc05836b7c1bb693d92af006deb5ffbc4c70fb44d0195d0c6f252faac61659ef86523aa16517f87cb5f1340e723756ab65efb2f91964e14391de2a432263a6faf1d146937b35a33621c12d00be8223a7f1919cec0acd12097ff3ab00ab1",
			KeyedHash = "5392ddae0e0a69d5f40160462cbd9bd889375082ff224ac9c758802b7a6fd20a9ffbf7efd13e989a6c246f96d3a96b9d279f2c4e63fb0bdff633957acf50ee1a5f658be144bab0f6f16500dee4aa5967fc2c586d85a04caddec90fffb7633f46a60786024353b9e5cebe277fcd9514217fee2267dcda8f7b31697b7c54fab6a939bf8f",
			DeriveKey = "1f166565a7df0098ee65922d7fea425fb18b9943f19d6161e2d17939356168e6daa59cae19892b2d54f6fc9f475d26031fd1c22ae0a3e8ef7bdb23f452a15e0027629d2e867b1bb1e6ab21c71297377750826c404dfccc2406bd57a83775f89e0b075e59a7732326715ef912078e213944f490ad68037557518b79c0086de6d6f6cdd2"
		},
		{
			InputLen = 3,
			Hash = "e1be4d7a8ab5560aa4199eea339849ba8e293d55ca0a81006726d184519e647f5b49b82f805a538c68915c1ae8035c900fd1d4b13902920fd05e1450822f36de9454b7e9996de4900c8e723512883f93f4345f8a58bfe64ee38d3ad71ab027765d25cdd0e448328a8e7a683b9a6af8b0af94fa09010d9186890b096a08471e4230a134",
			KeyedHash = "39e67b76b5a007d4921969779fe666da67b5213b096084ab674742f0d5ec62b9b9142d0fab08e1b161efdbb28d18afc64d8f72160c958e53a950cdecf91c1a1bbab1a9c0f01def762a77e2e8545d4dec241e98a89b6db2e9a5b070fc110caae2622690bd7b76c02ab60750a3ea75426a6bb8803c370ffe465f07fb57def95df772c39f",
			DeriveKey = "440aba35cb006b61fc17c0529255de438efc06a8c9ebf3f2ddac3b5a86705797f27e2e914574f4d87ec04c379e12789eccbfbc15892626042707802dbe4e97c3ff59dca80c1e54246b6d055154f7348a39b7d098b2b4824ebe90e104e763b2a447512132cede16243484a55a4e40a85790038bb0dcf762e8c053cabae41bbe22a5bff7"
		},
		{
			InputLen = 4,
			Hash = "f30f5ab28fe047904037f77b6da4fea1e27241c5d132638d8bedce9d40494f328f603ba4564453e06cdcee6cbe728a4519bbe6f0d41e8a14b5b225174a566dbfa61b56afb1e452dc08c804f8c3143c9e2cc4a31bb738bf8c1917b55830c6e65797211701dc0b98daa1faeaa6ee9e56ab606ce03a1a881e8f14e87a4acf4646272cfd12",
			KeyedHash = "7671dde590c95d5ac9616651ff5aa0a27bee5913a348e053b8aa9108917fe070116c0acff3f0d1fa97ab38d813fd46506089118147d83393019b068a55d646251ecf81105f798d76a10ae413f3d925787d6216a7eb444e510fd56916f1d753a5544ecf0072134a146b2615b42f50c179f56b8fae0788008e3e27c67482349e249cb86a",
			DeriveKey = "f46085c8190d69022369ce1a18880e9b369c135eb93f3c63550d3e7630e91060fbd7d8f4258bec9da4e05044f88b91944f7cab317a2f0c18279629a3867fad0662c9ad4d42c6f27e5b124da17c8c4f3a94a025ba5d1b623686c6099d202a7317a82e3d95dae46a87de0555d727a5df55de44dab799a20dffe239594d6e99ed17950910"
		},
		{
			InputLen = 5,
			Hash = "b40b44dfd97e7a84a996a91af8b85188c66c126940ba7aad2e7ae6b385402aa2ebcfdac6c5d32c31209e1f81a454751280db64942ce395104e1e4eaca62607de1c2ca748251754ea5bbe8c20150e7f47efd57012c63b3c6a6632dc1c7cd15f3e1c999904037d60fac2eb9397f2adbe458d7f264e64f1e73aa927b30988e2aed2f03620",
			KeyedHash = "73ac69eecf286894d8102018a6fc729f4b1f4247d3703f69bdc6a5fe3e0c84616ab199d1f2f3e53bffb17f0a2209fe8b4f7d4c7bae59c2bc7d01f1ff94c67588cc6b38fa6024886f2c078bfe09b5d9e6584cd6c521c3bb52f4de7687b37117a2dbbec0d59e92fa9a8cc3240d4432f91757aabcae03e87431dac003e7d73574bfdd8218",
			DeriveKey = "1f24eda69dbcb752847ec3ebb5dd42836d86e58500c7c98d906ecd82ed9ae47f6f48a3f67e4e43329c9a89b1ca526b9b35cbf7d25c1e353baffb590fd79be58ddb6c711f1a6b60e98620b851c688670412fcb0435657ba6b638d21f0f2a04f2f6b0bd8834837b10e438d5f4c7c2c71299cf7586ea9144ed09253d51f8f54dd6bff719d"
		},
		{
			InputLen = 6,
			Hash = "06c4e8ffb6872fad96f9aaca5eee1553eb62aed0ad7198cef42e87f6a616c844611a30c4e4f37fe2fe23c0883cde5cf7059d88b657c7ed2087e3d210925ede716435d6d5d82597a1e52b9553919e804f5656278bd739880692c94bff2824d8e0b48cac1d24682699e4883389dc4f2faa2eb3b4db6e39debd5061ff3609916f3e07529a",
			KeyedHash = "82d3199d0013035682cc7f2a399d4c212544376a839aa863a0f4c91220ca7a6dc2ffb3aa05f2631f0fa9ac19b6e97eb7e6669e5ec254799350c8b8d189e8807800842a5383c4d907c932f34490aaf00064de8cdb157357bde37c1504d2960034930887603abc5ccb9f5247f79224baff6120a3c622a46d7b1bcaee02c5025460941256",
			DeriveKey = "be96b30b37919fe4379dfbe752ae77b4f7e2ab92f7ff27435f76f2f065f6a5f435ae01a1d14bd5a6b3b69d8cbd35f0b01ef2173ff6f9b640ca0bd4748efa398bf9a9c0acd6a66d9332fdc9b47ffe28ba7ab6090c26747b85f4fab22f936b71eb3f64613d8bd9dfabe9bb68da19de78321b481e5297df9e40ec8a3d662f3e1479c65de0"
		},
		{
			InputLen = 7,
			Hash = "3f8770f387faad08faa9d8414e9f449ac68e6ff0417f673f602a646a891419fe66036ef6e6d1a8f54baa9fed1fc11c77cfb9cff65bae915045027046ebe0c01bf5a941f3bb0f73791d3fc0b84370f9f30af0cd5b0fc334dd61f70feb60dad785f070fef1f343ed933b49a5ca0d16a503f599a365a4296739248b28d1a20b0e2cc8975c",
			KeyedHash = "af0a7ec382aedc0cfd626e49e7628bc7a353a4cb108855541a5651bf64fbb28a7c5035ba0f48a9c73dabb2be0533d02e8fd5d0d5639a18b2803ba6bf527e1d145d5fd6406c437b79bcaad6c7bdf1cf4bd56a893c3eb9510335a7a798548c6753f74617bede88bef924ba4b334f8852476d90b26c5dc4c3668a2519266a562c6c8034a6",
			DeriveKey = "dc3b6485f9d94935329442916b0d059685ba815a1fa2a14107217453a7fc9f0e66266db2ea7c96843f9d8208e600a73f7f45b2f55b9e6d6a7ccf05daae63a3fdd10b25ac0bd2e224ce8291f88c05976d575df998477db86fb2cfbbf91725d62cb57acfeb3c2d973b89b503c2b60dde85a7802b69dc1ac2007d5623cbea8cbfb6b181f5"
		},
		{
			InputLen = 8,
			Hash = "2351207d04fc16ade43ccab08600939c7c1fa70a5c0aaca76063d04c3228eaeb725d6d46ceed8f785ab9f2f9b06acfe398c6699c6129da084cb531177445a682894f9685eaf836999221d17c9a64a3a057000524cd2823986db378b074290a1a9b93a22e135ed2c14c7e20c6d045cd00b903400374126676ea78874d79f2dd7883cf5c",
			KeyedHash = "be2f5495c61cba1bb348a34948c004045e3bd4dae8f0fe82bf44d0da245a060048eb5e68ce6dea1eb0229e144f578b3aa7e9f4f85febd135df8525e6fe40c6f0340d13dd09b255ccd5112a94238f2be3c0b5b7ecde06580426a93e0708555a265305abf86d874e34b4995b788e37a823491f25127a502fe0704baa6bfdf04e76c13276",
			DeriveKey = "2b166978cef14d9d438046c720519d8b1cad707e199746f1562d0c87fbd32940f0e2545a96693a66654225ebbaac76d093bfa9cd8f525a53acb92a861a98c42e7d1c4ae82e68ab691d510012edd2a728f98cd4794ef757e94d6546961b4f280a51aac339cc95b64a92b83cc3f26d8af8dfb4c091c240acdb4d47728d23e7148720ef04"
		},
		{
			InputLen = 63,
			Hash = "e9bc37a594daad83be9470df7f7b3798297c3d834ce80ba85d6e207627b7db7b1197012b1e7d9af4d7cb7bdd1f3bb49a90a9b5dec3ea2bbc6eaebce77f4e470cbf4687093b5352f04e4a4570fba233164e6acc36900e35d185886a827f7ea9bdc1e5c3ce88b095a200e62c10c043b3e9bc6cb9b6ac4dfa51794b02ace9f98779040755",
			KeyedHash = "bb1eb5d4afa793c1ebdd9fb08def6c36d10096986ae0cfe148cd101170ce37aea05a63d74a840aecd514f654f080e51ac50fd617d22610d91780fe6b07a26b0847abb38291058c97474ef6ddd190d30fc318185c09ca1589d2024f0a6f16d45f11678377483fa5c005b2a107cb9943e5da634e7046855eaa888663de55d6471371d55d",
			DeriveKey = "b6451e30b953c206e34644c6803724e9d2725e0893039cfc49584f991f451af3b89e8ff572d3da4f4022199b9563b9d70ebb616efff0763e9abec71b550f1371e233319c4c4e74da936ba8e5bbb29a598e007a0bbfa929c99738ca2cc098d59134d11ff300c39f82e2fce9f7f0fa266459503f64ab9913befc65fddc474f6dc1c67669"
		},
		{
			InputLen = 64,
			Hash = "4eed7141ea4a5cd4b788606bd23f46e212af9cacebacdc7d1f4c6dc7f2511b98fc9cc56cb831ffe33ea8e7e1d1df09b26efd2767670066aa82d023b1dfe8ab1b2b7fbb5b97592d46ffe3e05a6a9b592e2949c74160e4674301bc3f97e04903f8c6cf95b863174c33228924cdef7ae47559b10b294acd660666c4538833582b43f82d74",
			KeyedHash = "ba8ced36f327700d213f120b1a207a3b8c04330528586f414d09f2f7d9ccb7e68244c26010afc3f762615bbac552a1ca909e67c83e2fd5478cf46b9e811efccc93f77a21b17a152ebaca1695733fdb086e23cd0eb48c41c034d52523fc21236e5d8c9255306e48d52ba40b4dac24256460d56573d1312319afcf3ed39d72d0bfc69acb",
			DeriveKey = "a5c4a7053fa86b64746d4bb688d06ad1f02a18fce9afd3e818fefaa7126bf73e9b9493a9befebe0bf0c9509fb3105cfa0e262cde141aa8e3f2c2f77890bb64a4cca96922a21ead111f6338ad5244f2c15c44cb595443ac2ac294231e31be4a4307d0a91e874d36fc9852aeb1265c09b6e0cda7c37ef686fbbcab97e8ff66718be048bb"
		},
		{
			InputLen = 65,
			Hash = "de1e5fa0be70df6d2be8fffd0e99ceaa8eb6e8c93a63f2d8d1c30ecb6b263dee0e16e0a4749d6811dd1d6d1265c29729b1b75a9ac346cf93f0e1d7296dfcfd4313b3a227faaaaf7757cc95b4e87a49be3b8a270a12020233509b1c3632b3485eef309d0abc4a4a696c9decc6e90454b53b000f456a3f10079072baaf7a981653221f2c",
			KeyedHash = "c0a4edefa2d2accb9277c371ac12fcdbb52988a86edc54f0716e1591b4326e72d5e795f46a596b02d3d4bfb43abad1e5d19211152722ec1f20fef2cd413e3c22f2fc5da3d73041275be6ede3517b3b9f0fc67ade5956a672b8b75d96cb43294b9041497de92637ed3f2439225e683910cb3ae923374449ca788fb0f9bea92731bc26ad",
			DeriveKey = "51fd05c3c1cfbc8ed67d139ad76f5cf8236cd2acd26627a30c104dfd9d3ff8a82b02e8bd36d8498a75ad8c8e9b15eb386970283d6dd42c8ae7911cc592887fdbe26a0a5f0bf821cd92986c60b2502c9be3f98a9c133a7e8045ea867e0828c7252e739321f7c2d65daee4468eb4429efae469a42763f1f94977435d10dccae3e3dce88d"
		},
		{
			InputLen = 127,
			Hash = "d81293fda863f008c09e92fc382a81f5a0b4a1251cba1634016a0f86a6bd640de3137d477156d1fde56b0cf36f8ef18b44b2d79897bece12227539ac9ae0a5119da47644d934d26e74dc316145dcb8bb69ac3f2e05c242dd6ee06484fcb0e956dc44355b452c5e2bbb5e2b66e99f5dd443d0cbcaaafd4beebaed24ae2f8bb672bcef78",
			KeyedHash = "c64200ae7dfaf35577ac5a9521c47863fb71514a3bcad18819218b818de85818ee7a317aaccc1458f78d6f65f3427ec97d9c0adb0d6dacd4471374b621b7b5f35cd54663c64dbe0b9e2d95632f84c611313ea5bd90b71ce97b3cf645776f3adc11e27d135cbadb9875c2bf8d3ae6b02f8a0206aba0c35bfe42574011931c9a255ce6dc",
			DeriveKey = "c91c090ceee3a3ac81902da31838012625bbcd73fcb92e7d7e56f78deba4f0c3feeb3974306966ccb3e3c69c337ef8a45660ad02526306fd685c88542ad00f759af6dd1adc2e50c2b8aac9f0c5221ff481565cf6455b772515a69463223202e5c371743e35210bbbbabd89651684107fd9fe493c937be16e39cfa7084a36207c99bea3"
		},
		{
			InputLen = 128,
			Hash = "f17e570564b26578c33bb7f44643f539624b05df1a76c81f30acd548c44b45efa69faba091427f9c5c4caa873aa07828651f19c55bad85c47d1368b11c6fd99e47ecba5820a0325984d74fe3e4058494ca12e3f1d3293d0010a9722f7dee64f71246f75e9361f44cc8e214a100650db1313ff76a9f93ec6e84edb7add1cb4a95019b0c",
			KeyedHash = "b04fe15577457267ff3b6f3c947d93be581e7e3a4b018679125eaf86f6a628ecd86bbe0001f10bda47e6077b735016fca8119da11348d93ca302bbd125bde0db2b50edbe728a620bb9d3e6f706286aedea973425c0b9eedf8a38873544cf91badf49ad92a635a93f71ddfcee1eae536c25d1b270956be16588ef1cfef2f1d15f650bd5",
			DeriveKey = "81720f34452f58a0120a58b6b4608384b5c51d11f39ce97161a0c0e442ca022550e7cd651e312f0b4c6afb3c348ae5dd17d2b29fab3b894d9a0034c7b04fd9190cbd90043ff65d1657bbc05bfdecf2897dd894c7a1b54656d59a50b51190a9da44db426266ad6ce7c173a8c0bbe091b75e734b4dadb59b2861cd2518b4e7591e4b83c9"
		},
		{
			InputLen = 129,
			Hash = "683aaae9f3c5ba37eaaf072aed0f9e30bac0865137bae68b1fde4ca2aebdcb12f96ffa7b36dd78ba321be7e842d364a62a42e3746681c8bace18a4a8a79649285c7127bf8febf125be9de39586d251f0d41da20980b70d35e3dac0eee59e468a894fa7e6a07129aaad09855f6ad4801512a116ba2b7841e6cfc99ad77594a8f2d181a7",
			KeyedHash = "d4a64dae6cdccbac1e5287f54f17c5f985105457c1a2ec1878ebd4b57e20d38f1c9db018541eec241b748f87725665b7b1ace3e0065b29c3bcb232c90e37897fa5aaee7e1e8a2ecfcd9b51463e42238cfdd7fee1aecb3267fa7f2128079176132a412cd8aaf0791276f6b98ff67359bd8652ef3a203976d5ff1cd41885573487bcd683",
			DeriveKey = "938d2d4435be30eafdbb2b7031f7857c98b04881227391dc40db3c7b21f41fc18d72d0f9c1de5760e1941aebf3100b51d64644cb459eb5d20258e233892805eb98b07570ef2a1787cd48e117c8d6a63a68fd8fc8e59e79dbe63129e88352865721c8d5f0cf183f85e0609860472b0d6087cefdd186d984b21542c1c780684ed6832d8d"
		},
		{
			InputLen = 1023,
			Hash = "10108970eeda3eb932baac1428c7a2163b0e924c9a9e25b35bba72b28f70bd11a182d27a591b05592b15607500e1e8dd56bc6c7fc063715b7a1d737df5bad3339c56778957d870eb9717b57ea3d9fb68d1b55127bba6a906a4a24bbd5acb2d123a37b28f9e9a81bbaae360d58f85e5fc9d75f7c370a0cc09b6522d9c8d822f2f28f485",
			KeyedHash = "c951ecdf03288d0fcc96ee3413563d8a6d3589547f2c2fb36d9786470f1b9d6e890316d2e6d8b8c25b0a5b2180f94fb1a158ef508c3cde45e2966bd796a696d3e13efd86259d756387d9becf5c8bf1ce2192b87025152907b6d8cc33d17826d8b7b9bc97e38c3c85108ef09f013e01c229c20a83d9e8efac5b37470da28575fd755a10",
			DeriveKey = "74a16c1c3d44368a86e1ca6df64be6a2f64cce8f09220787450722d85725dea59c413264404661e9e4d955409dfe4ad3aa487871bcd454ed12abfe2c2b1eb7757588cf6cb18d2eccad49e018c0d0fec323bec82bf1644c6325717d13ea712e6840d3e6e730d35553f59eff5377a9c350bcc1556694b924b858f329c44ee64b884ef00d"
		},
		{
			InputLen = 1024,
			Hash = "42214739f095a406f3fc83deb889744ac00df831c10daa55189b5d121c855af71cf8107265ecdaf8505b95d8fcec83a98a6a96ea5109d2c179c47a387ffbb404756f6eeae7883b446b70ebb144527c2075ab8ab204c0086bb22b7c93d465efc57f8d917f0b385c6df265e77003b85102967486ed57db5c5ca170ba441427ed9afa684e",
			KeyedHash = "75c46f6f3d9eb4f55ecaaee480db732e6c2105546f1e675003687c31719c7ba4a78bc838c72852d4f49c864acb7adafe2478e824afe51c8919d06168414c265f298a8094b1ad813a9b8614acabac321f24ce61c5a5346eb519520d38ecc43e89b5000236df0597243e4d2493fd626730e2ba17ac4d8824d09d1a4a8f57b8227778e2de",
			DeriveKey = "7356cd7720d5b66b6d0697eb3177d9f8d73a4a5c5e968896eb6a6896843027066c23b601d3ddfb391e90d5c8eccdef4ae2a264bce9e612ba15e2bc9d654af1481b2e75dbabe615974f1070bba84d56853265a34330b4766f8e75edd1f4a1650476c10802f22b64bd3919d246ba20a17558bc51c199efdec67e80a227251808d8ce5bad"
		},
		{
			InputLen = 1025,
			Hash = "d00278ae47eb27b34faecf67b4fe263f82d5412916c1ffd97c8cb7fb814b8444f4c4a22b4b399155358a994e52bf255de60035742ec71bd08ac275a1b51cc6bfe332b0ef84b409108cda080e6269ed4b3e2c3f7d722aa4cdc98d16deb554e5627be8f955c98e1d5f9565a9194cad0c4285f93700062d9595adb992ae68ff12800ab67a",
			KeyedHash = "357dc55de0c7e382c900fd6e320acc04146be01db6a8ce7210b7189bd664ea69362396b77fdc0d2634a552970843722066c3c15902ae5097e00ff53f1e116f1cd5352720113a837ab2452cafbde4d54085d9cf5d21ca613071551b25d52e69d6c81123872b6f19cd3bc1333edf0c52b94de23ba772cf82636cff4542540a7738d5b930",
			DeriveKey = "effaa245f065fbf82ac186839a249707c3bddf6d3fdda22d1b95a3c970379bcb5d31013a167509e9066273ab6e2123bc835b408b067d88f96addb550d96b6852dad38e320b9d940f86db74d398c770f462118b35d2724efa13da97194491d96dd37c3c09cbef665953f2ee85ec83d88b88d11547a6f911c8217cca46defa2751e7f3ad"
		},
		{
			InputLen = 2048,
			Hash = "e776b6028c7cd22a4d0ba182a8bf62205d2ef576467e838ed6f2529b85fba24a9a60bf80001410ec9eea6698cd537939fad4749edd484cb541aced55cd9bf54764d063f23f6f1e32e12958ba5cfeb1bf618ad094266d4fc3c968c2088f677454c288c67ba0dba337b9d91c7e1ba586dc9a5bc2d5e90c14f53a8863ac75655461cea8f9",
			KeyedHash = "879cf1fa2ea0e79126cb1063617a05b6ad9d0b696d0d757cf053439f60a99dd10173b961cd574288194b23ece278c330fbb8585485e74967f31352a8183aa782b2b22f26cdcadb61eed1a5bc144b8198fbb0c13abbf8e3192c145d0a5c21633b0ef86054f42809df823389ee40811a5910dcbd1018af31c3b43aa55201ed4edaac74fe",
			DeriveKey = "7b2945cb4fef70885cc5d78a87bf6f6207dd901ff239201351ffac04e1088a23e2c11a1ebffcea4d80447867b61badb1383d842d4e79645d48dd82ccba290769caa7af8eaa1bd78a2a5e6e94fbdab78d9c7b74e894879f6a515257ccf6f95056f4e25390f24f6b35ffbb74b766202569b1d797f2d4bd9d17524c720107f985f4ddc583"
		},
		{
			InputLen = 2049,
			Hash = "5f4d72f40d7a5f82b15ca2b2e44b1de3c2ef86c426c95c1af0b687952256303096de31d71d74103403822a2e0bc1eb193e7aecc9643a76b7bbc0c9f9c52e8783aae98764ca468962b5c2ec92f0c74eb5448d519713e09413719431c802f948dd5d90425a4ecdadece9eb178d80f26efccae630734dff63340285adec2aed3b51073ad3",
			KeyedHash = "9f29700902f7c86e514ddc4df1e3049f258b2472b6dd5267f61bf13983b78dd5f9a88abfefdfa1e00b418971f2b39c64ca621e8eb37fceac57fd0c8fc8e117d43b81447be22d5d8186f8f5919ba6bcc6846bd7d50726c06d245672c2ad4f61702c646499ee1173daa061ffe15bf45a631e2946d616a4c345822f1151284712f76b2b0e",
			DeriveKey = "2ea477c5515cc3dd606512ee72bb3e0e758cfae7232826f35fb98ca1bcbdf27316d8e9e79081a80b046b60f6a263616f33ca464bd78d79fa18200d06c7fc9bffd808cc4755277a7d5e09da0f29ed150f6537ea9bed946227ff184cc66a72a5f8c1e4bd8b04e81cf40fe6dc4427ad5678311a61f4ffc39d195589bdbc670f63ae70f4b6"
		},
		{
			InputLen = 3072,
			Hash = "b98cb0ff3623be03326b373de6b9095218513e64f1ee2edd2525c7ad1e5cffd29a3f6b0b978d6608335c09dc94ccf682f9951cdfc501bfe47b9c9189a6fc7b404d120258506341a6d802857322fbd20d3e5dae05b95c88793fa83db1cb08e7d8008d1599b6209d78336e24839724c191b2a52a80448306e0daa84a3fdb566661a37e11",
			KeyedHash = "044a0e7b172a312dc02a4c9a818c036ffa2776368d7f528268d2e6b5df19177022f302d0529e4174cc507c463671217975e81dab02b8fdeb0d7ccc7568dd22574c783a76be215441b32e91b9a904be8ea81f7a0afd14bad8ee7c8efc305ace5d3dd61b996febe8da4f56ca0919359a7533216e2999fc87ff7d8f176fbecb3d6f34278b",
			DeriveKey = "050df97f8c2ead654d9bb3ab8c9178edcd902a32f8495949feadcc1e0480c46b3604131bbd6e3ba573b6dd682fa0a63e5b165d39fc43a625d00207607a2bfeb65ff1d29292152e26b298868e3b87be95d6458f6f2ce6118437b632415abe6ad522874bcd79e4030a5e7bad2efa90a7a7c67e93f0a18fb28369d0a9329ab5c24134ccb0"
		},
		{
			InputLen = 3073,
			Hash = "7124b49501012f81cc7f11ca069ec9226cecb8a2c850cfe644e327d22d3e1cd39a27ae3b79d68d89da9bf25bc27139ae65a324918a5f9b7828181e52cf373c84f35b639b7fccbb985b6f2fa56aea0c18f531203497b8bbd3a07ceb5926f1cab74d14bd66486d9a91eba99059a98bd1cd25876b2af5a76c3e9eed554ed72ea952b603bf",
			KeyedHash = "68dede9bef00ba89e43f31a6825f4cf433389fedae75c04ee9f0cf16a427c95a96d6da3fe985054d3478865be9a092250839a697bbda74e279e8a9e69f0025e4cfddd6cfb434b1cd9543aaf97c635d1b451a4386041e4bb100f5e45407cbbc24fa53ea2de3536ccb329e4eb9466ec37093a42cf62b82903c696a93a50b702c80f3c3c5",
			DeriveKey = "72613c9ec9ff7e40f8f5c173784c532ad852e827dba2bf85b2ab4b76f7079081576288e552647a9d86481c2cae75c2dd4e7c5195fb9ada1ef50e9c5098c249d743929191441301c69e1f48505a4305ec1778450ee48b8e69dc23a25960fe33070ea549119599760a8a2d28aeca06b8c5e9ba58bc19e11fe57b6ee98aa44b2a8e6b14a5"
		},
		{
			InputLen = 4096,
			Hash = "015094013f57a5277b59d8475c0501042c0b642e531b0a1c8f58d2163229e9690289e9409ddb1b99768eafe1623da896faf7e1114bebeadc1be30829b6f8af707d85c298f4f0ff4d9438aef948335612ae921e76d411c3a9111df62d27eaf871959ae0062b5492a0feb98ef3ed4af277f5395172dbe5c311918ea0074ce0036454f620",
			KeyedHash = "befc660aea2f1718884cd8deb9902811d332f4fc4a38cf7c7300d597a081bfc0bbb64a36edb564e01e4b4aaf3b060092a6b838bea44afebd2deb8298fa562b7b597c757b9df4c911c3ca462e2ac89e9a787357aaf74c3b56d5c07bc93ce899568a3eb17d9250c20f6c5f6c1e792ec9a2dcb715398d5a6ec6d5c54f586a00403a1af1de",
			DeriveKey = "1e0d7f3db8c414c97c6307cbda6cd27ac3b030949da8e23be1a1a924ad2f25b9d78038f7b198596c6cc4a9ccf93223c08722d684f240ff6569075ed81591fd93f9fff1110b3a75bc67e426012e5588959cc5a4c192173a03c00731cf84544f65a2fb9378989f72e9694a6a394a8a30997c2e67f95a504e631cd2c5f55246024761b245"
		},
		{
			InputLen = 4097,
			Hash = "9b4052b38f1c5fc8b1f9ff7ac7b27cd242487b3d890d15c96a1c25b8aa0fb99505f91b0b5600a11251652eacfa9497b31cd3c409ce2e45cfe6c0a016967316c426bd26f619eab5d70af9a418b845c608840390f361630bd497b1ab44019316357c61dbe091ce72fc16dc340ac3d6e009e050b3adac4b5b2c92e722cffdc46501531956",
			KeyedHash = "00df940cd36bb9fa7cbbc3556744e0dbc8191401afe70520ba292ee3ca80abbc606db4976cfdd266ae0abf667d9481831ff12e0caa268e7d3e57260c0824115a54ce595ccc897786d9dcbf495599cfd90157186a46ec800a6763f1c59e36197e9939e900809f7077c102f888caaf864b253bc41eea812656d46742e4ea42769f89b83f",
			DeriveKey = "aca51029626b55fda7117b42a7c211f8c6e9ba4fe5b7a8ca922f34299500ead8a897f66a400fed9198fd61dd2d58d382458e64e100128075fc54b860934e8de2e84170734b06e1d212a117100820dbc48292d148afa50567b8b84b1ec336ae10d40c8c975a624996e12de31abbe135d9d159375739c333798a80c64ae895e51e22f3ad"
		},
		{
			InputLen = 5120,
			Hash = "9cadc15fed8b5d854562b26a9536d9707cadeda9b143978f319ab34230535833acc61c8fdc114a2010ce8038c853e121e1544985133fccdd0a2d507e8e615e611e9a0ba4f47915f49e53d721816a9198e8b30f12d20ec3689989175f1bf7a300eee0d9321fad8da232ece6efb8e9fd81b42ad161f6b9550a069e66b11b40487a5f5059",
			KeyedHash = "2c493e48e9b9bf31e0553a22b23503c0a3388f035cece68eb438d22fa1943e209b4dc9209cd80ce7c1f7c9a744658e7e288465717ae6e56d5463d4f80cdb2ef56495f6a4f5487f69749af0c34c2cdfa857f3056bf8d807336a14d7b89bf62bef2fb54f9af6a546f818dc1e98b9e07f8a5834da50fa28fb5874af91bf06020d1bf0120e",
			DeriveKey = "7a7acac8a02adcf3038d74cdd1d34527de8a0fcc0ee3399d1262397ce5817f6055d0cefd84d9d57fe792d65a278fd20384ac6c30fdb340092f1a74a92ace99c482b28f0fc0ef3b923e56ade20c6dba47e49227166251337d80a037e987ad3a7f728b5ab6dfafd6e2ab1bd583a95d9c895ba9c2422c24ea0f62961f0dca45cad47bfa0d"
		},
		{
			InputLen = 5121,
			Hash = "628bd2cb2004694adaab7bbd778a25df25c47b9d4155a55f8fbd79f2fe154cff96adaab0613a6146cdaabe498c3a94e529d3fc1da2bd08edf54ed64d40dcd6777647eac51d8277d70219a9694334a68bc8f0f23e20b0ff70ada6f844542dfa32cd4204ca1846ef76d811cdb296f65e260227f477aa7aa008bac878f72257484f2b6c95",
			KeyedHash = "6ccf1c34753e7a044db80798ecd0782a8f76f33563accaddbfbb2e0ea4b2d0240d07e63f13667a8d1490e5e04f13eb617aea16a8c8a5aaed1ef6fbde1b0515e3c81050b361af6ead126032998290b563e3caddeaebfab592e155f2e161fb7cba939092133f23f9e65245e58ec23457b78a2e8a125588aad6e07d7f11a85b88d375b72d",
			DeriveKey = "b07f01e518e702f7ccb44a267e9e112d403a7b3f4883a47ffbed4b48339b3c341a0add0ac032ab5aaea1e4e5b004707ec5681ae0fcbe3796974c0b1cf31a194740c14519273eedaabec832e8a784b6e7cfc2c5952677e6c3f2c3914454082d7eb1ce1766ac7d75a4d3001fc89544dd46b5147382240d689bbbaefc359fb6ae30263165"
		},
		{
			InputLen = 6144,
			Hash = "3e2e5b74e048f3add6d21faab3f83aa44d3b2278afb83b80b3c35164ebeca2054d742022da6fdda444ebc384b04a54c3ac5839b49da7d39f6d8a9db03deab32aade156c1c0311e9b3435cde0ddba0dce7b26a376cad121294b689193508dd63151603c6ddb866ad16c2ee41585d1633a2cea093bea714f4c5d6b903522045b20395c83",
			KeyedHash = "3d6b6d21281d0ade5b2b016ae4034c5dec10ca7e475f90f76eac7138e9bc8f1dc35754060091dc5caf3efabe0603c60f45e415bb3407db67e6beb3d11cf8e4f7907561f05dace0c15807f4b5f389c841eb114d81a82c02a00b57206b1d11fa6e803486b048a5ce87105a686dee041207e095323dfe172df73deb8c9532066d88f9da7e",
			DeriveKey = "2a95beae63ddce523762355cf4b9c1d8f131465780a391286a5d01abb5683a1597099e3c6488aab6c48f3c15dbe1942d21dbcdc12115d19a8b8465fb54e9053323a9178e4275647f1a9927f6439e52b7031a0b465c861a3fc531527f7758b2b888cf2f20582e9e2c593709c0a44f9c6e0f8b963994882ea4168827823eef1f64169fef"
		},
		{
			InputLen = 6145,
			Hash = "f1323a8631446cc50536a9f705ee5cb619424d46887f3c376c695b70e0f0507f18a2cfdd73c6e39dd75ce7c1c6e3ef238fd54465f053b25d21044ccb2093beb015015532b108313b5829c3621ce324b8e14229091b7c93f32db2e4e63126a377d2a63a3597997d4f1cba59309cb4af240ba70cebff9a23d5e3ff0cdae2cfd54e070022",
			KeyedHash = "9ac301e9e39e45e3250a7e3b3df701aa0fb6889fbd80eeecf28dbc6300fbc539f3c184ca2f59780e27a576c1d1fb9772e99fd17881d02ac7dfd39675aca918453283ed8c3169085ef4a466b91c1649cc341dfdee60e32231fc34c9c4e0b9a2ba87ca8f372589c744c15fd6f985eec15e98136f25beeb4b13c4e43dc84abcc79cd4646c",
			DeriveKey = "379bcc61d0051dd489f686c13de00d5b14c505245103dc040d9e4dd1facab8e5114493d029bdbd295aaa744a59e31f35c7f52dba9c3642f773dd0b4262a9980a2aef811697e1305d37ba9d8b6d850ef07fe41108993180cf779aeece363704c76483458603bbeeb693cffbbe5588d1f3535dcad888893e53d977424bb707201569a8d2"
		},
		{
			InputLen = 7168,
			Hash = "61da957ec2499a95d6b8023e2b0e604ec7f6b50e80a9678b89d2628e99ada77a5707c321c83361793b9af62a40f43b523df1c8633cecb4cd14d00bdc79c78fca5165b863893f6d38b02ff7236c5a9a8ad2dba87d24c547cab046c29fc5bc1ed142e1de4763613bb162a5a538e6ef05ed05199d751f9eb58d332791b8d73fb74e4fce95",
			KeyedHash = "b42835e40e9d4a7f42ad8cc04f85a963a76e18198377ed84adddeaecacc6f3fca2f01d5277d69bb681c70fa8d36094f73ec06e452c80d2ff2257ed82e7ba348400989a65ee8daa7094ae0933e3d2210ac6395c4af24f91c2b590ef87d7788d7066ea3eaebca4c08a4f14b9a27644f99084c3543711b64a070b94f2c9d1d8a90d035d52",
			DeriveKey = "11c37a112765370c94a51415d0d651190c288566e295d505defdad895dae223730d5a5175a38841693020669c7638f40b9bc1f9f39cf98bda7a5b54ae24218a800a2116b34665aa95d846d97ea988bfcb53dd9c055d588fa21ba78996776ea6c40bc428b53c62b5f3ccf200f647a5aae8067f0ea1976391fcc72af1945100e2a6dcb88"
		},
		{
			InputLen = 7169,
			Hash = "a003fc7a51754a9b3c7fae0367ab3d782dccf28855a03d435f8cfe74605e781798a8b20534be1ca9eb2ae2df3fae2ea60e48c6fb0b850b1385b5de0fe460dbe9d9f9b0d8db4435da75c601156df9d047f4ede008732eb17adc05d96180f8a73548522840779e6062d643b79478a6e8dbce68927f36ebf676ffa7d72d5f68f050b119c8",
			KeyedHash = "ed9b1a922c046fdb3d423ae34e143b05ca1bf28b710432857bf738bcedbfa5113c9e28d72fcbfc020814ce3f5d4fc867f01c8f5b6caf305b3ea8a8ba2da3ab69fabcb438f19ff11f5378ad4484d75c478de425fb8e6ee809b54eec9bdb184315dc856617c09f5340451bf42fd3270a7b0b6566169f242e533777604c118a6358250f54",
			DeriveKey = "554b0a5efea9ef183f2f9b931b7497995d9eb26f5c5c6dad2b97d62fc5ac31d99b20652c016d88ba2a611bbd761668d5eda3e568e940faae24b0d9991c3bd25a65f770b89fdcadabcb3d1a9c1cb63e69721cacf1ae69fefdcef1e3ef41bc5312ccc17222199e47a26552c6adc460cf47a72319cb5039369d0060eaea59d6c65130f1dd"
		},
		{
			InputLen = 8192,
			Hash = "aae792484c8efe4f19e2ca7d371d8c467ffb10748d8a5a1ae579948f718a2a635fe51a27db045a567c1ad51be5aa34c01c6651c4d9b5b5ac5d0fd58cf18dd61a47778566b797a8c67df7b1d60b97b19288d2d877bb2df417ace009dcb0241ca1257d62712b6a4043b4ff33f690d849da91ea3bf711ed583cb7b7a7da2839ba71309bbf",
			KeyedHash = "dc9637c8845a770b4cbf76b8daec0eebf7dc2eac11498517f08d44c8fc00d58a4834464159dcbc12a0ba0c6d6eb41bac0ed6585cabfe0aca36a375e6c5480c22afdc40785c170f5a6b8a1107dbee282318d00d915ac9ed1143ad40765ec120042ee121cd2baa36250c618adaf9e27260fda2f94dea8fb6f08c04f8f10c78292aa46102",
			DeriveKey = "ad01d7ae4ad059b0d33baa3c01319dcf8088094d0359e5fd45d6aeaa8b2d0c3d4c9e58958553513b67f84f8eac653aeeb02ae1d5672dcecf91cd9985a0e67f4501910ecba25555395427ccc7241d70dc21c190e2aadee875e5aae6bf1912837e53411dabf7a56cbf8e4fb780432b0d7fe6cec45024a0788cf5874616407757e9e6bef7"
		},
		{
			InputLen = 8193,
			Hash = "bab6c09cb8ce8cf459261398d2e7aef35700bf488116ceb94a36d0f5f1b7bc3bb2282aa69be089359ea1154b9a9286c4a56af4de975a9aa4a5c497654914d279bea60bb6d2cf7225a2fa0ff5ef56bbe4b149f3ed15860f78b4e2ad04e158e375c1e0c0b551cd7dfc82f1b155c11b6b3ed51ec9edb30d133653bb5709d1dbd55f4e1ff6",
			KeyedHash = "954a2a75420c8d6547e3ba5b98d963e6fa6491addc8c023189cc519821b4a1f5f03228648fd983aef045c2fa8290934b0866b615f585149587dda2299039965328835a2b18f1d63b7e300fc76ff260b571839fe44876a4eae66cbac8c67694411ed7e09df51068a22c6e67d6d3dd2cca8ff12e3275384006c80f4db68023f24eebba57",
			DeriveKey = "af1e0346e389b17c23200270a64aa4e1ead98c61695d917de7d5b00491c9b0f12f20a01d6d622edf3de026a4db4e4526225debb93c1237934d71c7340bb5916158cbdafe9ac3225476b6ab57a12357db3abbad7a26c6e66290e44034fb08a20a8d0ec264f309994d2810c49cfba6989d7abb095897459f5425adb48aba07c5fb3c83c0"
		},
		{
			InputLen = 16384,
			Hash = "f875d6646de28985646f34ee13be9a576fd515f76b5b0a26bb324735041ddde49d764c270176e53e97bdffa58d549073f2c660be0e81293767ed4e4929f9ad34bbb39a529334c57c4a381ffd2a6d4bfdbf1482651b172aa883cc13408fa67758a3e47503f93f87720a3177325f7823251b85275f64636a8f1d599c2e49722f42e93893",
			KeyedHash = "9e9fc4eb7cf081ea7c47d1807790ed211bfec56aa25bb7037784c13c4b707b0df9e601b101e4cf63a404dfe50f2e1865bb12edc8fca166579ce0c70dba5a5c0fc960ad6f3772183416a00bd29d4c6e651ea7620bb100c9449858bf14e1ddc9ecd35725581ca5b9160de04060045993d972571c3e8f71e9d0496bfa744656861b169d65",
			DeriveKey = "160e18b5878cd0df1c3af85eb25a0db5344d43a6fbd7a8ef4ed98d0714c3f7e160dc0b1f09caa35f2f417b9ef309dfe5ebd67f4c9507995a531374d099cf8ae317542e885ec6f589378864d3ea98716b3bbb65ef4ab5e0ab5bb298a501f19a41ec19af84a5e6b428ecd813b1a47ed91c9657c3fba11c406bc316768b58f6802c9e9b57"
		},
		{
			InputLen = 31744,
			Hash = "62b6960e1a44bcc1eb1a611a8d6235b6b4b78f32e7abc4fb4c6cdcce94895c47860cc51f2b0c28a7b77304bd55fe73af663c02d3f52ea053ba43431ca5bab7bfea2f5e9d7121770d88f70ae9649ea713087d1914f7f312147e247f87eb2d4ffef0ac978bf7b6579d57d533355aa20b8b77b13fd09748728a5cc327a8ec470f4013226f",
			KeyedHash = "efa53b389ab67c593dba624d898d0f7353ab99e4ac9d42302ee64cbf9939a4193a7258db2d9cd32a7a3ecfce46144114b15c2fcb68a618a976bd74515d47be08b628be420b5e830fade7c080e351a076fbc38641ad80c736c8a18fe3c66ce12f95c61c2462a9770d60d0f77115bbcd3782b593016a4e728d4c06cee4505cb0c08a42ec",
			DeriveKey = "39772aef80e0ebe60596361e45b061e8f417429d529171b6764468c22928e28e9759adeb797a3fbf771b1bcea30150a020e317982bf0d6e7d14dd9f064bc11025c25f31e81bd78a921db0174f03dd481d30e93fd8e90f8b2fee209f849f2d2a52f31719a490fb0ba7aea1e09814ee912eba111a9fde9d5c274185f7bae8ba85d300a2b"
		},
		{
			InputLen = 102400,
			Hash = "bc3e3d41a1146b069abffad3c0d44860cf664390afce4d9661f7902e7943e085e01c59dab908c04c3342b816941a26d69c2605ebee5ec5291cc55e15b76146e6745f0601156c3596cb75065a9c57f35585a52e1ac70f69131c23d611ce11ee4ab1ec2c009012d236648e77be9295dd0426f29b764d65de58eb7d01dd42248204f45f8e",
			KeyedHash = "1c35d1a5811083fd7119f5d5d1ba027b4d01c0c6c49fb6ff2cf75393ea5db4a7f9dbdd3e1d81dcbca3ba241bb18760f207710b751846faaeb9dff8262710999a59b2aa1aca298a032d94eacfadf1aa192418eb54808db23b56e34213266aa08499a16b354f018fc4967d05f8b9d2ad87a7278337be9693fc638a3bfdbe314574ee6fc4",
			DeriveKey = "4652cff7a3f385a6103b5c260fc1593e13c778dbe608efb092fe7ee69df6e9c6d83a3e041bc3a48df2879f4a0a3ed40e7c961c73eff740f3117a0504c2dff4786d44fb17f1549eb0ba585e40ec29bf7732f0b7e286ff8acddc4cb1e23b87ff5d824a986458dcc6a04ac83969b80637562953df51ed1a7e90a7926924d2763778be8560"
		}
	}
}

Testing.Describe("Blake3 Algorithm Tests", function()
	for Index, TestCase in New.Cases do
		local Input = buffer.create(TestCase.InputLen)
		if TestCase.InputLen > 0 then
			for I = 0, TestCase.InputLen - 1 do
				buffer.writeu8(Input, I, I % 251)
			end
		end

		local HashOutputLen = string.len(TestCase.Hash) / 2
		local KeyedHashOutputLen = string.len(TestCase.KeyedHash) / 2
		local DeriveKeyOutputLen = string.len(TestCase.DeriveKey) / 2

		Testing.Test(`Input Length {TestCase.InputLen} Hash`, function()
			local Result = Algorithm.Digest(Input, HashOutputLen)
			Testing.Expect(Result).ToBe(TestCase.Hash)
		end)

		Testing.Test(`Input Length {TestCase.InputLen} Keyed Hash`, function()
			local Key = buffer.fromstring(New.Key)
			local Result = Algorithm.DigestKeyed(Input, Key, KeyedHashOutputLen)
			Testing.Expect(Result).ToBe(TestCase.KeyedHash)
		end)

		Testing.Test(`Input Length {TestCase.InputLen} Key Derivation`, function()
			local Context = buffer.fromstring(New.ContextString)
			local KeyDeriver = Algorithm.DeriveKey(Context)
			local Result = KeyDeriver(Input, DeriveKeyOutputLen)
			Testing.Expect(Result).ToBe(TestCase.DeriveKey)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{91E7C97C-06F0-4014-B219-7F35487C69BD}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Blake3</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD828A66BF7D74CE19B1F8C468E1EE26E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: number
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Checksums/CRC32")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = 0x00000000 },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangramm Example", Expected = 0x519025E9 },
	[", !"] = { Description = "UTF-8 Example", Expected = 0x391651BC },
	["\0"] = { Description = "Null Terminator", Expected = 0xD202EF8D },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = 0xAADFE34E },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = 0x171A3F5F },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = 0xD7EE9B8C },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bits", Expected = 0x191F3349 },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = 0x4144EBAE },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = 0x5B34791C },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = 0x7C5597B9 },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = 0xB3D0F54D },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = 0xDC25BFBC },
}

Testing.Describe("CRC32 Checksum Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString), "Iso", false) :: number
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{6AE5D47E-4B71-45D2-A04C-888C0061DB0B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CRC32</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC8BF75893E4A4BAC9E332B92BD798144">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict

local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Utilities/CSPRNG") 

Testing.Describe("CSPRNG Algorithm Tests", function()
	Testing.Test("Ed25519 Functions", function()
		local Ed25519Bytes = Algorithm.Ed25519Random()
		Testing.Expect(typeof(Ed25519Bytes)).ToBe("buffer")
		Testing.Expect(buffer.len(Ed25519Bytes)).ToBe(32)

		Testing.Expect(function()
			Algorithm.Ed25519ClampedBytes("not a buffer" :: any)
		end).ToThrow()

		local TestBuffer = Algorithm.RandomBytes(32)
		local ClampedBytes = Algorithm.Ed25519ClampedBytes(TestBuffer)
		Testing.Expect(typeof(ClampedBytes)).ToBe("buffer")
		Testing.Expect(buffer.len(ClampedBytes)).ToBe(32)

		local FirstByte = buffer.readu8(ClampedBytes, 0)
		local LastByte = buffer.readu8(ClampedBytes, 31)

		Testing.Expect(bit32.band(FirstByte, 0x07)).ToBe(0)
		Testing.Expect(bit32.band(LastByte, 0x80)).ToBe(0)
		Testing.Expect(bit32.band(LastByte, 0x40)).ToBe(0x40)

		local Ed25519Random = Algorithm.Ed25519Random()
		Testing.Expect(typeof(Ed25519Random)).ToBe("buffer")
		Testing.Expect(buffer.len(Ed25519Random)).ToBe(32)

		local FirstByteRandom = buffer.readu8(Ed25519Random, 0)
		local LastByteRandom = buffer.readu8(Ed25519Random, 31)

		Testing.Expect(bit32.band(FirstByteRandom, 0x07)).ToBe(0)
		Testing.Expect(bit32.band(LastByteRandom, 0x80)).ToBe(0)
		Testing.Expect(bit32.band(LastByteRandom, 0x40)).ToBe(0x40)
	end)

	Testing.Test("Reseed Function", function()
		local Value1 = Algorithm.Random()
		Algorithm.Reseed()
		local Value2 = Algorithm.Random()

		Testing.Expect(Value1).Never.ToBe(Value2)

		local CustomEntropy = Algorithm.RandomBytes(64)
		Algorithm.Reseed(CustomEntropy)
		local Value3 = Algorithm.Random()
		Testing.Expect(typeof(Value3)).ToBe("number")

		Testing.Expect(function()
			Algorithm.Reseed("not a buffer" :: any)
		end).ToThrow()
	end)

	Testing.Test("Chance", function()
		type Rarities = "Common" | "Rare" | "Legendary" | "Mythic"
		
		local WeightedChances: {[Rarities]: number} = {
			Common = 50,
			Rare = 30,
			Legendary = 20,
			Mythic = 1
		}

		local TotalWeight = 0

		for Name, Weight in WeightedChances do
			TotalWeight += Weight :: any
		end

		local function ChooseRandom()
			local Number = Algorithm.RandomInt(1, TotalWeight)
			--local Number = math.random(1, TotalWeight)
			local CurrentWeight = 0

			for Name, Weight in WeightedChances do
				CurrentWeight += Weight

				if Number <= CurrentWeight then
					return Name
				end
			end

			return "Common"
		end

		local ROLLS = 300_000
		local EPSILON = 0.05
		local ITERATIONS = 10

		local Occurences = {
			Common = 0,
			Rare = 0,
			Legendary = 0,
			Mythic = 0,
		}

		local function Reset()
			for Name, Count in Occurences do
				Occurences[Name] = 0
			end
		end

		local function ExpectedOccurences(Rarity: Rarities)
			return math.ceil((WeightedChances[Rarity] / TotalWeight) * ROLLS)
		end

		local Accumlated = table.clone(Occurences)
		for _ = 1, ITERATIONS do
			for _ = 1, ROLLS do
				local ChosenRarity = ChooseRandom()
				Occurences[ChosenRarity] += 1
			end

			for Name, Count in Occurences do
				Name = Name :: Rarities
				Count = Count :: number

				local ActualRate = math.abs(1 - (Count / ExpectedOccurences(Name)))
				Accumlated[Name] += ActualRate
			end

			Reset()
		end

		for Name, Chance in Accumlated do
			local AverageRate = Chance / ITERATIONS
			Testing.Expect(AverageRate).ToBeLessThan(EPSILON)
		end
	end)

	Testing.Test("Distribution Tests", function()
		local Buckets = {}
		for i = 1, 10 do
			Buckets[i] = 0
		end

		for i = 1, 10000 do
			local Value = Algorithm.RandomInt(1, 10)
			Buckets[Value] += 1
		end

		for i = 1, 10 do
			Testing.Expect(Buckets[i]).ToBeGreaterThan(800)
			Testing.Expect(Buckets[i]).ToBeLessThan(1200)
		end

		local FloatBuckets = {0, 0, 0, 0, 0}
		for i = 1, 10000 do
			local Value = Algorithm.Random()
			local Bucket = math.floor(Value * 5) + 1
			FloatBuckets[Bucket] = FloatBuckets[Bucket] + 1
		end

		for i = 1, 5 do
			Testing.Expect(FloatBuckets[i]).ToBeGreaterThan(1600)
			Testing.Expect(FloatBuckets[i]).ToBeLessThan(2400)
		end
	end)

	Testing.Test("Entropy Quality (Chi-Squared)", function()
		local LargeBuffer = Algorithm.RandomBytes(1000)
		local BitCounts = {0, 0, 0, 0, 0, 0, 0, 0}

		for i = 0, 999 do
			local Byte = buffer.readu8(LargeBuffer, i)
			for Bit = 0, 7 do
				if bit32.band(Byte, bit32.lshift(1, Bit)) ~= 0 then
					BitCounts[Bit + 1] += 1
				end
			end
		end

		local Expected = 500
		local ChiSquared = 0
		for i = 1, 8 do
			local Deviation = BitCounts[i] - Expected
			ChiSquared = ChiSquared + (Deviation * Deviation) / Expected
		end

		Testing.Expect(ChiSquared).ToBeLessThan(14.07)
	end)

	Testing.Test("RandomInt", function()
		Testing.Expect(function()
			Algorithm.RandomInt(0, -1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomInt(0, 0)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomInt(1, 1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomInt("test" :: any)
		end).ToThrow()

		for i = 1, 100 do
			local Result = Algorithm.RandomInt(10)
			Testing.Expect(Result).ToBeGreaterThanOrEqual(1)
			Testing.Expect(Result).ToBeLessThanOrEqual(10)
		end

		for i = 1, 1000 do
			local Result = Algorithm.RandomInt(1, 100)
			Testing.Expect(Result).ToBeGreaterThanOrEqual(1)
			Testing.Expect(Result).ToBeLessThanOrEqual(100)
		end

		for i = 1, 100 do
			local Result = Algorithm.RandomInt(2^20, 2^21)
			Testing.Expect(Result).ToBeGreaterThanOrEqual(2^20)
			Testing.Expect(Result).ToBeLessThanOrEqual(2^21)
		end
	end)

	Testing.Test("Random Number", function()
		Testing.Expect(function()
			Algorithm.RandomNumber(0, -1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomNumber(0, 0)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomNumber(1, 1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomNumber("test" :: any)
		end).ToThrow()

		for i = 1, 100 do
			local Result = Algorithm.RandomNumber(10.5)
			Testing.Expect(Result).ToBeGreaterThanOrEqual(0)
			Testing.Expect(Result).ToBeLessThanOrEqual(10.5)
		end

		for i = 1, 1000 do
			local Result = Algorithm.RandomNumber(1.5, 100.7)
			Testing.Expect(Result).ToBeGreaterThanOrEqual(1.5)
			Testing.Expect(Result).ToBeLessThanOrEqual(100.7)
		end

		for i = 1, 100 do
			local Result = Algorithm.RandomNumber(0.001, 0.002)
			Testing.Expect(Result).ToBeGreaterThanOrEqual(0.001)
			Testing.Expect(Result).ToBeLessThanOrEqual(0.002)
		end
	end)

	Testing.Test("GetBytes", function()
		Testing.Expect(function()
			Algorithm.RandomBytes(0)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomBytes(1.1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomBytes("test" :: any)
		end).ToThrow()

		local Buffer1 = Algorithm.RandomBytes(32)
		Testing.Expect(buffer.len(Buffer1)).ToBe(32)
		Testing.Expect(typeof(Buffer1)).ToBe("buffer")

		local Buffer2 = Algorithm.RandomBytes(32)
		Testing.Expect(buffer.len(Buffer2)).ToBe(32)

		local Different = false
		for i = 0, 31 do
			if buffer.readu8(Buffer1, i) ~= buffer.readu8(Buffer2, i) then
				Different = true
				break
			end
		end
		Testing.Expect(Different).ToBeTruthy()

		for Size = 1, 100 do
			local Buffer = Algorithm.RandomBytes(Size)
			Testing.Expect(buffer.len(Buffer)).ToBe(Size)
		end
	end)

	Testing.Test("RandomString", function()
		Testing.Expect(function()
			Algorithm.RandomString(0)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomString(-1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomString(10, 123 :: any)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomString(10, "hello" :: any)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomString(10.1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomString("test" :: any)
		end).ToThrow()

		Testing.Expect(string.len(Algorithm.RandomString(30) :: string)).ToBe(30)
		Testing.Expect(buffer.len(Algorithm.RandomString(30, true) :: buffer)).ToBe(30)

		local String1 = Algorithm.RandomString(10, false) :: string
		Testing.Expect(typeof(String1)).ToBe("string")
		Testing.Expect(#String1).ToBe(10)

		local String2 = Algorithm.RandomString(10, false) :: string
		Testing.Expect(typeof(String2)).ToBe("string")
		Testing.Expect(String1).Never.ToBe(String2)

		local Buffer1 = Algorithm.RandomString(10, true) :: buffer
		Testing.Expect(typeof(Buffer1)).ToBe("buffer")
		Testing.Expect(buffer.len(Buffer1)).ToBe(10)

		for i = 1, 100 do
			local String = Algorithm.RandomString(50, false) :: string
			for j = 1, #String do
				local Byte = string.byte(String, j)
				Testing.Expect(Byte).ToBeGreaterThanOrEqual(36)
				Testing.Expect(Byte).ToBeLessThanOrEqual(122)
			end
		end
	end)

	Testing.Test("RandomHex", function()
		Testing.Expect(function()
			Algorithm.RandomHex(0)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomHex(-1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomHex(10.1)
		end).ToThrow()

		Testing.Expect(function()
			Algorithm.RandomHex("test" :: any)
		end).ToThrow()

		Testing.Expect(string.len(Algorithm.RandomHex(30))).ToBe(30)
		Testing.Expect(function()
			Algorithm.RandomHex(31)
		end).ToThrow()
		Testing.Expect(string.len(Algorithm.RandomHex(32))).ToBe(32)

		for Length = 2, 64, 2 do 
			local HexString = Algorithm.RandomHex(Length)
			Testing.Expect(typeof(HexString)).ToBe("string")
			Testing.Expect(#HexString).ToBe(Length)

			for i = 1, #HexString do
				local Char = string.sub(HexString, i, i)
				local IsValidHex = string.match(Char, "[0-9a-fA-F]") ~= nil
				Testing.Expect(IsValidHex).ToBeTruthy()
			end
		end
	end)
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{E5B7DF79-8790-4386-9287-EC645CA6D3A3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CSPRNG</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB1A6D6B33AF24EE686662837148FE798">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict

local Testing = require("./")

type TestVector = {
	Description: string,
	Expected: number,
	Seed: number
}

type TestVectors = {[string]: TestVector}

local Algorithm = require("../Hashing/Murmur")

local TestVectors: TestVectors = {
	[""] = { 
		Description = "Empty String (Seed 0x00)", 
		Expected = 0x00000000, 
		Seed = 0x00 
	},
	["hello"] = { 
		Description = "Hello (Seed 0x00)", 
		Expected = 0x248bfa47, 
		Seed = 0x00 
	},
	["hello, world"] = { 
		Description = "Hello, world (Seed 0x00)", 
		Expected = 0x149bbb7f, 
		Seed = 0x00 
	},
	["19 Jan 2038 at 3:14:07 AM"] = { 
		Description = "Date String (Seed 0x00)", 
		Expected = 0xe31e8a70, 
		Seed = 0x00 
	},
	["The quick brown fox jumps over the lazy dog."] = { 
		Description = "Quick Brown Fox (Seed 0x00)", 
		Expected = 0xd5c48bfc, 
		Seed = 0x00 
	},
}

local SeededTestVectors1: TestVectors = {
	[""] = { 
		Description = "Empty String (Seed 0x01)", 
		Expected = 0x514e28b7, 
		Seed = 0x01 
	},
	["hello"] = { 
		Description = "Hello (Seed 0x01)", 
		Expected = 0xbb4abcad, 
		Seed = 0x01 
	},
	["hello, world"] = { 
		Description = "Hello, world (Seed 0x01)", 
		Expected = 0x6f5cb2e9, 
		Seed = 0x01 
	},
	["19 Jan 2038 at 3:14:07 AM"] = { 
		Description = "Date String (Seed 0x01)", 
		Expected = 0xf50e1f30, 
		Seed = 0x01 
	},
	["The quick brown fox jumps over the lazy dog."] = { 
		Description = "Quick Brown Fox (Seed 0x01)", 
		Expected = 0x846f6a36, 
		Seed = 0x01 
	},
}

local SeededTestVectors2A: TestVectors = {
	[""] = { 
		Description = "Empty String (Seed 0x2a)", 
		Expected = 0x087fcd5c, 
		Seed = 0x2a 
	},
	["hello"] = { 
		Description = "Hello (Seed 0x2a)", 
		Expected = 0xe2dbd2e1, 
		Seed = 0x2a 
	},
	["hello, world"] = { 
		Description = "Hello, world (Seed 0x2a)", 
		Expected = 0x7ec7c6c2, 
		Seed = 0x2a 
	},
	["19 Jan 2038 at 3:14:07 AM"] = { 
		Description = "Date String (Seed 0x2a)", 
		Expected = 0x58f745f6, 
		Seed = 0x2a 
	},
	["The quick brown fox jumps over the lazy dog."] = { 
		Description = "Quick Brown Fox (Seed 0x2a)", 
		Expected = 0xc02d1434, 
		Seed = 0x2a 
	},
}

Testing.Describe("MurmurHash3-32 Algorithm Tests (Seed 0x00)", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString), Info.Seed)
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("MurmurHash3-32 Algorithm Tests (Seed 0x01)", function()
	for TestString, Info in SeededTestVectors1 do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString), Info.Seed)
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("MurmurHash3-32 Algorithm Tests (Seed 0x2a)", function()
	for TestString, Info in SeededTestVectors2A do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString), Info.Seed)
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0
]]></ProtectedString>
							<string name="ScriptGuid">{127E668E-59AC-4571-8552-7CC3961AD3FF}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Murmur</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA5580CC28F2C408AA0F1F99E0BF38B32">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")

type TestVector = {
	Mode: "Encrypt" | "Decrypt",
	Description: string,
	Expected: string,
	Key: buffer?,
	Plaintext: string?,
}

type TestVectors = {[string]: TestVector}

local function FromHex(Hex: string): buffer
	local Length = #Hex
	local Buffer = buffer.create(Length / 2)
	for Index = 0, Length - 2, 2 do
		buffer.writeu8(Buffer, Index / 2, tonumber(string.sub(Hex, Index + 1, Index + 2), 16) :: number)
	end
	
	return Buffer
end

local function ToHex(Buffer: buffer): string
	local Hex = ""
	for Index = 0, buffer.len(Buffer) - 1 do
		Hex ..= string.format("%02x", buffer.readu8(Buffer, Index))
	end
	
	return Hex
end

local Speck = require("../Encryption/Speck")


Testing.Describe("Speck Cipher Algorithm Tests", function()

	Testing.Test("Generate Expected Values For Custom Tests", function()
		local HelloEncrypted = Speck.Encrypt(
			buffer.fromstring("Hello!!!"),
			FromHex("0001020304050607")
		)

		local HelloDecrypted = Speck.Decrypt(
			HelloEncrypted,
			FromHex("0001020304050607")
		)
		Testing.Expect(buffer.tostring(HelloDecrypted)).ToBe("Hello!!!")
	end)

	Testing.Test("Official Test Vector Round-trip", function()
		local Plaintext = FromHex("6561656e7320466174")
		local Key = FromHex("0001020308094b10111213000000")

		local Encrypted = Speck.Encrypt(Plaintext, Key)
		local Decrypted = Speck.Decrypt(Encrypted, Key)

		Testing.Expect(ToHex(Decrypted)).ToBe(ToHex(Plaintext))
	end)

	local RoundTripTests = {
		"Hello World!",
		"Test123",
		"A",
		"This is a longer test string to verify padding works correctly!",
		string.rep("X", 100),
		"SpeckCipher",
		"12345678",
		"abcdefgh"
	}

	for _, TestString in RoundTripTests do
		Testing.Test("Round-trip Test: " .. TestString:sub(1, 20) .. (TestString:len() > 20 and "..." or ""), function()
			local Key = FromHex("0001020304050607")
			local Plaintext = buffer.fromstring(TestString)

			local Encrypted = Speck.Encrypt(Plaintext, Key)
			local Decrypted = Speck.Decrypt(Encrypted, Key)

			Testing.Expect(buffer.tostring(Decrypted)).ToBe(TestString)
		end)
	end

	Testing.Test("Key Handling Tests", function()
		local Plaintext = buffer.fromstring("TestData")

		local ShortKey = buffer.fromstring("key")
		local Encrypted1 = Speck.Encrypt(Plaintext, ShortKey)
		local Decrypted1 = Speck.Decrypt(Encrypted1, ShortKey)
		Testing.Expect(buffer.tostring(Decrypted1)).ToBe("TestData")

		local LongKey = buffer.fromstring("this_is_a_very_long_key_that_exceeds_8_bytes")
		local Encrypted2 = Speck.Encrypt(Plaintext, LongKey)
		local Decrypted2 = Speck.Decrypt(Encrypted2, LongKey)
		Testing.Expect(buffer.tostring(Decrypted2)).ToBe("TestData")
	end)

	Testing.Test("Empty Input Test", function()
		local Key = FromHex("0001020304050607")
		local EmptyBuffer = buffer.create(0)

		local Encrypted = Speck.Encrypt(EmptyBuffer, Key)
		local Decrypted = Speck.Decrypt(Encrypted, Key)

		Testing.Expect(buffer.len(Decrypted)).ToBe(0)
	end)

	Testing.Test("Exact Block Size Test", function()
		local Key = FromHex("0001020304050607")
		local Plaintext = FromHex("0123456789abcdef")

		local Encrypted = Speck.Encrypt(Plaintext, Key)
		local Decrypted = Speck.Decrypt(Encrypted, Key)

		Testing.Expect(ToHex(Decrypted)).ToBe("0123456789abcdef")
	end)

	Testing.Test("Different Key Patterns", function()
		local Plaintext = buffer.fromstring("TestSpeck")

		local Keys = {
			FromHex("0123456789abcdef"),
			FromHex("fedcba9876543210"),
			FromHex("aaaaaaaaaaaaaaaa"),
			FromHex("5555555555555555"),
			FromHex("0f0f0f0f0f0f0f0f")
		}

		for Index, Key in Keys do
			local Encrypted = Speck.Encrypt(Plaintext, Key)
			local Decrypted = Speck.Decrypt(Encrypted, Key)
			Testing.Expect(buffer.tostring(Decrypted)).ToBe("TestSpeck")
		end
	end)

	Testing.Test("Large Data Test", function()
		local Key = FromHex("0001020304050607")
		local LargeText = string.rep("Speck64Encryption", 50)
		local Plaintext = buffer.fromstring(LargeText)

		local Encrypted = Speck.Encrypt(Plaintext, Key)
		local Decrypted = Speck.Decrypt(Encrypted, Key)

		Testing.Expect(buffer.tostring(Decrypted)).ToBe(LargeText)
	end)

	Testing.Test("Binary Data Test", function()
		local Key = FromHex("deadbeefcafebabe")
		local BinaryData = FromHex("00112233445566778899aabbccddeeff")

		local Encrypted = Speck.Encrypt(BinaryData, Key)
		local Decrypted = Speck.Decrypt(Encrypted, Key)

		Testing.Expect(ToHex(Decrypted)).ToBe("00112233445566778899aabbccddeeff")
	end)
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{703CC6C4-1D63-4670-B807-1C20C1CFA1AF}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Speck</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD9774BC24917434CB61BB4C2FED99421">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	HMAC Wycheproof Test Suite
	
	Validates HMAC implementations against Google's Wycheproof test vectors.
	Covers MAC generation and verification with various key and message sizes.
	
	Test Vector Sources:
		HMAC-SHA-256: https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/hmac_sha256_test.json
		HMAC-SHA3-512: https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/hmac_sha3_512_test.json
	
	Test Categories:
		Pseudorandom - Various input sizes for correctness testing
		ModifiedTag - Tampered MACs to verify full tag checking
	
	Endianness Note:
		SHA-256 uses big-endian output (default for HMAC)
		SHA3-512 uses little-endian output (requires explicit false parameter)
		This test suite validates both work correctly.
--]=]

--!strict
--!optimize 2

local Http = game:GetService("HttpService")

local Testing = require("./")
local Cryptography = require("../")
local HMAC = Cryptography.Hashing.HMAC
local SHA2 = Cryptography.Hashing.SHA2
local SHA3 = Cryptography.Hashing.SHA3
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex

type MacTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	key: string,
	msg: string,
	tag: string,
	result: string,
}

type MacGroup = {
	type: string,
	keySize: number,
	tagSize: number,
	source: {name: string, version: string}?,
	tests: {MacTest},
}

type MacData = {
	algorithm: string,
	numberOfTests: number,
	testGroups: {MacGroup},
}

type HmacConfig = {
	Name: string,
	Url: string,
	HashFunc: (buffer, buffer?) -> (string, buffer),
	BlockSize: number,
	BigEndian: boolean,
}

local HMAC_CONFIGS: {HmacConfig} = {
	{
		Name = "HMAC-SHA-256",
		Url = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/hmac_sha256_test.json",
		HashFunc = SHA2.SHA256,
		BlockSize = 64,
		BigEndian = true,
	},
	{
		Name = "HMAC-SHA3-512",
		Url = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/hmac_sha3_512_test.json",
		HashFunc = SHA3.SHA3_512,
		BlockSize = 72,
		BigEndian = false,
	},
}

local function FetchTestVectors(Url: string): MacData
	local Response = Http:GetAsync(Url)
	return Http:JSONDecode(Response) :: MacData
end

local function RunHmacTests(Config: HmacConfig)
	Testing.Describe(`{Config.Name} Wycheproof Tests`, function()
		local Data = FetchTestVectors(Config.Url)

		for GroupIndex, Group in ipairs(Data.testGroups) do
			local KeySize = Group.keySize
			local TagSize = Group.tagSize
			local SourceName = if Group.source then Group.source.name else "unknown"

			Testing.Describe(`Group_{GroupIndex}: {KeySize}bit_Key_{TagSize}bit_Tag (Source: {SourceName})`, function()
				for _, Test in ipairs(Group.tests) do
					local TestId = Test.tcId
					local Comment = Test.comment or ""
					local ExpectedResult = Test.result

					local TestName = `Test_{TestId}`
					if Comment ~= "" then
						TestName = `Test_{TestId}_{Comment:sub(1, 25):gsub(" ", "_")}`
					end

					Testing.Test(TestName, function()
						local Key = FromHex(Test.key)
						local Msg = FromHex(Test.msg)
						local ExpectedTag = Test.tag:lower()
						local ExpectedTagBytes = TagSize // 8

						local ComputeOk, Result, _ = pcall(function()
							return HMAC(Msg, Key, Config.HashFunc, Config.BlockSize, Config.BigEndian)
						end)

						if ExpectedResult == "valid" then
							Testing.Expect(ComputeOk).ToBe(true)
							Testing.Expect(Result).ToBeDefined()

							if ComputeOk and Result then
								local ComputedTag = string.sub(Result:lower(), 1, ExpectedTagBytes * 2)
								Testing.Expect(ComputedTag).ToBe(ExpectedTag)
							end
						elseif ExpectedResult == "invalid" then
							if ComputeOk and Result then
								local ComputedTag = string.sub(Result:lower(), 1, ExpectedTagBytes * 2)
								Testing.Expect(ComputedTag).Never.ToBe(ExpectedTag)
							else
								Testing.Expect(true).ToBe(true)
							end
						elseif ExpectedResult == "acceptable" then
							Testing.Expect(true).ToBe(true)
						end
					end)
				end
			end)
		end
	end)
end

for _, Config in ipairs(HMAC_CONFIGS) do
	RunHmacTests(Config)
end

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{9D88F1B6-6501-40A5-A496-5E4AE27336A4}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HMAC</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8C99E07716904D148DA0CBC13B8EE38C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/MD5")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "d41d8cd98f00b204e9800998ecf8427e" },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangramm Example", Expected = "e4d909c290d0fb1ca068ffaddf22cbd0" },
	[", !"] = { Description = "UTF-8 Example", Expected = "c446a2994f35689482651b7c7ba8b56c" },
	["\0"] = { Description = "Null Terminator", Expected = "93b885adfe0da089cdf634904fd59f71" },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = "ef1772b6dff9a122358552954ad0df65" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "8215ef0796a20bcaaae116d3876c664a" },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = "089f243d1e831c5879aa375ee364a06e" },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bits", Expected = "03dd8807a93175fb062dfb55dc7d359c" },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = "8a7bd0732ed6a28ce75f6dabc90e1613" },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = "b7b40d64ffccebd78abcf522376b3aae" },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = "c9a34cfc85d982698c6ac89f76071abd" },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = "5b21a86f4bb0f3f703167705e5e673df" },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = "7707d6ae4e027c70eea2a935c2296f21" },
}

Testing.Describe("MD5 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{E4F5D418-19A9-4F3E-B736-3F703697C710}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MD5</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAE9F030DBC9D4DE7BAC0ED854B755AC9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/SHA1")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "da39a3ee5e6b4b0d3255bfef95601890afd80709" },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangramm Example", Expected = "408d94384216f890ff7a0c3528e8bed1e0b01621" },
	[", !"] = { Description = "UTF-8 Example", Expected = "0cb95b7891ff182f0972be8754ec934df65af21c" },
	["\0"] = { Description = "Null Terminator", Expected = "5ba93c9db0cff93f52b521d7420e43f6eda2784f" },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = "c1c8bbdc22796e28c0e15163d20899b65621d65a" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "84983e441c3bd26ebaae4aa1f95129e5e54670f1" },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = "ac877859d427d9192054eea8feb3b8a403ef83a5" },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bits", Expected = "a49b2446a02c645bf419f995b67091253a04a259" },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = "ee971065aaa017e0632a8ca6c77bb3bf8b1dfc56" },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = "fdc30857cf7b957f47ebd8288d5e5d7426f44394" },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = "8eca554631df9ead14510e1a70ae48c70f9b9384" },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = "b673b36f4398c26070c29ade5193903b4e6455d9" },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = "34aa973cd4c4daa4f61eeb2bdbad27316534016f" },
}

Testing.Describe("SHA1 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{9743BA0C-3ED2-4F82-881B-029105B7FD56}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA1</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA3C421186BE04AB6975B185B0288F58C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/SHA2/SHA224")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f" },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangramm Example", Expected = "619cba8e8e05826e9b8c519c0a5c68f4fb653e8a3d8aa04bb2c8cd4c" },
	[", !"] = { Description = "UTF-8 Example", Expected = "941fd4cfe921e7a8ea1e1c6dd255b3c06d948fe7546bcd1d8deda161" },
	["\0"] = { Description = "Null Terminator", Expected = "fff9292b4201617bdc4d3053fce02734166a683d7d858a7f5f59b073" },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = "fb0bd626a70c28541dfa781bb5cc4d7d7f56622a58f01a0b1ddd646f" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525" },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = "4aeec1a49b2c1bc663abf2809b36faaa64359523d4f26d02dbc2cba3" },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bits", Expected = "c97ca9a559850ce97a04a96def6d99a9e0e0e2ab14e6b8df265fc0b3" },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = "e000e6709d26667b631faa7fc1bd404eb4774003c5fb4f51a0184875" },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = "9da4e535cdffdbb7ee783ef7c6b61cbda7bcd4b15ce59d6ce5c2f099" },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = "dcbd9ce406352c2e127ce1cad5042c22dd28a0246dadefc12f384c2e" },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = "4fa3ff00143a30c4530a986cecb42ee2c2ae41b52faff36bfbee5152" },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = "20794655980c91d8bbb4c1ea97618a4bf03f42581948b2ee4ee7ad67" },
}

Testing.Describe("SHA224 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{B4119EF2-3BD1-45EF-BE4E-AB60556CF8D9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA224</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB69DE26701114ECB8AB3D9F213A6B2EC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/SHA2/SHA256")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangramm Example", Expected = "ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c" },
	[", !"] = { Description = "UTF-8 Example", Expected = "9a0af011605a6ab9022f248fb797064a42782210ac91e834348b3ef089313e5f" },
	["\0"] = { Description = "Null Terminator", Expected = "6e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d" },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = "9f4390f8d30c2dd92ec9f095b65e2b9ae9b0a925a5258e241c9f1e910f734318" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1" },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = "6374f73208854473827f6f6a3f43b1f53eaa3b82c21c1a6d69a2110b2a79baad" },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bits", Expected = "cf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1" },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = "31eba51c313a5c08226adf18d4a359cfdfd8d2e816b13f4af952f7ea6584dcfb" },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = "064b3d122abe25c36265f79fc794b0adf28a6c5e4fe8ed3661f2287e8cecadcc" },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = "2edc986847e209b4016e141a6dc8716d3207350f416969382d431539bf292e4a" },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = "6a2540f78c491a847183ac081f68c7f971806fbd346408aaefbf5d4edec3e901" },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = "cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0" },
}

Testing.Describe("SHA256 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{EFAEF3C4-590F-41AC-8574-152DB480DCAD}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA256</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX875E55686B4D40D6BCFEF1519584D09A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/SHA3")
local SHA3_224_TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7" },
	["abc"] = { Description = "Short String", Expected = "e642824c3f8cf24ad09234ee7d3c766fc9a3a5168d0c94ad73b46fdf" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "8a24108b154ada21c9fd5574494479ba5c7e7ab76ef264ead0fcce33" },
	["The quick brown fox jumps over the lazy dog"] = { Description = "Pangram", Expected = "d15dadceaa4d5d7bb3b48f446421d542e08ad8887305e28d58335795" },
	[string.rep("a", 1000000)] = { Description = "Million a's", Expected = "d69335b93325192e516a912e6d19a15cb51c6ed5c15243e7a7fd653c" }
}

local SHA3_256_TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a" },
	["abc"] = { Description = "Short String", Expected = "3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "41c0dba2a9d6240849100376a8235e2c82e1b9998a999e21db32dd97496d3376" },
	["The quick brown fox jumps over the lazy dog"] = { Description = "Pangram", Expected = "69070dda01975c8c120c3aada1b282394e7f032fa9cf32f4cb2259a0897dfc04" },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangram with Period", Expected = "a80f839cd4f83f6c3dafc87feae470045e4eb0d366397d5c6ce34ba1739f734d" },
	[string.rep("a", 1000000)] = { Description = "Million a's", Expected = "5c8875ae474a3634ba4fd55ec85bffd661f32aca75c6d699d0cdcb6c115891c1" }
}

local SHA3_384_TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004" },
	["abc"] = { Description = "Short String", Expected = "ec01498288516fc926459f58e2c6ad8df9b473cb0fc08c2596da7cf0e49be4b298d88cea927ac7f539f1edf228376d25" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "991c665755eb3a4b6bbdfb75c78a492e8c56a22c5c4d7e429bfdbc32b9d4ad5aa04a1f076e62fea19eef51acd0657c22" },
	["The quick brown fox jumps over the lazy dog"] = { Description = "Pangram", Expected = "7063465e08a93bce31cd89d2e3ca8f602498696e253592ed26f07bf7e703cf328581e1471a7ba7ab119b1a9ebdf8be41" },
	[string.rep("a", 1000000)] = { Description = "Million a's", Expected = "eee9e24d78c1855337983451df97c8ad9eedf256c6334f8e948d252d5e0e76847aa0774ddb90a842190d2c558b4b8340" }
}

local SHA3_512_TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26" },
	["abc"] = { Description = "Short String", Expected = "b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "04a371e84ecfb5b8b77cb48610fca8182dd457ce6f326a0fd3d7ec2f1e91636dee691fbe0c985302ba1b0d8dc78c086346b533b49c030d99a27daf1139d6e75e" },
	["The quick brown fox jumps over the lazy dog"] = { Description = "Pangram", Expected = "01dedd5de4ef14642445ba5f5b97c15e47b9ad931326e4b0727cd94cefc44fff23f07bf543139939b49128caf436dc1bdee54fcb24023a08d9403f9b4bf0d450" },
	[string.rep("a", 1000000)] = { Description = "Million a's", Expected = "3c3a876da14034ab60627c077bb98f7e120a2a5370212dffb3385a18d4f38859ed311d0a9d5141ce9cc5c66ee689b266a8aa18ace8282a0e0db596c90b0a7b87" }
}

local SHAKE128_TestVectors: TestVectors = {
	[""] = { Description = "Empty String (32 bytes)", Expected = "7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef26" },
	["abc"] = { Description = "Short String (32 bytes)", Expected = "5881092dd818bf5cf8a3ddb793fbcba74097d5c526a6d35f97b83351940f2cc8" },
	["The quick brown fox jumps over the lazy dog"] = { Description = "Pangram (32 bytes)", Expected = "f4202e3c5852f9182a0430fd8144f0a74b95e7417ecae17db0f8cfeed0e3e66e" },
	[string.rep("a", 1000000)] = { Description = "Million a's (32 bytes)", Expected = "9d222c79c4ff9d092cf6ca86143aa411e369973808ef97093255826c5572ef58" }
}

local SHAKE256_TestVectors: TestVectors = {
	[""] = { Description = "Empty String (64 bytes)", Expected = "46b9dd2b0ba88d13233b3feb743eeb243fcd52ea62b81b82b50c27646ed5762fd75dc4ddd8c0f200cb05019d67b592f6fc821c49479ab48640292eacb3b7c4be" },
	["abc"] = { Description = "Short String (64 bytes)", Expected = "483366601360a8771c6863080cc4114d8db44530f8f1e1ee4f94ea37e78b5739d5a15bef186a5386c75744c0527e1faa9f8726e462a12a4feb06bd8801e751e4" },
	["The quick brown fox jumps over the lazy dog"] = { Description = "Pangram (64 bytes)", Expected = "2f671343d9b2e1604dc9dcf0753e5fe15c7c64a0d283cbbf722d411a0e36f6ca1d01d1369a23539cd80f7c054b6e5daf9c962cad5b8ed5bd11998b40d5734442" },
	[string.rep("a", 1000000)] = { Description = "Million a's (64 bytes)", Expected = "3578a7a4ca9137569cdf76ed617d31bb994fca9c1bbf8b184013de8234dfd13a3fd124d4df76c0a539ee7dd2f6e1ec346124c815d9410e145eb561bcd97b18ab" }
}

Testing.Describe("SHA3-224 Algorithm Tests", function()
	for TestString, Info in SHA3_224_TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm.SHA3_224(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("SHA3-256 Algorithm Tests", function()
	for TestString, Info in SHA3_256_TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm.SHA3_256(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("SHA3-384 Algorithm Tests", function()
	for TestString, Info in SHA3_384_TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm.SHA3_384(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("SHA3-512 Algorithm Tests", function()
	for TestString, Info in SHA3_512_TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm.SHA3_512(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("SHAKE128 Algorithm Tests", function()
	for TestString, Info in SHAKE128_TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm.SHAKE128(buffer.fromstring(TestString), 32)
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("SHAKE256 Algorithm Tests", function()
	for TestString, Info in SHAKE256_TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm.SHAKE256(buffer.fromstring(TestString), 64)
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{4A4B6391-1BA3-470E-BF24-ED55C4B5225C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA3</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAC46C337A7C649879E85213514506355">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/SHA2/SHA384")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b" },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangramm Example", Expected = "ed892481d8272ca6df370bf706e4d7bc1b5739fa2177aae6c50e946678718fc67a7af2819a021c2fc34e91bdb63409d7" },
	[", !"] = { Description = "UTF-8 Example", Expected = "6a69c1a6d1d16f369dd6883690561e0bd508d6766a512c33d7c46a2c73cfbdbbc1fcf55cd5d657830713cffc343b7bac" },
	["\0"] = { Description = "Null Terminator", Expected = "bec021b4f368e3069134e012c2b4307083d3a9bdd206e24e5f0d86e13d6636655933ec2b413465966817a9c208a11717" },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = "5d91ac7e74e62b5c728904b40f10784d66b7af9cb6302123e48c92f0432ceb8d2a92c02de77dcb29ed75c4b42bde46f4" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "3391fdddfc8dc7393707a65b1b4709397cf8b1d162af05abfe8f450de5f36bc6b0455a8520bc4e6f5fe95b1fe3c8452b" },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = "3c37955051cb5c3026f94d551d5b5e2ac38d572ae4e07172085fed81f8466b8f90dc23a8ffcdea0b8d8e58e8fdacc80a" },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bits", Expected = "09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712fcc7c71a557e2db966c3e9fa91746039" },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = "c2fbb1911d6889e3db556b482236ab82f3c736f00a22c088641a09fdbbca27e3f1e3b6235bad20aee1ca083c76ac590c" },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = "e247c35f4bc1aa38026f8880c8c97305545d00d3f859e00c57d1c1f0a176b3c6b749c4eb081f08bd0fba500969cd056a" },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = "a31bea5896ef0e418f18014ef9fde89f6f33a177dc97190bc39dedd94e5476342a0d277c92bc19ca0542fca227d12c4c" },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = "a698a19c13a234f4cff4f80bdc8e4b69f729580ff9b3ff55526fbcdf1f1700ea0186c1d5c412d75aff1db8884d697534" },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = "9d0e1809716474cb086e834e310a4a1ced149e9c00f248527972cec5704c2a5b07b8b3dc38ecc4ebae97ddd87f3d8985" },
}

Testing.Describe("SHA384 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{EF511A36-1F90-4B18-8703-B3EC8BC4A807}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA384</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3326953E61AB428080A5318895401381">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: string
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/SHA2/SHA512")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e" },
	["The quick brown fox jumps over the lazy dog."] = { Description = "Pangramm Example", Expected = "91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bbc6c7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed" },
	[", !"] = { Description = "UTF-8 Example", Expected = "72999100567a447d753427946f9de45255ab9ce1778f771b5c3d4663cbb53f8623e829655b3b3ca7bfe388510249f74e5d3a0e16c8be0ff2d0696abcb68a940e" },
	["\0"] = { Description = "Null Terminator", Expected = "b8244d028981d693af7b456af8efa4cad63d282e19ff14942c246e50d9351d22704a802a71c3580b6370de4ceb293c324a8423342557d4e5c38438f0e36910ee" },
	[string.rep("a", 55)] = { Description = "Block of Characters", Expected = "b0220c772cbf6c1822e2cb38a437d0e1d58772417a4bbb21c961364f8b6143e05aa6316dca8d1d7b19e16448419076395f6086cb55101fbd6d5497b148e1745f" },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit", Expected = "204a8fc6dda82f0a0ced7beb8e08a41657c16ef468b228a8279be331a703c33596fd15c13b1b07f9aa1d3bea57789ca031ad85c7a71dd70354ec631238ca3445" },
	[string.rep("a", 111)] = { Description = "111 Characters", Expected = "fa9121c7b32b9e01733d034cfc78cbf67f926c7ed83e82200ef86818196921760b4beff48404df811b953828274461673c68d04e297b0eb7b2b4d60fc6b566a2" },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bits", Expected = "8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909" },
	[string.rep("a", 119)] = { Description = "119 Characters", Expected = "130396a75cb483f2eee8c56d8a668bb3d2641f5243212c0bee2bd33da096ad9eb8179fe18f9eaacf76e09fae9de4c3f14ba13341e345be05bf76c182cc3468cb" },
	[string.rep("a", 239)] = { Description = "239 Characters", Expected = "52c853cb8d907f3d4d6b889beb027985d7c273486d75f8baf26f80d24e90c74c6c3de3e22131582380a7d14d43f2941a31385439cd6ddc469f628015e50bf286" },
	[string.rep("a", 1024)] = { Description = "Long String", Expected = "74b22492e3b9a86a9c93c23a69f821ebafa429302c1f4054b4bc37356a4bae056d9ccbc6f24093a25704faaa72bd21a5f337ca9ec92f32369d24e6b9fae954d8" },
	[string.rep("a", 199999)] = { Description = "Really Long String", Expected = "24ff84cd80316c1f3591abf9f59c026eb8a22390f005acf1a2d21aa0d3433608cc8bdfebe07fbe2ced63f625b5675f5cdb21fdc9710f8ecd31dea524d282d284" },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = "e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973ebde0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b" },
}

Testing.Describe("SHA512 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString))
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{D2794AE3-11CD-4FDD-9A25-495296E4A403}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SHA512</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX881E745097744C9680A68003C0B3F860">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Expected: number,
	Seed: number?
}

type TestVectors = {[string]: TestVector}
local Algorithm = require("../Hashing/XXH32")

local TestVectors: TestVectors = {
	[""] = { Description = "Empty String", Expected = 0x02cc5d05 },
	["abc"] = { Description = "Simple ABC", Expected = 0x32d153ff },
	["foo"] = { Description = "Simple Foo", Expected = 0xe20f0dd9 },
	["bar"] = { Description = "Simple Bar", Expected = 0x41a22b2c },
	["baz"] = { Description = "Simple Baz", Expected = 0x9bab0987 },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit Alphabet", Expected = 0x89ea60c3 },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bit Alphabet", Expected = 0x590b4165 },
	["The Fitness-Gram Pacer Test is a multi-stage aerobic capacity test"] = { Description = "Fitness-Gram Test", Expected = 0xbea696a7 },
	[string.rep("e", 199999)] = { Description = "Really Long String", Expected = 0xb27dd558 },
	[string.rep("a", 1e6)] = { Description = "Million", Expected = 0xe1155920 },
}

local SeededTestVectors: TestVectors = {
	[""] = { Description = "Empty String with Seed", Expected = 0xf6114164, Seed = 0x02cc5d05 },
	["abc"] = { Description = "Simple ABC with Seed", Expected = 0x9041e0d8, Seed = 0x32d153ff },
	["foo"] = { Description = "Simple Foo with Seed", Expected = 0xf4d3f6c9, Seed = 0xe20f0dd9 },
	["bar"] = { Description = "Simple Bar with Seed", Expected = 0x9ad4ead3, Seed = 0x41a22b2c },
	["baz"] = { Description = "Simple Baz with Seed", Expected = 0x23af9b99, Seed = 0x9bab0987 },
	["abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"] = { Description = "448 Bit Alphabet with Seed", Expected = 0x404871e3, Seed = 0x89ea60c3 },
	["abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"] = { Description = "896 Bit Alphabet with Seed", Expected = 0xc033cd93, Seed = 0x590b4165 },
	["The Fitness-Gram Pacer Test is a multi-stage aerobic capacity test"] = { Description = "Fitness-Gram Test with Seed", Expected = 0x3c6ef7ed, Seed = 0xbea696a7 },
	[string.rep("e", 199999)] = { Description = "Really Long String with Seed", Expected = 0x6174a9bd, Seed = 0xb27dd558 },
	[string.rep("a", 1e6)] = { Description = "Million with Seed", Expected = 0xc0c7beae, Seed = 0xe1155920 },
}

Testing.Describe("xxHash32 Algorithm Tests", function()
	for TestString, Info in TestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString), Info.Seed)
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Describe("xxHash32 Seeded Algorithm Tests", function()
	for TestString, Info in SeededTestVectors do
		Testing.Test(Info.Description, function()
			local Result = Algorithm(buffer.fromstring(TestString), Info.Seed)
			Testing.Expect(Result).ToBe(Info.Expected)
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{EEA947DE-8135-4F8E-B719-083245E80D04}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">XXH32</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2C914F3BE9054E54BD971308CB6E848B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")
type TestVector = {
	Description: string,
	Input: string,
	Key: string,
}


local function ToHex(Buffer: buffer) : string
	local Hex = ""
	for Index = 0, buffer.len(Buffer) - 1 do
		Hex ..= string.format("%02x", buffer.readu8(Buffer, Index))
	end

	return Hex
end

local XOR = require("../Encryption/XOR")

local TestVectors: {TestVector} = {
	{
		Description = "Single byte key - Hello World!",
		Input = "Hello World!",
		Key = "X"
	},
	{
		Description = "Four byte key - Testing 1234",
		Input = "Testing 1234",
		Key = "ABCD"
	},
	{
		Description = "Three byte key - Hello World!",
		Input = "Hello World!",
		Key = "KEY"
	},
	{
		Description = "150 characters with 5 byte key",
		Input = string.rep("a", 150),
		Key = "@@@@@"
	},
	{
		Description = "Empty string",
		Input = "",
		Key = "KEY"
	},
	{
		Description = "Single character",
		Input = "A",
		Key = "C"
	},
	{
		Description = "Binary data",
		Input = "\xFF\x00\xFF\x00\xFF\x00\xFF\x00",
		Key = "\x55"
	},
	{
		Description = "Two byte key - Test Message",
		Input = "Test Message",
		Key = "AB"
	},
	{
		Description = "Key longer than message",
		Input = "Short",
		Key = "VeryLongKeyThatIsLongerThanMessage"
	},
	{
		Description = "String with null byte",
		Input = "Test\0Message",
		Key = "ABC"
	},
	{
		Description = "3 byte string",
		Input = "123",
		Key = "BAD"
	},
	{
		Description = "5 byte string",
		Input = "12345",
		Key = "BAD"
	},
	{
		Description = "17 byte key",
		Input = "This is a test message for XOR encryption",
		Key = "LARGEKEY12345678X"
	},
	{
		Description = "Key repetition pattern",
		Input = "ABCDEFGHIJKLMNOP",
		Key = "CAB"
	},
}

Testing.Describe("XOR Encryption Algorithm Tests", function()
	for _, Vector in TestVectors do
		Testing.Test(Vector.Description .. " [Encrypt/Decrypt Cycle]", function()
			local InputBuffer = buffer.fromstring(Vector.Input)
			local KeyBuffer = buffer.fromstring(Vector.Key)

			local Encrypted = XOR(InputBuffer, KeyBuffer)
			local Decrypted = XOR(Encrypted, KeyBuffer)

			Testing.Expect(buffer.tostring(Decrypted)).ToBe(Vector.Input)
		end)
	end

	Testing.Test("Deterministic output test", function()
		local Input = "Test String"
		local Key = "MyKey"
		local InputBuffer = buffer.fromstring(Input)
		local KeyBuffer = buffer.fromstring(Key)

		local Result1 = ToHex(XOR(InputBuffer, KeyBuffer))
		local Result2 = ToHex(XOR(InputBuffer, KeyBuffer))

		Testing.Expect(Result1).ToBe(Result2)
	end)

	Testing.Test("Known value: A XOR C = 02", function()
		local InputBuffer = buffer.fromstring("A")
		local KeyBuffer = buffer.fromstring("C")
		local Result = ToHex(XOR(InputBuffer, KeyBuffer))
		Testing.Expect(Result).ToBe("02")
	end)

	Testing.Test("Known value: 0xFF XOR 0x55 = 0xAA", function()
		local InputBuffer = buffer.fromstring("\xFF")
		local KeyBuffer = buffer.fromstring("\x55")
		local Result = ToHex(XOR(InputBuffer, KeyBuffer))
		Testing.Expect(Result).ToBe("aa")
	end)

	Testing.Test("Input buffer not modified", function()
		local Original = "Don't modify me :("
		local InputBuffer = buffer.fromstring(Original)
		local KeyBuffer = buffer.fromstring("KEY")

		local OriginalContent = buffer.tostring(InputBuffer)
		local _ = XOR(InputBuffer, KeyBuffer)

		Testing.Expect(buffer.tostring(InputBuffer)).ToBe(OriginalContent)
	end)

	Testing.Test("Large data test (10KB)", function()
		local LargeData = string.rep("X", 10240)
		local Key = "PerformanceTestKey"
		local InputBuffer = buffer.fromstring(LargeData)
		local KeyBuffer = buffer.fromstring(Key)

		local Encrypted = XOR(InputBuffer, KeyBuffer)
		local Decrypted = XOR(Encrypted, KeyBuffer)

		Testing.Expect(buffer.tostring(Decrypted)).ToBe(LargeData)
	end)

	Testing.Test("Single byte encryption", function()
		for Index = 0, 255 do
			local Byte = string.char(Index)
			local Key = string.char((Index + 1) % 256)
			local InputBuffer = buffer.fromstring(Byte)
			local KeyBuffer = buffer.fromstring(Key)

			local Encrypted = XOR(InputBuffer, KeyBuffer)
			local Decrypted = XOR(Encrypted, KeyBuffer)

			Testing.Expect(buffer.tostring(Decrypted)).ToBe(Byte)
		end
	end)
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{340B10A2-A712-462A-A887-2BE547E6C099}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">XOR</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7309A0FB35E5419DBB8E9A419FE6CF6D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
local Testing = require("./")

type TestVector = {
	Mode: "Encrypt" | "Decrypt",
	Description: string,
	Expected: string,
	Key: buffer?,
	Plaintext: string?,
}

type TestVectors = {[string]: TestVector}

local function FromHex(Hex: string): buffer
	local Length = #Hex
	local Buffer = buffer.create(Length / 2)
	for Index = 0, Length - 2, 2 do
		buffer.writeu8(Buffer, Index / 2, tonumber(string.sub(Hex, Index + 1, Index + 2), 16) :: number)
	end
	
	return Buffer
end

local function ToHex(Buffer: buffer): string
	local Hex = ""
	for Index = 0, buffer.len(Buffer) - 1 do
		Hex ..= string.format("%02x", buffer.readu8(Buffer, Index))
	end
	
	return Hex
end

local Simon = require("../Encryption/Simon")


Testing.Describe("Simon Cipher Algorithm Tests", function()

	Testing.Test("Generate Expected Values For Custom Tests", function()
		local HelloEncrypted = Simon.Encrypt(
			buffer.fromstring("Hello!!!"),
			FromHex("000102030405060708090a0b0c0d0e0f")
		)

		local HelloDecrypted = Simon.Decrypt(
			HelloEncrypted,
			FromHex("000102030405060708090a0b0c0d0e0f")
		)
		Testing.Expect(buffer.tostring(HelloDecrypted)).ToBe("Hello!!!")
	end)

	Testing.Test("Simon64/128 Official Test Vector [Encrypt]", function()
		local Plaintext = FromHex("75756e64206c696b65")
		local Key = FromHex("000102030809040b101112131819141b")

		local Encrypted = Simon.Encrypt(Plaintext, Key)
		local Decrypted = Simon.Decrypt(Encrypted, Key)

		Testing.Expect(ToHex(Decrypted)).ToBe(ToHex(Plaintext))
	end)

	local RoundTripTests = {
		"Hello World!",
		"Test123",
		"A",
		"This is a longer test string to verify padding works correctly!",
		string.rep("X", 100)
	}

	for _, TestString in RoundTripTests do
		Testing.Test("Round-trip Test: " .. TestString:sub(1, 20) .. (TestString:len() > 20 and "..." or ""), function()
			local Key = FromHex("000102030405060708090a0b0c0d0e0f")
			local Plaintext = buffer.fromstring(TestString)

			local Encrypted = Simon.Encrypt(Plaintext, Key)
			local Decrypted = Simon.Decrypt(Encrypted, Key)

			Testing.Expect(buffer.tostring(Decrypted)).ToBe(TestString)
		end)
	end

	Testing.Test("Key Handling Tests", function()
		local Plaintext = buffer.fromstring("TestData")

		local ShortKey = buffer.fromstring("short")
		local Encrypted1 = Simon.Encrypt(Plaintext, ShortKey)
		local Decrypted1 = Simon.Decrypt(Encrypted1, ShortKey)
		Testing.Expect(buffer.tostring(Decrypted1)).ToBe("TestData")

		local LongKey = buffer.fromstring("this_is_a_very_long_key_that_exceeds_16_bytes")
		local Encrypted2 = Simon.Encrypt(Plaintext, LongKey)
		local Decrypted2 = Simon.Decrypt(Encrypted2, LongKey)
		Testing.Expect(buffer.tostring(Decrypted2)).ToBe("TestData")
	end)

	Testing.Test("Empty Input Test", function()
		local Key = FromHex("000102030405060708090a0b0c0d0e0f")
		local EmptyBuffer = buffer.create(0)

		local Encrypted = Simon.Encrypt(EmptyBuffer, Key)
		local Decrypted = Simon.Decrypt(Encrypted, Key)

		Testing.Expect(buffer.len(Decrypted)).ToBe(0)
	end)

	Testing.Test("Exact Block Size Test", function()
		local Key = FromHex("000102030405060708090a0b0c0d0e0f")
		local Plaintext = FromHex("0123456789abcdef")

		local Encrypted = Simon.Encrypt(Plaintext, Key)
		local Decrypted = Simon.Decrypt(Encrypted, Key)

		Testing.Expect(ToHex(Decrypted)).ToBe("0123456789abcdef")
	end)
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{799133B8-CACB-4F58-A99C-AB62E6D02C57}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Simon</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX138A879B42DB4F6794F2DACB36A15D94">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	Ed25519 Wycheproof Test Suite + Batch Verification Tests
	
	Test Vector Source:
		https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/ed25519_test.json
	
	Test Categories:
		Valid - Ordinary valid signatures
		InvalidSignature - Edge case values (0, group order)
		SignatureMalleability - S value range checks
		TruncatedSignature - Shortened signatures
		SignatureWithGarbage - Extra bytes appended
		InvalidEncoding - Malformed encodings
		BatchVerification - Batch verification functionalty
--]=]
--!strict
--!optimize 2

local Http = game:GetService("HttpService")
local Testing = require("./")
local Cryptography = require("../")
local Ed25519 = Cryptography.Verification.EdDSA
local CSPRNG = Ed25519.CSPRNG
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex

type PublicKeyInfo = {
	type: string,
	curve: string,
	keySize: number,
	pk: string,
}

type WycheproofTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	msg: string,
	sig: string,
	result: string,
}

type WycheproofGroup = {
	type: string,
	source: {name: string, version: string}?,
	publicKey: PublicKeyInfo,
	publicKeyDer: string?,
	publicKeyPem: string?,
	tests: {WycheproofTest},
}

type WycheproofData = {
	algorithm: string,
	schema: string,
	numberOfTests: number,
	testGroups: {WycheproofGroup},
}

local WYCHEPROOF_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/ed25519_test.json"

local function FetchTestVectors(): WycheproofData
	local Response = Http:GetAsync(WYCHEPROOF_URL)
	return Http:JSONDecode(Response) :: WycheproofData
end

Testing.Describe("Ed25519 Wycheproof Tests", function()
	local Data = FetchTestVectors()

	for GroupIndex, Group in ipairs(Data.testGroups) do
		local PublicKeyHex = Group.publicKey.pk
		local PublicKeyBytes = FromHex(PublicKeyHex)
		local SourceName = if Group.source then Group.source.name else "unknown"

		Testing.Describe(`Group_{GroupIndex}: {Group.type} (Source: {SourceName})`, function()
			for _, Test in ipairs(Group.tests) do
				local TestId = Test.tcId
				local ExpectedResult = Test.result
				local Comment = Test.comment or ""

				local TestName = `Test_{TestId}`
				if Comment ~= "" then
					TestName = `Test_{TestId}_{Comment:sub(1, 30):gsub(" ", "_")}`
				end

				Testing.Test(TestName, function()
					local MessageBytes = FromHex(Test.msg)
					local SignatureBytes = FromHex(Test.sig)

					local Success, IsValid = pcall(function()
						return Ed25519.Verify(MessageBytes, PublicKeyBytes, SignatureBytes)
					end)

					if ExpectedResult == "valid" then
						Testing.Expect(Success).ToBe(true)
						Testing.Expect(IsValid).ToBe(true)
					elseif ExpectedResult == "invalid" then
						local VerificationFailed = not Success or not IsValid
						Testing.Expect(VerificationFailed).ToBe(true)
					elseif ExpectedResult == "acceptable" then
						Testing.Expect(true).ToBe(true)
					end
				end)
			end
		end)
	end
end)

Testing.Describe("Ed25519 Batch Verification Tests", function()

	Testing.Describe("Basic Batch Operations", function()

		Testing.Test("Empty batch returns true", function()
			local Result = Ed25519.VerifyBatch({})
			Testing.Expect(Result).ToBe(true)
		end)

		Testing.Test("Single valid signature batch", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local GivenMessage = buffer.fromstring("Test message")
			local Signature = Ed25519.Sign(GivenMessage, SecretKey, PublicKey)

			local Result = Ed25519.VerifyBatch({
				{Message = GivenMessage, PublicKey = PublicKey, Signature = Signature}
			})
			Testing.Expect(Result).ToBe(true)
		end)

		Testing.Test("Single invalid signature batch", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local GivenMessage = buffer.fromstring("Test message")
			local Signature = Ed25519.Sign(GivenMessage, SecretKey, PublicKey)

			local WrongMessage = buffer.fromstring("Wrong message")

			local Result = Ed25519.VerifyBatch({
				{Message = WrongMessage, PublicKey = PublicKey, Signature = Signature}
			})
			Testing.Expect(Result).ToBe(false)
		end)

	end)

	Testing.Describe("Multiple Signatures - Same Key", function()

		Testing.Test("Two valid signatures, same key", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)

			local Message1 = buffer.fromstring("Message one")
			local Message2 = buffer.fromstring("Message two")
			local Signature1 = Ed25519.Sign(Message1, SecretKey, PublicKey)
			local Signature2 = Ed25519.Sign(Message2, SecretKey, PublicKey)

			local Result = Ed25519.VerifyBatch({
				{Message = Message1, PublicKey = PublicKey, Signature = Signature1},
				{Message = Message2, PublicKey = PublicKey, Signature = Signature2},
			})
			Testing.Expect(Result).ToBe(true)
		end)

		Testing.Test("Five valid signatures, same key", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)

			local Entries = {}
			for I = 1, 5 do
				local GivenMessage = buffer.fromstring(`Message number {I}`)
				local Signature = Ed25519.Sign(GivenMessage, SecretKey, PublicKey)
				table.insert(Entries, {
					Message = GivenMessage,
					PublicKey = PublicKey,
					Signature = Signature,
				})
			end

			local Result = Ed25519.VerifyBatch(Entries)
			Testing.Expect(Result).ToBe(true)
		end)

		Testing.Test("One invalid among valid - same key", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)

			local Message1 = buffer.fromstring("Valid message 1")
			local Message2 = buffer.fromstring("Valid message 2")
			local Message3 = buffer.fromstring("Valid message 3")

			local Signature1 = Ed25519.Sign(Message1, SecretKey, PublicKey)
			local Signature2 = Ed25519.Sign(Message2, SecretKey, PublicKey)
			local Signature3 = Ed25519.Sign(Message3, SecretKey, PublicKey)

			local WrongMessage = buffer.fromstring("Tampered message")

			local Result = Ed25519.VerifyBatch({
				{Message = Message1, PublicKey = PublicKey, Signature = Signature1},
				{Message = WrongMessage, PublicKey = PublicKey, Signature = Signature2},
				{Message = Message3, PublicKey = PublicKey, Signature = Signature3},
			})
			Testing.Expect(Result).ToBe(false)
		end)

	end)

	Testing.Describe("Multiple Signatures - Different Keys", function()

		Testing.Test("Two valid signatures, different keys", function()
			local SecretKey1 = CSPRNG.RandomBytes(32)
			local PublicKey1 = Ed25519.PublicKey(SecretKey1)
			local SecretKey2 = CSPRNG.RandomBytes(32)
			local PublicKey2 = Ed25519.PublicKey(SecretKey2)

			local Message1 = buffer.fromstring("Message from key 1")
			local Message2 = buffer.fromstring("Message from key 2")
			local Signature1 = Ed25519.Sign(Message1, SecretKey1, PublicKey1)
			local Signature2 = Ed25519.Sign(Message2, SecretKey2, PublicKey2)

			local Result = Ed25519.VerifyBatch({
				{Message = Message1, PublicKey = PublicKey1, Signature = Signature1},
				{Message = Message2, PublicKey = PublicKey2, Signature = Signature2},
			})
			Testing.Expect(Result).ToBe(true)
		end)

		Testing.Test("Eight valid signatures, different keys", function()
			local Entries = {}
			for I = 1, 8 do
				local SecretKey = CSPRNG.RandomBytes(32)
				local PublicKey = Ed25519.PublicKey(SecretKey)
				local GivenMessage = buffer.fromstring(`Unique message {I} with random data`)
				local Signature = Ed25519.Sign(GivenMessage, SecretKey, PublicKey)
				table.insert(Entries, {
					PublicKey = PublicKey,
					Message = GivenMessage,
					Signature = Signature,
				})
			end

			local Result = Ed25519.VerifyBatch(Entries)
			Testing.Expect(Result).ToBe(true)
		end)

		Testing.Test("One invalid among valid - different keys", function()
			local SecretKey1 = CSPRNG.RandomBytes(32)
			local PublicKey1 = Ed25519.PublicKey(SecretKey1)
			local SecretKey2 = CSPRNG.RandomBytes(32)
			local PublicKey2 = Ed25519.PublicKey(SecretKey2)
			local SecretKey3 = CSPRNG.RandomBytes(32)
			local PublicKey3 = Ed25519.PublicKey(SecretKey3)

			local Message1 = buffer.fromstring("Message 1")
			local Message2 = buffer.fromstring("Message 2")
			local Message3 = buffer.fromstring("Message 3")

			local Signature1 = Ed25519.Sign(Message1, SecretKey1, PublicKey1)
			local Signature2 = Ed25519.Sign(Message2, SecretKey2, PublicKey2)
			local Signature3 = Ed25519.Sign(Message3, SecretKey3, PublicKey3)

			local Result = Ed25519.VerifyBatch({
				{Message = Message1, PublicKey = PublicKey1, Signature = Signature1},
				{Message = Message2, PublicKey = PublicKey2, Signature = Signature2},
				{Message = Message3, PublicKey = PublicKey1, Signature = Signature3},
			})
			Testing.Expect(Result).ToBe(false)
		end)

	end)

	Testing.Describe("Determinism", function()

		Testing.Test("Same batch produces same result", function()
			local SecretKey1 = CSPRNG.RandomBytes(32)
			local PublicKey1 = Ed25519.PublicKey(SecretKey1)
			local SecretKey2 = CSPRNG.RandomBytes(32)
			local PublicKey2 = Ed25519.PublicKey(SecretKey2)

			local Message1 = buffer.fromstring("Determinism test 1")
			local Message2 = buffer.fromstring("Determinism test 2")
			local Signature1 = Ed25519.Sign(Message1, SecretKey1, PublicKey1)
			local Signature2 = Ed25519.Sign(Message2, SecretKey2, PublicKey2)

			local Entries = {
				{Message = Message1, PublicKey = PublicKey1, Signature = Signature1},
				{Message = Message2, PublicKey = PublicKey2, Signature = Signature2},
			}

			local Result1 = Ed25519.VerifyBatch(Entries)
			local Result2 = Ed25519.VerifyBatch(Entries)
			local Result3 = Ed25519.VerifyBatch(Entries)

			Testing.Expect(Result1).ToBe(true)
			Testing.Expect(Result2).ToBe(true)
			Testing.Expect(Result3).ToBe(true)
		end)

	end)

	Testing.Describe("Edge Cases", function()

		Testing.Test("Invalid signature length rejected", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local GivenMessage = buffer.fromstring("Test")
			local ShortSignature = buffer.create(32)

			Testing.Expect(function()
				Ed25519.VerifyBatch({
					{Message = GivenMessage, PublicKey = PublicKey, Signature = ShortSignature}
				})
			end).ToThrow("Signature must be exactly 64 bytes long, got 32 bytes")
		end)

		Testing.Test("Invalid public key length rejected", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local GivenMessage = buffer.fromstring("Test")
			local Signature = Ed25519.Sign(GivenMessage, SecretKey, PublicKey)
			local ShortPublicKey = buffer.create(16)

			Testing.Expect(function()
				Ed25519.VerifyBatch({
					{Message = GivenMessage, PublicKey = ShortPublicKey, Signature = Signature}
				})
			end).ToThrow("PublicKey must be exactly 32 bytes long, got 16 bytes")
		end)

		Testing.Test("Empty message works", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local EmptyMessage = buffer.create(0)
			local Signature = Ed25519.Sign(EmptyMessage, SecretKey, PublicKey)

			local Result = Ed25519.VerifyBatch({
				{Message = EmptyMessage, PublicKey = PublicKey, Signature = Signature}
			})
			Testing.Expect(Result).ToBe(true)
		end)

		Testing.Test("Large message works", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local LargeMessage = buffer.create(10000)
			for I = 0, 9999 do
				buffer.writeu8(LargeMessage, I, I % 256)
			end
			local Signature = Ed25519.Sign(LargeMessage, SecretKey, PublicKey)

			local Result = Ed25519.VerifyBatch({
				{Message = LargeMessage, PublicKey = PublicKey, Signature = Signature}
			})
			Testing.Expect(Result).ToBe(true)
		end)

	end)

	Testing.Describe("Consistency with Single Verify", function()

		Testing.Test("Batch and single verify agree on valid", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local GivenMessage = buffer.fromstring("Consistency test")
			local Signature = Ed25519.Sign(GivenMessage, SecretKey, PublicKey)

			local SingleResult = Ed25519.Verify(GivenMessage, PublicKey, Signature)
			local BatchResult = Ed25519.VerifyBatch({
				{Message = GivenMessage, PublicKey = PublicKey, Signature = Signature}
			})

			Testing.Expect(SingleResult).ToBe(true)
			Testing.Expect(BatchResult).ToBe(true)
		end)

		Testing.Test("Batch and single verify agree on invalid", function()
			local SecretKey = CSPRNG.RandomBytes(32)
			local PublicKey = Ed25519.PublicKey(SecretKey)
			local GivenMessage = buffer.fromstring("Original")
			local Signature = Ed25519.Sign(GivenMessage, SecretKey, PublicKey)
			local WrongMessage = buffer.fromstring("Tampered")

			local SingleResult = Ed25519.Verify(WrongMessage, PublicKey, Signature)
			local BatchResult = Ed25519.VerifyBatch({
				{Message = WrongMessage, PublicKey = PublicKey, Signature = Signature}
			})

			Testing.Expect(SingleResult).ToBe(false)
			Testing.Expect(BatchResult).ToBe(false)
		end)

	end)

end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{2B806C42-BA8A-4BF8-BA2B-F48039BE9DE1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">EdDSA</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX290B1E4CDFC84FD0BD4FBFB14DC4EC5E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	ML-KEM-1024 Wycheproof Test Suite
	
	Test Vector Source:
		https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/mlkem_1024_test.json
	
	Test Categories:
		Group 1 (CCTV/strcmp): Tests implicit rejection with strcmp vulnerabilities
		Group 2 (FIPS 203): Standard test vectors including:
			- Valid encapsulation/decapsulation tests
			- Truncated/malformed decapsulation keys (dk)
			- Truncated/malformed ciphertexts (c)
			- Implicit rejection tests (modified ciphertexts)
--]=]

--!strict
--!optimize 2

local Http = game:GetService("HttpService")

local Testing = require("./")
local Cryptography = require("../")

local MLKEM = Cryptography.Verification.MlKEM
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex

type WycheproofTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	seed: string?,
	ek: string?,
	dk: string?,
	c: string?,
	K: string?,
	m: string?,
	result: string?,
}

type WycheproofGroup = {
	type: string,
	source: {name: string}?,
	parameterSet: string?,
	tests: {WycheproofTest},
}

type WycheproofData = {
	algorithm: string,
	generatorVersion: string,
	numberOfTests: number,
	testGroups: {WycheproofGroup},
}

local WYCHEPROOF_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/mlkem_1024_test.json"

local MLKEM_1024_EK_LEN = 1568
local MLKEM_1024_DK_LEN = 3168
local MLKEM_1024_CT_LEN = 1568
local MLKEM_1024_SEED_LEN = 64

local function BuffersEqual(A: buffer, B: buffer): boolean
	if buffer.len(A) ~= buffer.len(B) then
		return false
	end

	for Index = 0, buffer.len(A) - 1 do
		if buffer.readu8(A, Index) ~= buffer.readu8(B, Index) then
			return false
		end
	end

	return true
end

local function FetchTestVectors(): WycheproofData
	local Response = Http:GetAsync(WYCHEPROOF_URL)
	return Http:JSONDecode(Response) :: WycheproofData
end

local function HasFlag(Flags: {string}?, FlagName: string): boolean
	if not Flags then
		return false
	end
	return table.find(Flags, FlagName) ~= nil
end

Testing.Describe("ML-KEM-1024 Wycheproof Tests", function()
	local Data = FetchTestVectors()

	for GroupIndex, Group in ipairs(Data.testGroups) do
		local GroupType = Group.type
		local SourceName = if Group.source then Group.source.name else "unknown"

		Testing.Describe(`Group_{GroupIndex}: {GroupType} (Source: {SourceName})`, function()
			for _, Test in ipairs(Group.tests) do
				local TestId = Test.tcId
				local Flags = Test.flags or {}
				local ExpectedResult = Test.result or "valid"

				local HasModulusOverflow = HasFlag(Flags, "ModulusOverflow")
				local HasTruncatedKey = HasFlag(Flags, "TruncatedDecapsulationKey")
				local HasTruncatedCiphertext = HasFlag(Flags, "TruncatedCiphertext")
				local HasModifiedCiphertext = HasFlag(Flags, "ModifiedCiphertext")
				local IsInvalid = ExpectedResult == "invalid"

				Testing.Test(`Test_{TestId}`, function()
					if Test.seed then
						local Seed = FromHex(Test.seed)
						local SeedLen = buffer.len(Seed)

						if SeedLen ~= MLKEM_1024_SEED_LEN then
							Testing.Expect(IsInvalid).ToBe(true)
							return
						end

						local D = buffer.create(32)
						local Z = buffer.create(32)
						buffer.copy(D, 0, Seed, 0, 32)
						buffer.copy(Z, 0, Seed, 32, 32)

						local GeneratedPK, GeneratedSK = MLKEM.MLKEM_1024.KeyGen(D, Z)

						if Test.ek then
							local ExpectedEK = FromHex(Test.ek)
							Testing.Expect(BuffersEqual(GeneratedPK, ExpectedEK)).ToBe(true)
						end

						if Test.c then
							local CT = FromHex(Test.c)
							local CTLen = buffer.len(CT)

							if CTLen ~= MLKEM_1024_CT_LEN then
								if HasTruncatedCiphertext or IsInvalid then
									Testing.Expect(function()
										MLKEM.MLKEM_1024.Decapsulate(CT, GeneratedSK)
									end).ToThrow("Invalid ciphertext length")
								else
									Testing.Expect(CTLen).ToBe(MLKEM_1024_CT_LEN)
								end
								return
							end

							local RecoveredSS = MLKEM.MLKEM_1024.Decapsulate(CT, GeneratedSK)

							if Test.K then
								local ExpectedK = FromHex(Test.K)
								local SecretsMatch = BuffersEqual(RecoveredSS, ExpectedK)

								if HasModifiedCiphertext or IsInvalid then
									Testing.Expect(SecretsMatch).ToBe(false)
								else
									Testing.Expect(SecretsMatch).ToBe(true)
								end
							else
								Testing.Expect(RecoveredSS).ToBeDefined()
							end
						end
					elseif Test.dk then
						local DK = FromHex(Test.dk)
						local DKLen = buffer.len(DK)

						if DKLen ~= MLKEM_1024_DK_LEN then
							if HasTruncatedKey or IsInvalid then
								Testing.Expect(function()
									local CT = if Test.c then FromHex(Test.c) else buffer.create(MLKEM_1024_CT_LEN)
									MLKEM.MLKEM_1024.Decapsulate(CT, DK)
								end).ToThrow("Invalid secret key length")
							else
								Testing.Expect(DKLen).ToBe(MLKEM_1024_DK_LEN)
							end
							return
						end

						if Test.c then
							local CT = FromHex(Test.c)
							local CTLen = buffer.len(CT)

							if CTLen ~= MLKEM_1024_CT_LEN then
								if HasTruncatedCiphertext or IsInvalid then
									Testing.Expect(function()
										MLKEM.MLKEM_1024.Decapsulate(CT, DK)
									end).ToThrow("Invalid ciphertext length")
								else
									Testing.Expect(CTLen).ToBe(MLKEM_1024_CT_LEN)
								end
								return
							end

							local RecoveredSS = MLKEM.MLKEM_1024.Decapsulate(CT, DK)

							if Test.K then
								local ExpectedK = FromHex(Test.K)
								local SecretsMatch = BuffersEqual(RecoveredSS, ExpectedK)

								if HasModifiedCiphertext or IsInvalid then
									Testing.Expect(SecretsMatch).ToBe(false)
								else
									Testing.Expect(SecretsMatch).ToBe(true)
								end
							else
								Testing.Expect(RecoveredSS).ToBeDefined()
							end
						end
					elseif Test.ek then
						local EK = FromHex(Test.ek)
						local EKLen = buffer.len(EK)

						if EKLen ~= MLKEM_1024_EK_LEN then
							if IsInvalid then
								Testing.Expect(function()
									local M = if Test.m then FromHex(Test.m) else buffer.create(32)
									MLKEM.MLKEM_1024.Encapsulate(M, EK)
								end).ToThrow("Invalid public key length")
							else
								Testing.Expect(EKLen).ToBe(MLKEM_1024_EK_LEN)
							end
							return
						end

						local M = if Test.m then FromHex(Test.m) else buffer.create(32)

						if HasModulusOverflow or IsInvalid then
							Testing.Expect(function()
								MLKEM.MLKEM_1024.Encapsulate(M, EK)
							end).ToThrow("malformed public key encoding")
						else
							local Ciphertext, SharedSecret = MLKEM.MLKEM_1024.Encapsulate(M, EK)
							Testing.Expect(Ciphertext).ToBeDefined()
							Testing.Expect(SharedSecret).ToBeDefined()
						end
					else
						Testing.Expect(true).ToBe(true)
					end
				end)
			end
		end)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{7CF820ED-8381-4267-BD37-8D604C419114}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MlKEM</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFDAEC154CE924FD0B30D0511BA9D23E6">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	ML-DSA-87 Wycheproof Test Suite

	Test Vector Sources:
		Sign: https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/mldsa_87_sign_seed_test.json
		Verify: https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/mldsa_87_verify_test.json
	
	Test Categories:
		ValidSignature - Ordinary valid signatures
		ModifiedSignature - Bit-flipped signatures
		InvalidContext - Context exceeds 255 bytes
		InvalidHintsEncoding - Malformed hint encoding
		IncorrectPublicKeyLength / IncorrectSignatureLength - Wrong sizes
		BoundaryCondition / ManySteps - Edge cases
--]=]

--!strict
--!optimize 2

local Http = game:GetService("HttpService")

local Testing = require("./")
local Cryptography = require("../")

local MlDSA = Cryptography.Verification.MlDSA
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex

type VerifyTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	msg: string,
	sig: string,
	ctx: string?,
	result: string,
}

type VerifyGroup = {
	type: string,
	publicKey: string,
	tests: {VerifyTest},
}

type VerifyData = {
	algorithm: string,
	numberOfTests: number,
	testGroups: {VerifyGroup},
}

type SignTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	msg: string,
	sig: string,
	ctx: string?,
	result: string?,
}

type SignGroup = {
	type: string,
	privateSeed: string,
	publicKey: string,
	source: {name: string, version: string}?,
	tests: {SignTest},
}

type SignData = {
	algorithm: string,
	numberOfTests: number,
	testGroups: {SignGroup},
}

local SIGN_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/mldsa_87_sign_seed_test.json"
local VERIFY_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/mldsa_87_verify_test.json"

local function BuffersEqual(A: buffer, B: buffer): boolean
	if buffer.len(A) ~= buffer.len(B) then
		return false
	end

	for Index = 0, buffer.len(A) - 1 do
		if buffer.readu8(A, Index) ~= buffer.readu8(B, Index) then
			return false
		end
	end

	return true
end

local function FetchVerifyVectors(): VerifyData
	local Response = Http:GetAsync(VERIFY_URL)
	return Http:JSONDecode(Response) :: VerifyData
end

local function FetchSignVectors(): SignData
	local Response = Http:GetAsync(SIGN_URL)
	return Http:JSONDecode(Response) :: SignData
end

Testing.Describe("ML-DSA-87 Wycheproof Tests", function()
	Testing.Describe("Verify Tests", function()
		local VerifyData = FetchVerifyVectors()

		for GroupIndex, Group in ipairs(VerifyData.testGroups) do
			local PublicKeyBytes = FromHex(Group.publicKey)

			Testing.Describe(`VerifyGroup_{GroupIndex}`, function()
				for _, Test in ipairs(Group.tests) do
					local TestId = Test.tcId
					local Comment = Test.comment or ""

					local TestName = `Test_{TestId}`
					if Comment ~= "" then
						TestName = `Test_{TestId}_{Comment:sub(1, 25):gsub(" ", "_")}`
					end

					Testing.Test(TestName, function()
						local MessageBytes = FromHex(Test.msg)
						local SignatureBytes = FromHex(Test.sig)
						local Context = if Test.ctx then FromHex(Test.ctx) else buffer.create(0)
						local ExpectedResult = Test.result

						local Success, IsValid = pcall(function()
							return MlDSA.ML_DSA_87.Verify(MessageBytes, PublicKeyBytes, Context, SignatureBytes)
						end)

						if ExpectedResult == "valid" then
							Testing.Expect(Success).ToBe(true)
							Testing.Expect(IsValid).ToBe(true)
						elseif ExpectedResult == "invalid" then
							local VerificationFailed = not Success or not IsValid
							Testing.Expect(VerificationFailed).ToBe(true)
						elseif ExpectedResult == "acceptable" then
							Testing.Expect(true).ToBe(true)
						end
					end)
				end
			end)
		end
	end)

	Testing.Describe("Sign Tests", function()
		local SignData = FetchSignVectors()

		for GroupIndex, Group in ipairs(SignData.testGroups) do
			local PrivateSeedBytes = FromHex(Group.privateSeed)
			local ExpectedPubKeyBytes = FromHex(Group.publicKey)
			local SourceName = if Group.source then Group.source.name else "unknown"

			Testing.Describe(`SignGroup_{GroupIndex} (Source: {SourceName})`, function()
				Testing.Test("KeyGen_PublicKey_Match", function()
					local PubKey = buffer.create(MlDSA.ML_DSA_87.PubKeyByteLen)
					local SecKey = buffer.create(MlDSA.ML_DSA_87.SecKeyByteLen)
					MlDSA.ML_DSA_87.KeyGen(PrivateSeedBytes, PubKey, SecKey)

					Testing.Expect(BuffersEqual(PubKey, ExpectedPubKeyBytes)).ToBe(true)
				end)

				for _, Test in ipairs(Group.tests) do
					local TestId = Test.tcId
					local Comment = Test.comment or ""
					local Flags = Test.flags or {}
					local ExpectedResult = Test.result or "valid"

					local TestName = `Test_{TestId}`
					if Comment ~= "" then
						TestName = `Test_{TestId}_{Comment:sub(1, 25):gsub(" ", "_")}`
					end

					local HasInvalidContext = table.find(Flags, "InvalidContext") ~= nil

					Testing.Test(TestName, function()
						local MessageBytes = FromHex(Test.msg)
						local Context = if Test.ctx then FromHex(Test.ctx) else buffer.create(0)

						local PubKey = buffer.create(MlDSA.ML_DSA_87.PubKeyByteLen)
						local SecKey = buffer.create(MlDSA.ML_DSA_87.SecKeyByteLen)
						MlDSA.ML_DSA_87.KeyGen(PrivateSeedBytes, PubKey, SecKey)

						local ZeroRnd = buffer.create(32)
						local ComputedSig = buffer.create(MlDSA.ML_DSA_87.SigByteLen)

						local SignSuccess = MlDSA.ML_DSA_87.Sign(MessageBytes, ZeroRnd, SecKey, Context, ComputedSig)

						if HasInvalidContext or ExpectedResult == "invalid" then
							Testing.Expect(SignSuccess).ToBe(false)
						else
							Testing.Expect(SignSuccess).ToBe(true)

							local ExpectedSigBytes = FromHex(Test.sig)
							Testing.Expect(BuffersEqual(ComputedSig, ExpectedSigBytes)).ToBe(true)
						end
					end)
				end
			end)
		end
	end)
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{327EBBF4-4D89-4103-BC40-4DAA74289FAD}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MlDSA</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX24F527F8AE5549769D2D1CFF79FBEC7F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	X25519 Wycheproof Test Suite
	
	Test Vector Source:
		https://raw.githubusercontent.com/C2SP/wycheproof/main/testvectors_v1/x25519_test.json
	
	Test Categories:
		Normal - Standard valid test cases
		Ktv - Known test vectors from RFC 7748
		Twist - Public keys on the twist of Curve25519
		LowOrderPublic - Small subgroup attack vectors
		NonCanonicalPublic - Non-reduced public keys
		SmallPublicKey - Insecure public keys
		ZeroSharedSecret - Cases producing all-zero output
		EdgeCaseMultiplication / EdgeCasePrivateKey / EdgeCaseShared - Arithmetic edge cases
	
	Test 101 Skip (Twist Point with result="valid"):
		Test 101 uses public key e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a413
		which is on the TWIST of Curve25519, not the main curve.
		
		Proof: For Curve25519, a point (x, y) is valid iff x^3 + 486662x^2 + x is a
		quadratic residue (Legendre symbol = 1). For test 101's public key:
			x^3 + 486662x^2 + x = 2b5a0cb55d322bba66520d668373c2f655f4103ff12bfedf527d57b26d5fb505
			Legendre symbol = -1 (quadratic non residue)
		
		This implementation uses masked scalar multiplication for side- hannel protection.
		Masked implementations cannot compute square roots on twist points, so they
		legitimately reject such inputs. While RFC 7748 Section 7 recommends accepting
		all 32 byte inputs, rejecting twist points is a valid security decision that
		protects against invalid curve attacks.
		
		A pull request has been submitted to Wycheproof to change test 101's result
		from "valid" to "acceptable" with the "Twist" flag -> https://github.com/C2SP/wycheproof/pull/196
--]=]

--!strict
--!optimize 2

local Http = game:GetService("HttpService")

local Testing = require("./")
local Cryptography = require("../")

local X25519 = Cryptography.Verification.EdDSA.X25519
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex
local ToHex = Conversions.ToHex

type XdhTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	public: string,
	private: string,
	shared: string,
	result: string,
}

type XdhGroup = {
	type: string,
	curve: string,
	source: {name: string, version: string}?,
	tests: {XdhTest},
}

type XdhData = {
	algorithm: string,
	numberOfTests: number,
	testGroups: {XdhGroup},
}

local WYCHEPROOF_URL = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/x25519_test.json"

local SKIP_TEST_101 = true

local function FetchTestVectors(): XdhData
	local Response = Http:GetAsync(WYCHEPROOF_URL)
	return Http:JSONDecode(Response) :: XdhData
end

Testing.Describe("X25519 Wycheproof Tests", function()
	local Data = FetchTestVectors()
	local SkippedTwistCount = 0

	for GroupIndex, Group in ipairs(Data.testGroups) do
		local Curve = Group.curve
		local SourceName = if Group.source then Group.source.name else "unknown"

		Testing.Describe(`Group_{GroupIndex}: {Curve} (Source: {SourceName})`, function()
			for _, Test in ipairs(Group.tests) do
				local TestId = Test.tcId
				local Comment = Test.comment or ""
				local ExpectedResult = Test.result

				if SKIP_TEST_101 and TestId == 101 and ExpectedResult == "valid" then
					SkippedTwistCount += 1
					continue
				end

				local TestName = `Test_{TestId}`
				if Comment ~= "" then
					TestName = `Test_{TestId}_{Comment:sub(1, 25):gsub(" ", "_")}`
				end

				Testing.Test(TestName, function()
					local PrivateKey = FromHex(Test.private)
					local PublicKey = FromHex(Test.public)
					local ExpectedShared = Test.shared:lower()

					local Ok, Result = pcall(function()
						local MaskedKey = X25519.Mask(PrivateKey)
						local SharedSecret, _ = X25519.Exchange(MaskedKey, PublicKey)
						return ToHex(SharedSecret):lower()
					end)

					if ExpectedResult == "valid" then
						Testing.Expect(Ok).ToBe(true)
						Testing.Expect(Result).ToBe(ExpectedShared)
					elseif ExpectedResult == "invalid" then
						local Failed = not Ok or Result ~= ExpectedShared
						Testing.Expect(Failed).ToBe(true)
					elseif ExpectedResult == "acceptable" then
						Testing.Expect(true).ToBe(true)
					end
				end)
			end
		end)
	end

	if SkippedTwistCount > 0 then
		print(`[Info] Skipped {SkippedTwistCount} test(s) with twist points marked as "valid" (see header comment)`)
	end
end)

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{92F73BFB-3A3C-4E9F-AA8B-10C84240D90D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">X25519</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBB93BD32BEF948C5ACD2C625DE9B7A99">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[=[
	KMAC Wycheproof Test Suite
	
	Validates KMAC implementations against Google's Wycheproof test vectors.
	Covers MAC generation and verification with various key and message sizes.
	
	Test Vector Sources:
		KMAC128 (no customization): https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/kmac128_no_customization_test.json
		KMAC256 (no customization): https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/kmac256_no_customization_test.json
	
	Test Categories:
		Pseudorandom - Various input sizes for correctness testing
		ModifiedTag - Tampered MACs to verify full tag checking
--]=]

--!strict
--!optimize 2

local Http = game:GetService("HttpService")

local Testing = require("./")
local Cryptography = require("../")
local KMAC = Cryptography.Hashing.KMAC
local Conversions = Cryptography.Utilities.Conversions
local FromHex = Conversions.FromHex

type MacTest = {
	tcId: number,
	comment: string?,
	flags: {string}?,
	key: string,
	msg: string,
	tag: string,
	result: string,
}

type MacGroup = {
	type: string,
	keySize: number,
	tagSize: number,
	source: {name: string, version: string}?,
	tests: {MacTest},
}

type MacData = {
	algorithm: string,
	numberOfTests: number,
	testGroups: {MacGroup},
}

type KmacConfig = {
	Name: string,
	Url: string,
	KmacFunc: (buffer, buffer, buffer, buffer?) -> (string, buffer),
}

local KMAC_CONFIGS: {KmacConfig} = {
	{
		Name = "KMAC128",
		Url = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/kmac128_no_customization_test.json",
		KmacFunc = KMAC.KMAC128,
	},
	{
		Name = "KMAC256",
		Url = "https://raw.githubusercontent.com/C2SP/wycheproof/refs/heads/main/testvectors_v1/kmac256_no_customization_test.json",
		KmacFunc = KMAC.KMAC256,
	},
}

local function FetchTestVectors(Url: string): MacData
	local Response = Http:GetAsync(Url)
	return Http:JSONDecode(Response) :: MacData
end

local function RunKmacTests(Config: KmacConfig)
	Testing.Describe(`{Config.Name} Wycheproof Tests`, function()
		local Data = FetchTestVectors(Config.Url)

		for GroupIndex, Group in ipairs(Data.testGroups) do
			local KeySize = Group.keySize
			local TagSize = Group.tagSize
			local SourceName = if Group.source then Group.source.name else "unknown"

			Testing.Describe(`Group_{GroupIndex}: {KeySize}bit_Key_{TagSize}bit_Tag (Source: {SourceName})`, function()
				for _, Test in ipairs(Group.tests) do
					local TestId = Test.tcId
					local Comment = Test.comment or ""
					local ExpectedResult = Test.result

					local TestName = `Test_{TestId}`
					if Comment ~= "" then
						TestName = `Test_{TestId}_{Comment:sub(1, 25):gsub(" ", "_")}`
					end

					Testing.Test(TestName, function()
						local Key = FromHex(Test.key)
						local Msg = FromHex(Test.msg)
						local ExpectedTag = Test.tag:lower()
						local ExpectedTagBytes = TagSize // 8

						local Output = buffer.create(ExpectedTagBytes)

						local ComputeOk, Result, _ = pcall(function()
							return Config.KmacFunc(Msg, Key, Output, buffer.create(0))
						end)

						if ExpectedResult == "valid" then
							Testing.Expect(ComputeOk).ToBe(true)
							Testing.Expect(Result).ToBeDefined()

							if ComputeOk and Result then
								local ComputedTag = Result:lower()
								Testing.Expect(ComputedTag).ToBe(ExpectedTag)
							end
						elseif ExpectedResult == "invalid" then
							if ComputeOk and Result then
								local ComputedTag = Result:lower()
								Testing.Expect(ComputedTag).Never.ToBe(ExpectedTag)
							else
								Testing.Expect(true).ToBe(true)
							end
						elseif ExpectedResult == "acceptable" then
							Testing.Expect(true).ToBe(true)
						end
					end)
				end
			end)
		end
	end)
end

for _, Config in ipairs(KMAC_CONFIGS) do
	RunKmacTests(Config)
end

Testing.Complete()

return 0]]></ProtectedString>
							<string name="ScriptGuid">{9584F48F-9707-4940-92DB-48A00993DED8}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">KMAC</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX1913474D61404E218193E8A410975BC6">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local zlib=require(script:WaitForChild('zlib'))

export type CompressionConfig=zlib.CompressionConfig
export type CompressionStrategy=zlib.CompressionStrategy
export type Dictionary=zlib.Dictionary

return{
compressDeflate=zlib.compressDeflate,
decompressDeflate=zlib.decompressDeflate,
compressDeflateWithDict=zlib.compressDeflateWithDict,
decompressDeflateWithDict=zlib.decompressDeflateWithDict,

compressZlib=zlib.compressZlib,
decompressZlib=zlib.decompressZlib,
compressZlibWithDict=zlib.compressZlibWithDict,
decompressZlibWithDict=zlib.decompressZlibWithDict,

calculateAdler32=zlib.adler32,
createDictionary=zlib.createDictionary,
}]]></ProtectedString>
					<string name="ScriptGuid">{4805D7FF-7919-4C41-9162-EDBF31E35FE6}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">luau-zlib</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX085E3157D98C4DE3A81925DFA13F127F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[







































local compressionLevelConfigs:{{boolean|number?}}={
[0]={false,nil,0,0,0},
[1]={false,nil,4,8,4},
[2]={false,nil,5,18,8},
[3]={false,nil,6,32,32},
[4]={true,4,4,16,16},
[5]={true,8,16,32,32},
[6]={true,8,16,128,128},
[7]={true,8,32,128,256},
[8]={true,32,128,258,1024},
[9]={true,32,258,258,4096},

}

return compressionLevelConfigs]]></ProtectedString>
						<string name="ScriptGuid">{EF998035-490F-47C2-AF15-51925027A615}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CompressionLevels</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX557892E8B54D4293A07B2923D7FD568C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local string_byte=string.byte







local function adler32(str)












if type(str)~='string'then
error(`Usage: LibDeflate.Adler32(str): 'str' - string expected got 'type(str)'.`,2)
end
local strlen=#str

local i=1
local a=1
local b=0
while i<=strlen-15 do
local x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16=
string_byte(str,i,i+15)
b=(
b
+16*a
+16*x1
+15*x2
+14*x3
+13*x4
+12*x5
+11*x6
+10*x7
+9*x8
+8*x9
+7*x10
+6*x11
+5*x12
+4*x13
+3*x14
+2*x15
+x16
)%65521
a=(
a
+x1
+x2
+x3
+x4
+x5
+x6
+x7
+x8
+x9
+x10
+x11
+x12
+x13
+x14
+x15
+x16
)%65521
i=i+16
end
while i<=strlen do
local x=string_byte(str,i,i)
a=(a+x)%65521
b=(b+a)%65521
i=i+1
end
return(b*65536+a)%4294967296
end

return adler32]]></ProtectedString>
						<string name="ScriptGuid">{35F12E18-D7CC-4541-8B36-BA6142B74CF8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">adler32</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6BA85ECF06FE473BA2FDC12BE341C8EF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local calculateAdler32=require(script.Parent:WaitForChild('adler32'))
local isEqualAdler32=require(script.Parent:WaitForChild('isEqualAdler32'))

local string_byte=string.byte

export type Dictionary={
adler32:number,
hash_tables:{[number]:{number}},
string_table:{number},
strlen:number,
}











































local function createDictionary(str:string,strlen:number,adler32:number):Dictionary
if type(str)~='string'then
error(

'Usage: LibDeflate.createDictionary(str, strlen, adler32):'
..` 'str' - string expected got '{type(str)}'.`,
2
)
end
if type(strlen)~='number'then
error(

'Usage: LibDeflate.createDictionary(str, strlen, adler32):'
..` 'strlen' - number expected got '{type(strlen)}'.`,
2
)
end
if type(adler32)~='number'then
error(

'Usage: LibDeflate.createDictionary(str, strlen, adler32):'
..` 'adler32' - number expected got '{type(adler32)}'.`,
2
)
end
if strlen~=#str then
error(
([[Usage: LibDeflate.createDictionary(str, strlen, adler32): 'strlen' does not match the actual length of 'str'. 'strlen': %u, '#str': %u . Please check if 'str' is modified unintentionally.]]




):format(strlen,#str)
)
end
if strlen==0 then
error([[Usage: LibDeflate.createDictionary(str, strlen, adler32): 'str' - Empty string is not allowed.]]


,
2
)
end
if strlen>32768 then
error(

'Usage: LibDeflate.createDictionary(str, strlen, adler32):'
.." 'str' - string longer than 32768 bytes is not allowed."
..` Got {strlen} bytes.`,
2
)
end
local actual_adler32=calculateAdler32(str)
if not isEqualAdler32(adler32,actual_adler32)then
error(
([[Usage: LibDeflate.createDictionary(str, strlen, adler32): 'adler32' does not match the actual adler32 of 'str'. 'adler32': %u, 'Adler32(str)': %u . Please check if 'str' is modified unintentionally.]]




):format(adler32,actual_adler32)
)
end

local dictionary={
adler32=adler32,
hash_tables={},
string_table={},
strlen=strlen,
}
local string_table=dictionary.string_table
local hash_tables=dictionary.hash_tables
string_table[1]=string_byte(str,1,1)
string_table[2]=string_byte(str,2,2)
if strlen>=3 then
local i=1
local hash=string_table[1]*256+string_table[2]
while i<=strlen-2-3 do
local x1,x2,x3,x4=string_byte(str,i+2,i+5)
string_table[i+2]=x1
string_table[i+3]=x2
string_table[i+4]=x3
string_table[i+5]=x4
hash=(hash*256+x1)%16777216
local t=hash_tables[hash]
if not t then
t={}
hash_tables[hash]=t
end
t[#t+1]=i-strlen
i=i+1
hash=(hash*256+x2)%16777216
t=hash_tables[hash]
if not t then
t={}
hash_tables[hash]=t
end
t[#t+1]=i-strlen
i=i+1
hash=(hash*256+x3)%16777216
t=hash_tables[hash]
if not t then
t={}
hash_tables[hash]=t
end
t[#t+1]=i-strlen
i=i+1
hash=(hash*256+x4)%16777216
t=hash_tables[hash]
if not t then
t={}
hash_tables[hash]=t
end
t[#t+1]=i-strlen
i=i+1
end
while i<=strlen-2 do
local x=string_byte(str,i+2)
string_table[i+2]=x
hash=(hash*256+x)%16777216
local t=hash_tables[hash]
if not t then
t={}
hash_tables[hash]=t
end
t[#t+1]=i-strlen
i=i+1
end
end
return dictionary
end

return createDictionary]]></ProtectedString>
						<string name="ScriptGuid">{16C639CD-89AF-49FA-9571-0F501C750B29}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">createDictionary</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0F934E2F49AB4B059351C4C6FA1E6A39">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[


local function isEqualAdler32(actual:number,expected:number):boolean
return(actual%4294967296)==(expected%4294967296)
end

return isEqualAdler32]]></ProtectedString>
						<string name="ScriptGuid">{7E9E85FD-ABBA-4BD4-BCCB-88F861CE9CD0}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">isEqualAdler32</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4880A5319E52426CAE0FA9906E9EBDEB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[

local MinHeap=require(script.Parent:WaitForChild('internals'):WaitForChild('MinHeap'))
local StoreBlock=require(script.Parent:WaitForChild('internals'):WaitForChild('StoreBlock'))
local createDictionary=require(script.Parent:WaitForChild('createDictionary'))
local getBlockLZ77Result=require(script.Parent:WaitForChild('internals'):WaitForChild('getBlockLZ77Result'))
local isEqualAdler32=require(script.Parent:WaitForChild('isEqualAdler32'))
local isValidArguments=require(script.Parent:WaitForChild('internals'):WaitForChild('isValidArguments'))
local loadStringToTable=require(script.Parent:WaitForChild('internals'):WaitForChild('loadStringToTable'))

local minHeapPush=MinHeap.push
local minHeapPop=MinHeap.pop

local getStoreBlockSize=StoreBlock.getStoreBlockSize
local compressStoreBlock=StoreBlock.compressStoreBlock

export type Dictionary=createDictionary.Dictionary





















































































local LibDeflate={
createDictionary=createDictionary,
}


local string_byte=string.byte
local string_char=string.char
local string_sub=string.sub
local table_concat=table.concat
local table_sort=table.sort





local _pow2:{[number]:number}={}


local _byte_to_char={}









local _reverse_bits_tbl={}



local _literal_deflate_code_to_base_len={
3,
4,
5,
6,
7,
8,
9,
10,
11,
13,
15,
17,
19,
23,
27,
31,
35,
43,
51,
59,
67,
83,
99,
115,
131,
163,
195,
227,
258,
}



local _literal_deflate_code_to_extra_bitlen={
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
2,
2,
2,
2,
3,
3,
3,
3,
4,
4,
4,
4,
5,
5,
5,
5,
0,
}



local _dist_deflate_code_to_base_dist={
[0]=1,
2,
3,
4,
5,
7,
9,
13,
17,
25,
33,
49,
65,
97,
129,
193,
257,
385,
513,
769,
1025,
1537,
2049,
3073,
4097,
6145,
8193,
12289,
16385,
24577,
}



local _dist_deflate_code_to_extra_bitlen={
[0]=0,
0,
0,
0,
1,
1,
2,
2,
3,
3,
4,
4,
5,
5,
6,
6,
7,
7,
8,
8,
9,
9,
10,
10,
11,
11,
12,
12,
13,
13,
}



local _rle_codes_huffman_bitlen_order={
16,
17,
18,
0,
8,
7,
9,
6,
10,
5,
11,
4,
12,
3,
13,
2,
14,
1,
15,
}






local _fix_block_literal_huffman_code



local _fix_block_literal_huffman_to_deflate_code



local _fix_block_literal_huffman_bitlen



local _fix_block_literal_huffman_bitlen_count



local _fix_block_dist_huffman_code



local _fix_block_dist_huffman_to_deflate_code



local _fix_block_dist_huffman_bitlen




local _fix_block_dist_huffman_bitlen_count

for i=0,255 do
_byte_to_char[i]=string_char(i)
end

do
local pow=1
for i=0,32 do
_pow2[i]=pow
pow=pow*2
end
end

for i=1,9 do
_reverse_bits_tbl[i]={}
for j=0,_pow2[i+1]-1 do
local reverse=0
local value=j
for _=1,i do

reverse=reverse-reverse%2+(((reverse%2==1)or(value%2)==1)and 1 or 0)
value=(value-value%2)/2
reverse=reverse*2
end
_reverse_bits_tbl[i][j]=(reverse-reverse%2)/2
end
end







function LibDeflate.adler32(str)












if type(str)~='string'then
error(`Usage: LibDeflate.adler32(str): 'str' - string expected got 'type(str)'.`,2)
end
local strlen=#str

local i=1
local a=1
local b=0
while i<=strlen-15 do
local x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16=
string_byte(str,i,i+15)
b=(
b
+16*a
+16*x1
+15*x2
+14*x3
+13*x4
+12*x5
+11*x6
+10*x7
+9*x8
+8*x9
+7*x10
+6*x11
+5*x12
+4*x13
+3*x14
+2*x15
+x16
)%65521
a=(
a
+x1
+x2
+x3
+x4
+x5
+x6
+x7
+x8
+x9
+x10
+x11
+x12
+x13
+x14
+x15
+x16
)%65521
i=i+16
end
while i<=strlen do
local x=string_byte(str,i,i)
a=(a+x)%65521
b=(b+a)%65521
i=i+1
end
return(b*65536+a)%4294967296
end







local _FLUSH_MODE_MEMORY_CLEANUP=0

local _FLUSH_MODE_OUTPUT=1

local _FLUSH_MODE_BYTE_BOUNDARY=2

local _FLUSH_MODE_NO_FLUSH=3








local function createWriter()
local buffer_size=0
local cache=0
local cache_bitlen=0
local total_bitlen=0
local buffer={}

local result_buffer={}





local function writeBits(value:number,bitlen:number)
cache=cache+value*_pow2[cache_bitlen]
cache_bitlen=cache_bitlen+bitlen
total_bitlen=total_bitlen+bitlen

if cache_bitlen>=32 then
buffer_size=buffer_size+1
buffer[buffer_size]=_byte_to_char[cache%256]
.._byte_to_char[((cache-cache%256)/256%256)]
.._byte_to_char[((cache-cache%65536)/65536%256)]
.._byte_to_char[((cache-cache%16777216)/16777216%256)]
local rshift_mask=_pow2[32-cache_bitlen+bitlen]
cache=(value-value%rshift_mask)/rshift_mask
cache_bitlen=cache_bitlen-32
end
end




local function writeString(str:string)
for _=1,cache_bitlen,8 do
buffer_size=buffer_size+1
buffer[buffer_size]=string_char(cache%256)
cache=(cache-cache%256)/256
end
cache_bitlen=0
buffer_size=buffer_size+1
buffer[buffer_size]=str
total_bitlen=total_bitlen+#str*8
end








local function flushWriter(mode:number):(number,string?)
if mode==_FLUSH_MODE_NO_FLUSH then
return total_bitlen
end

if mode==_FLUSH_MODE_OUTPUT or mode==_FLUSH_MODE_BYTE_BOUNDARY then


local padding_bitlen=(8-cache_bitlen%8)%8

if cache_bitlen>0 then



cache=cache-_pow2[cache_bitlen]+_pow2[cache_bitlen+padding_bitlen]
for _=1,cache_bitlen,8 do
buffer_size=buffer_size+1
buffer[buffer_size]=_byte_to_char[cache%256]
cache=(cache-cache%256)/256
end

cache=0
cache_bitlen=0
end
if mode==_FLUSH_MODE_BYTE_BOUNDARY then
total_bitlen=total_bitlen+padding_bitlen
return total_bitlen
end
end

local flushed=table_concat(buffer)
buffer={}
buffer_size=0
result_buffer[#result_buffer+1]=flushed

if mode==_FLUSH_MODE_MEMORY_CLEANUP then
return total_bitlen
else
return total_bitlen,table_concat(result_buffer)
end
end

return writeBits,writeString,flushWriter
end









local function getHuffmanCodeFromBitlen(
bitlen_counts:{number},
symbol_bitlens:{number},
max_symbol:number,
max_bitlen:number
)
local huffman_code=0
local next_codes={}
local symbol_huffman_codes={}
for bitlen=1,max_bitlen do
huffman_code=(huffman_code+(bitlen_counts[bitlen-1]or 0))*2
next_codes[bitlen]=huffman_code
end
for symbol=0,max_symbol do
local bitlen=symbol_bitlens[symbol]
if bitlen then
huffman_code=next_codes[bitlen]
next_codes[bitlen]=huffman_code+1





if bitlen<=9 then
symbol_huffman_codes[symbol]=_reverse_bits_tbl[bitlen][huffman_code]
else
local reverse=0
for _=1,bitlen do
reverse=reverse
-reverse%2
+(((reverse%2==1)or(huffman_code%2)==1)and 1 or 0)
huffman_code=(huffman_code-huffman_code%2)/2
reverse=reverse*2
end
symbol_huffman_codes[symbol]=(reverse-reverse%2)/2
end
end
end
return symbol_huffman_codes
end




local function sortByFirstThenSecond(a:{number},b:{number}):boolean
return a[1]<b[1]or(a[1]==b[1]and a[2]<b[2])
end












local function getHuffmanBitlenAndCode(symbol_counts,max_bitlen:number,max_symbol)
local heap_size
local max_non_zero_bitlen_symbol=-1
local leafs={}
local heap={}
local symbol_bitlens={}
local symbol_codes={}
local bitlen_counts={}







local number_unique_symbols=0
for symbol,count in pairs(symbol_counts)do
number_unique_symbols=number_unique_symbols+1
leafs[number_unique_symbols]={count,symbol}
end

if number_unique_symbols==0 then

return{},{},-1
elseif number_unique_symbols==1 then




local symbol=leafs[1][2]
symbol_bitlens[symbol]=1
symbol_codes[symbol]=0
return symbol_bitlens,symbol_codes,symbol
else
table_sort(leafs,sortByFirstThenSecond)
heap_size=number_unique_symbols
for i=1,heap_size do
heap[i]=leafs[i]
end

while heap_size>1 do

local leftChild=minHeapPop(heap,heap_size)
heap_size=heap_size-1
local rightChild=minHeapPop(heap,heap_size)
heap_size=heap_size-1
local newNode:{number|{number}}=
{leftChild[1]+rightChild[1],-1,leftChild,rightChild}
minHeapPush(heap,newNode::any,heap_size)
heap_size=heap_size+1
end


local number_bitlen_overflow=0


local fifo:{number|{number}}={heap[1],0,0,0}
local fifo_size=1
local index=1
heap[1][1]=0
while index<=fifo_size do

local e:any=fifo[index]
local bitlen=e[1]
local symbol=e[2]
local left_child=e[3]
local right_child=e[4]
if left_child then
fifo_size=fifo_size+1
fifo[fifo_size]=left_child
left_child[1]=bitlen+1
end
if right_child then
fifo_size=fifo_size+1
fifo[fifo_size]=right_child
right_child[1]=bitlen+1
end
index=index+1

if bitlen>max_bitlen then
number_bitlen_overflow=number_bitlen_overflow+1
bitlen=max_bitlen
end
if symbol>=0 then
symbol_bitlens[symbol]=bitlen
max_non_zero_bitlen_symbol=(symbol>max_non_zero_bitlen_symbol)and symbol
or max_non_zero_bitlen_symbol
bitlen_counts[bitlen]=(bitlen_counts[bitlen]or 0)+1
end
end



if number_bitlen_overflow>0 then
repeat
local bitlen=max_bitlen-1
while(bitlen_counts[bitlen]or 0)==0 do
bitlen=bitlen-1
end

bitlen_counts[bitlen]=bitlen_counts[bitlen]-1

bitlen_counts[bitlen+1]=(bitlen_counts[bitlen+1]or 0)+2
bitlen_counts[max_bitlen]=bitlen_counts[max_bitlen]-1
number_bitlen_overflow=number_bitlen_overflow-2
until number_bitlen_overflow<=0

index=1
for bitlen=max_bitlen,1,-1 do
local n=bitlen_counts[bitlen]or 0
while n>0 do
local symbol=leafs[index][2]
symbol_bitlens[symbol]=bitlen
n=n-1
index=index+1
end
end
end

symbol_codes=
getHuffmanCodeFromBitlen(bitlen_counts,symbol_bitlens,max_symbol,max_bitlen)
return symbol_bitlens,symbol_codes,max_non_zero_bitlen_symbol
end
end













local function runLengthEncodeHuffmanBitlen(
lcode_bitlens:{number},
max_non_zero_bitlen_lcode:number,
dcode_bitlens:{number},
max_non_zero_bitlen_dcode:number
)
local rle_code_tblsize=0
local rle_codes={}
local rle_code_counts={}
local rle_extra_bits_tblsize=0
local rle_extra_bits={}
local prev=nil
local count=0




max_non_zero_bitlen_dcode=(max_non_zero_bitlen_dcode<0)and 0 or max_non_zero_bitlen_dcode
local max_code=max_non_zero_bitlen_lcode+max_non_zero_bitlen_dcode+1

for code=0,max_code+1 do
local len=(code<=max_non_zero_bitlen_lcode)and(lcode_bitlens[code]or 0)
or(
(code<=max_code)
and(dcode_bitlens[code-max_non_zero_bitlen_lcode-1]or 0)
or nil
)
if len==prev then
count=count+1
if len~=0 and count==6 then
rle_code_tblsize=rle_code_tblsize+1
rle_codes[rle_code_tblsize]=16
rle_extra_bits_tblsize=rle_extra_bits_tblsize+1
rle_extra_bits[rle_extra_bits_tblsize]=3
rle_code_counts[16]=(rle_code_counts[16]or 0)+1
count=0
elseif len==0 and count==138 then
rle_code_tblsize=rle_code_tblsize+1
rle_codes[rle_code_tblsize]=18
rle_extra_bits_tblsize=rle_extra_bits_tblsize+1
rle_extra_bits[rle_extra_bits_tblsize]=127
rle_code_counts[18]=(rle_code_counts[18]or 0)+1
count=0
end
else
if count==1 then
rle_code_tblsize=rle_code_tblsize+1
rle_codes[rle_code_tblsize]=prev
rle_code_counts[prev]=(rle_code_counts[prev]or 0)+1
elseif count==2 then
rle_code_tblsize=rle_code_tblsize+1
rle_codes[rle_code_tblsize]=prev
rle_code_tblsize=rle_code_tblsize+1
rle_codes[rle_code_tblsize]=prev
rle_code_counts[prev]=(rle_code_counts[prev]or 0)+2
elseif count>=3 then
rle_code_tblsize=rle_code_tblsize+1
local rleCode=(prev~=0)and 16 or(count<=10 and 17 or 18)
rle_codes[rle_code_tblsize]=rleCode
rle_code_counts[rleCode]=(rle_code_counts[rleCode]or 0)+1
rle_extra_bits_tblsize=rle_extra_bits_tblsize+1
rle_extra_bits[rle_extra_bits_tblsize]=(count<=10)and(count-3)
or(count-11)
end

prev=len::number
if len and len~=0 then
rle_code_tblsize=rle_code_tblsize+1
rle_codes[rle_code_tblsize]=len
rle_code_counts[len]=(rle_code_counts[len]or 0)+1
count=0
else
count=1
end
end
end

return rle_codes,rle_extra_bits,rle_code_counts
end






local function getBlockDynamicHuffmanHeader(lcodes_counts,dcodes_counts)
local lcodes_huffman_bitlens,lcodes_huffman_codes,max_non_zero_bitlen_lcode=
getHuffmanBitlenAndCode(lcodes_counts,15,285)
local dcodes_huffman_bitlens,dcodes_huffman_codes,max_non_zero_bitlen_dcode=
getHuffmanBitlenAndCode(dcodes_counts,15,29)

local rle_deflate_codes,rle_extra_bits,rle_codes_counts=runLengthEncodeHuffmanBitlen(
lcodes_huffman_bitlens,
max_non_zero_bitlen_lcode,
dcodes_huffman_bitlens,
max_non_zero_bitlen_dcode
)

local rle_codes_huffman_bitlens,rle_codes_huffman_codes=
getHuffmanBitlenAndCode(rle_codes_counts,7,18)

local HCLEN=0
for i=1,19 do
local symbol=_rle_codes_huffman_bitlen_order[i]
local length=rle_codes_huffman_bitlens[symbol]or 0
if length~=0 then
HCLEN=i
end
end

HCLEN=HCLEN-4
local HLIT=max_non_zero_bitlen_lcode+1-257
local HDIST=max_non_zero_bitlen_dcode+1-1
if HDIST<0 then
HDIST=0
end

return HLIT,
HDIST,
HCLEN,
rle_codes_huffman_bitlens,
rle_codes_huffman_codes,
rle_deflate_codes,
rle_extra_bits,
lcodes_huffman_bitlens,
lcodes_huffman_codes,
dcodes_huffman_bitlens,
dcodes_huffman_codes
end




local function getDynamicHuffmanBlockSize(
lcodes:{number},
dcodes:{number},
HCLEN:number,
rle_codes_huffman_bitlens:{number},
rle_deflate_codes:{number},
lcodes_huffman_bitlens:{number},
dcodes_huffman_bitlens:{number}
)
local block_bitlen=17
block_bitlen=block_bitlen+(HCLEN+4)*3

for _,code in rle_deflate_codes do
block_bitlen=block_bitlen+rle_codes_huffman_bitlens[code]
if code>=16 then
block_bitlen=block_bitlen+((code==16)and 2 or(code==17 and 3 or 7))
end
end

local length_code_count=0
for _,code in lcodes do
local huffman_bitlen=lcodes_huffman_bitlens[code]
block_bitlen=block_bitlen+huffman_bitlen
if code>256 then
length_code_count=length_code_count+1
if code>264 and code<285 then
local extra_bits_bitlen=_literal_deflate_code_to_extra_bitlen[code-256]
block_bitlen=block_bitlen+extra_bits_bitlen
end
local dist_code=dcodes[length_code_count]
local dist_huffman_bitlen=dcodes_huffman_bitlens[dist_code]
block_bitlen=block_bitlen+dist_huffman_bitlen

if dist_code>3 then
local dist_extra_bits_bitlen=(dist_code-dist_code%2)/2-1
block_bitlen=block_bitlen+dist_extra_bits_bitlen
end
end
end
return block_bitlen
end



local function compressDynamicHuffmanBlock(
writeBits,
is_last_block,
lcodes,
lextra_bits,
dcodes,
dextra_bits,
HLIT,
HDIST,
HCLEN,
rle_codes_huffman_bitlens,
rle_codes_huffman_codes,
rle_deflate_codes,
rle_extra_bits,
lcodes_huffman_bitlens,
lcodes_huffman_codes,
dcodes_huffman_bitlens,
dcodes_huffman_codes
)
writeBits(is_last_block and 1 or 0,1)
writeBits(2,2)

writeBits(HLIT,5)
writeBits(HDIST,5)
writeBits(HCLEN,4)

for i=1,HCLEN+4 do
local symbol=_rle_codes_huffman_bitlen_order[i]
local length=rle_codes_huffman_bitlens[symbol]or 0
writeBits(length,3)
end

local rleExtraBitsIndex=1
for i=1,#rle_deflate_codes do
local code=rle_deflate_codes[i]
writeBits(rle_codes_huffman_codes[code],rle_codes_huffman_bitlens[code])
if code>=16 then
local extraBits=rle_extra_bits[rleExtraBitsIndex]
writeBits(extraBits,(code==16)and 2 or(code==17 and 3 or 7))
rleExtraBitsIndex=rleExtraBitsIndex+1
end
end

local length_code_count=0
local length_code_with_extra_count=0
local dist_code_with_extra_count=0

for i=1,#lcodes do
local deflate_codee=lcodes[i]
local huffman_code=lcodes_huffman_codes[deflate_codee]
local huffman_bitlen=lcodes_huffman_bitlens[deflate_codee]
writeBits(huffman_code,huffman_bitlen)
if deflate_codee>256 then
length_code_count=length_code_count+1
if deflate_codee>264 and deflate_codee<285 then

length_code_with_extra_count=length_code_with_extra_count+1
local extra_bits=lextra_bits[length_code_with_extra_count]
local extra_bits_bitlen=_literal_deflate_code_to_extra_bitlen[deflate_codee-256]
writeBits(extra_bits,extra_bits_bitlen)
end

local dist_deflate_code=dcodes[length_code_count]
local dist_huffman_code=dcodes_huffman_codes[dist_deflate_code]
local dist_huffman_bitlen=dcodes_huffman_bitlens[dist_deflate_code]
writeBits(dist_huffman_code,dist_huffman_bitlen)

if dist_deflate_code>3 then
dist_code_with_extra_count=dist_code_with_extra_count+1
local dist_extra_bits=dextra_bits[dist_code_with_extra_count]
local dist_extra_bits_bitlen=(dist_deflate_code-dist_deflate_code%2)/2-1
writeBits(dist_extra_bits,dist_extra_bits_bitlen)
end
end
end
end





local function getFixedHuffmanBlockSize(lcodes,dcodes)
local block_bitlen=3
local length_code_count=0
for i=1,#lcodes do
local code=lcodes[i]
local huffman_bitlen=_fix_block_literal_huffman_bitlen[code]
block_bitlen=block_bitlen+huffman_bitlen
if code>256 then
length_code_count=length_code_count+1
if code>264 and code<285 then
local extra_bits_bitlen=_literal_deflate_code_to_extra_bitlen[code-256]
block_bitlen=block_bitlen+extra_bits_bitlen
end
local dist_code=dcodes[length_code_count]
block_bitlen=block_bitlen+5

if dist_code>3 then
local dist_extra_bits_bitlen=(dist_code-dist_code%2)/2-1
block_bitlen=block_bitlen+dist_extra_bits_bitlen
end
end
end
return block_bitlen
end




local function compressFixedHuffmanBlock(
WriteBits,
is_last_block,
lcodes,
lextra_bits,
dcodes,
dextra_bits
)
WriteBits(is_last_block and 1 or 0,1)
WriteBits(1,2)
local length_code_count=0
local length_code_with_extra_count=0
local dist_code_with_extra_count=0
for i=1,#lcodes do
local deflate_code=lcodes[i]
local huffman_code=_fix_block_literal_huffman_code[deflate_code]
local huffman_bitlen=_fix_block_literal_huffman_bitlen[deflate_code]
WriteBits(huffman_code,huffman_bitlen)
if deflate_code>256 then
length_code_count=length_code_count+1
if deflate_code>264 and deflate_code<285 then

length_code_with_extra_count=length_code_with_extra_count+1
local extra_bits=lextra_bits[length_code_with_extra_count]
local extra_bits_bitlen=_literal_deflate_code_to_extra_bitlen[deflate_code-256]
WriteBits(extra_bits,extra_bits_bitlen)
end

local dist_code=dcodes[length_code_count]
local dist_huffman_code=_fix_block_dist_huffman_code[dist_code]
WriteBits(dist_huffman_code,5)

if dist_code>3 then
dist_code_with_extra_count=dist_code_with_extra_count+1
local dist_extra_bits=dextra_bits[dist_code_with_extra_count]
local dist_extra_bits_bitlen=(dist_code-dist_code%2)/2-1
WriteBits(dist_extra_bits,dist_extra_bits_bitlen)
end
end
end
end












local function deflate(
configs:CompressionConfig?,
WriteBits,
WriteString,
FlushWriter,
str:string,
dictionary:Dictionary?
)
local string_table={}
local hash_tables={}
local is_last_block=nil
local block_start
local block_end
local bitlen_written
local total_bitlen=FlushWriter(_FLUSH_MODE_NO_FLUSH)
local strlen=#str
local offset

local level
local strategy
if configs then
if configs.level then
level=configs.level
end
if configs.strategy then
strategy=configs.strategy
end
end

if not level then
if strlen<2048 then
level=7
elseif strlen>65536 then
level=3
else
level=5
end
end

while not is_last_block do
if not block_start then
block_start=1
block_end=65535
offset=0
else
block_start=block_end+1
block_end=block_end+32768
offset=block_start-32768-1
end

if block_end>=strlen then
block_end=strlen
is_last_block=true
else
is_last_block=false
end

local lcodes,lextra_bits,lcodes_counts,dcodes,dextra_bits,dcodes_counts

local HLIT,HDIST,HCLEN,rle_codes_huffman_bitlens,rle_codes_huffman_codes,rle_deflate_codes,rle_extra_bits,lcodes_huffman_bitlens,lcodes_huffman_codes,dcodes_huffman_bitlens,dcodes_huffman_codes

local dynamic_block_bitlen
local fixed_block_bitlen
local store_block_bitlen

if level~=0 then

loadStringToTable(str,string_table,block_start,block_end+3,offset)
if block_start==1 and dictionary then
local dict_string_table=dictionary.string_table
local dict_strlen=dictionary.strlen
for i=0,(-dict_strlen+1)<-257 and-257 or(-dict_strlen+1),-1 do
string_table[i]=dict_string_table[dict_strlen+i]
end
end

if strategy=='huffman_only'then
lcodes={}
loadStringToTable(str,lcodes,block_start,block_end,block_start-1)
lextra_bits={}
lcodes_counts={}
lcodes[block_end-block_start+2]=256
for i=1,block_end-block_start+2 do
local code=lcodes[i]
lcodes_counts[code]=(lcodes_counts[code]or 0)+1
end
dcodes={}
dextra_bits={}
dcodes_counts={}
else
lcodes,lextra_bits,lcodes_counts,dcodes,dextra_bits,dcodes_counts=
getBlockLZ77Result(
level,
string_table,
hash_tables,
block_start,
block_end,
offset,
dictionary
)
end


HLIT,HDIST,HCLEN,rle_codes_huffman_bitlens,rle_codes_huffman_codes,rle_deflate_codes,rle_extra_bits,lcodes_huffman_bitlens,lcodes_huffman_codes,dcodes_huffman_bitlens,dcodes_huffman_codes=

getBlockDynamicHuffmanHeader(lcodes_counts,dcodes_counts)
dynamic_block_bitlen=getDynamicHuffmanBlockSize(
lcodes,
dcodes,
HCLEN,
rle_codes_huffman_bitlens,
rle_deflate_codes,
lcodes_huffman_bitlens,
dcodes_huffman_bitlens
)
fixed_block_bitlen=getFixedHuffmanBlockSize(lcodes,dcodes)
end

store_block_bitlen=getStoreBlockSize(block_start,block_end,total_bitlen)

local min_bitlen=store_block_bitlen
min_bitlen=(fixed_block_bitlen and fixed_block_bitlen<min_bitlen)and fixed_block_bitlen
or min_bitlen
min_bitlen=(dynamic_block_bitlen and dynamic_block_bitlen<min_bitlen)
and dynamic_block_bitlen
or min_bitlen

if
level==0
or(strategy~='fixed'and strategy~='dynamic'and store_block_bitlen==min_bitlen)
then
compressStoreBlock(
WriteBits,
WriteString,
is_last_block,
str,
block_start,
block_end,
total_bitlen
)
total_bitlen=total_bitlen+store_block_bitlen
elseif
strategy~='dynamic'
and(strategy=='fixed'or fixed_block_bitlen==min_bitlen)
then
compressFixedHuffmanBlock(
WriteBits,
is_last_block,
lcodes,
lextra_bits,
dcodes,
dextra_bits
)
total_bitlen=total_bitlen+fixed_block_bitlen
elseif strategy=='dynamic'or dynamic_block_bitlen==min_bitlen then
compressDynamicHuffmanBlock(
WriteBits,
is_last_block,
lcodes,
lextra_bits,
dcodes,
dextra_bits,
HLIT,
HDIST,
HCLEN,
rle_codes_huffman_bitlens,
rle_codes_huffman_codes,
rle_deflate_codes,
rle_extra_bits,
lcodes_huffman_bitlens,
lcodes_huffman_codes,
dcodes_huffman_bitlens,
dcodes_huffman_codes
)
total_bitlen=total_bitlen+dynamic_block_bitlen
end

if is_last_block then
bitlen_written=FlushWriter(_FLUSH_MODE_NO_FLUSH)
else
bitlen_written=FlushWriter(_FLUSH_MODE_MEMORY_CLEANUP)
end










if not is_last_block then
local j
if dictionary and block_start==1 then
j=0
while string_table[j]do
string_table[j]=nil
j=j-1
end
end
dictionary=nil
j=1
for i=block_end-32767,block_end do
string_table[j]=string_table[i-offset]
j=j+1
end

for k,t in pairs(hash_tables)do
local tSize=#t
if tSize>0 and block_end+1-t[1]>32768 then
if tSize==1 then
hash_tables[k]=nil
else
local new={}
local newSize=0
for i=2,tSize do
j=t[i]
if block_end+1-j<=32768 then
newSize=newSize+1
new[newSize]=j
end
end
hash_tables[k]=new
end
end
end
end
end
end











export type CompressionConfig={

level:number,
strategy:CompressionStrategy,
}
export type CompressionStrategy='fixed'|'dynamic'|'huffman_only'



local function compressDeflateInternal(
str:string,
dictionary:Dictionary?,
configs:CompressionConfig?
)
local WriteBits,WriteString,FlushWriter=createWriter()
deflate(configs,WriteBits,WriteString,FlushWriter,str,dictionary)
local total_bitlen,result=FlushWriter(_FLUSH_MODE_OUTPUT)
local padding_bitlen=(8-total_bitlen%8)%8
return result,padding_bitlen
end



local function compressZlibInternal(
str:string,
dictionary:Dictionary?,
configs:CompressionConfig?
)
local WriteBits,WriteString,FlushWriter=createWriter()

local CM=8
local CINFO=7
local CMF=CINFO*16+CM
WriteBits(CMF,8)

local FDIST=dictionary and 1 or 0
local FLEVEL=2
local FLG=FLEVEL*64+FDIST*32
local FCHECK=(31-(CMF*256+FLG)%31)



FLG=FLG+FCHECK
WriteBits(FLG,8)

if FDIST==1 then
local adler32=(dictionary::Dictionary).adler32
local byte0=adler32%256
adler32=(adler32-byte0)/256
local byte1=adler32%256
adler32=(adler32-byte1)/256
local byte2=adler32%256
adler32=(adler32-byte2)/256
local byte3=adler32%256
WriteBits(byte3,8)
WriteBits(byte2,8)
WriteBits(byte1,8)
WriteBits(byte0,8)
end

deflate(configs,WriteBits,WriteString,FlushWriter,str,dictionary)
FlushWriter(_FLUSH_MODE_BYTE_BOUNDARY)

local adler32=LibDeflate.adler32(str)


local byte3=adler32%256
adler32=(adler32-byte3)/256
local byte2=adler32%256
adler32=(adler32-byte2)/256
local byte1=adler32%256
adler32=(adler32-byte1)/256
local byte0=adler32%256

WriteBits(byte0,8)
WriteBits(byte1,8)
WriteBits(byte2,8)
WriteBits(byte3,8)
local total_bitlen,result=FlushWriter(_FLUSH_MODE_OUTPUT)
local padding_bitlen=(8-total_bitlen%8)%8
return result,padding_bitlen
end














function LibDeflate.compressDeflate(str:string,configs:CompressionConfig?)
local arg_valid,arg_err=isValidArguments(str,false,nil,true,configs)
if not arg_valid then
error(`Usage: LibDeflate.compressDeflate(str, configs): {arg_err}`,2)
end
return compressDeflateInternal(str,nil,configs)
end

















function LibDeflate.compressDeflateWithDict(
str:string,
dictionary:Dictionary,
configs:CompressionConfig?
)
local arg_valid,arg_err=isValidArguments(str,true,dictionary,true,configs)
if not arg_valid then
error(
('Usage: LibDeflate.compressDeflateWithDict'..`(str, dictionary, configs): {arg_err}`),
2
)
end
return compressDeflateInternal(str,dictionary,configs)
end











function LibDeflate.compressZlib(str:string,configs:CompressionConfig?)
local arg_valid,arg_err=isValidArguments(str,false,nil,true,configs)
if not arg_valid then
error(`Usage: LibDeflate.compressZlib(str, configs): {arg_err}`,2)
end
return compressZlibInternal(str,nil,configs)
end














function LibDeflate.compressZlibWithDict(
str:string,
dictionary:Dictionary,
configs:CompressionConfig?
)
local arg_valid,arg_err=isValidArguments(str,true,dictionary,true,configs)
if not arg_valid then
error(`Usage: LibDeflate.compressZlibWithDict(str, dictionary, configs): {arg_err}`,2)
end
return compressZlibInternal(str,dictionary,configs)
end















local function createReader(input_string:string)
local input=input_string
local input_strlen=#input_string
local input_next_byte_pos=1
local cache_bitlen=0
local cache=0







local function readBits(bitlen:number):number
local rshift_mask=_pow2[bitlen]
local code
if bitlen<=cache_bitlen then
code=cache%rshift_mask
cache=(cache-code)/rshift_mask
cache_bitlen=cache_bitlen-bitlen
else
local lshift_mask=_pow2[cache_bitlen]
local byte1,byte2,byte3,byte4=
string_byte(input,input_next_byte_pos,input_next_byte_pos+3)

cache=cache
+(
(byte1 or 0)
+(byte2 or 0)*256
+(byte3 or 0)*65536
+(byte4 or 0)*16777216
)
*lshift_mask
input_next_byte_pos=input_next_byte_pos+4
cache_bitlen=cache_bitlen+32-bitlen
code=cache%rshift_mask
cache=(cache-code)/rshift_mask
end
return code
end








local function readBytes(bytelen:number,buffer:{string},buffer_size:number)





local byte_from_cache=(cache_bitlen/8<bytelen)and(cache_bitlen/8)or bytelen
for _=1,byte_from_cache do
local byte=cache%256
buffer_size=buffer_size+1
buffer[buffer_size]=string_char(byte)
cache=(cache-byte)/256
end
cache_bitlen=cache_bitlen-byte_from_cache*8
bytelen=bytelen-byte_from_cache
if(input_strlen-input_next_byte_pos-bytelen+1)*8+cache_bitlen<0 then
return-1
end
for i=input_next_byte_pos,input_next_byte_pos+bytelen-1 do
buffer_size=buffer_size+1
buffer[buffer_size]=string_sub(input,i,i)
end

input_next_byte_pos=input_next_byte_pos+bytelen
return buffer_size
end












local function decode(huffman_bitlen_counts,huffman_symbols,min_bitlen)
local code=0
local first=0
local index=0
local count
if min_bitlen>0 then
if cache_bitlen<15 and input then
local lshift_mask=_pow2[cache_bitlen]
local byte1,byte2,byte3,byte4=
string_byte(input,input_next_byte_pos,input_next_byte_pos+3)

cache=cache
+(
(byte1 or 0)
+(byte2 or 0)*256
+(byte3 or 0)*65536
+(byte4 or 0)*16777216
)
*lshift_mask
input_next_byte_pos=input_next_byte_pos+4
cache_bitlen=cache_bitlen+32
end

local rshift_mask=_pow2[min_bitlen]
cache_bitlen=cache_bitlen-min_bitlen
code=cache%rshift_mask
cache=(cache-code)/rshift_mask

code=_reverse_bits_tbl[min_bitlen][code]

count=huffman_bitlen_counts[min_bitlen]
if code<count then
return huffman_symbols[code]
end
index=count
first=count*2
code=code*2
end

for bitlen=min_bitlen+1,15 do
local bit
bit=cache%2
cache=(cache-bit)/2
cache_bitlen=cache_bitlen-1

code=(bit==1)and(code+1-code%2)or code
count=huffman_bitlen_counts[bitlen]or 0
local diff=code-first
if diff<count then
return huffman_symbols[index+diff]
end
index=index+count
first=first+count
first=first*2
code=code*2
end


return-10
end

local function readerBitlenLeft()
return(input_strlen-input_next_byte_pos+1)*8+cache_bitlen
end

local function skipToByteBoundary()
local skipped_bitlen=cache_bitlen%8
local rshift_mask=_pow2[skipped_bitlen]
cache_bitlen=cache_bitlen-skipped_bitlen
cache=(cache-cache%rshift_mask)/rshift_mask
end

return readBits,readBytes,decode,readerBitlenLeft,skipToByteBoundary
end

type DeflateState={
ReadBits:(number)->number,
ReadBytes:(number,{string},number)->number,
Decode:({number},{number},number)->number,
ReaderBitlenLeft:()->number,
SkipToByteBoundary:()->(),
buffer_size:number,
buffer:{string},
result_buffer:{string},
dictionary:Dictionary?,
}






local function createDecompressState(str:string,dictionary:Dictionary?):DeflateState
local ReadBits,ReadBytes,Decode,ReaderBitlenLeft,SkipToByteBoundary=createReader(str)
local state={
ReadBits=ReadBits,
ReadBytes=ReadBytes,
Decode=Decode,
ReaderBitlenLeft=ReaderBitlenLeft,
SkipToByteBoundary=SkipToByteBoundary,
buffer_size=0,
buffer={},
result_buffer={},
dictionary=dictionary,
}
return state
end










local function getHuffmanForDecode(
huffman_bitlens:{number},
max_symbol:number,
max_bitlen:number
):(number,{number}?,{number}?,number?)
local huffman_bitlen_counts={}
local min_bitlen=max_bitlen
for symbol=0,max_symbol do
local bitlen=huffman_bitlens[symbol]or 0
min_bitlen=(bitlen>0 and bitlen<min_bitlen)and bitlen or min_bitlen
huffman_bitlen_counts[bitlen]=(huffman_bitlen_counts[bitlen]or 0)+1
end

if huffman_bitlen_counts[0]==max_symbol+1 then
return 0,huffman_bitlen_counts,{},0
end

local left=1
for len=1,max_bitlen do
left=left*2
left=left-(huffman_bitlen_counts[len]or 0)
if left<0 then
return left
end
end


local offsets={}
offsets[1]=0
for len=1,max_bitlen-1 do
offsets[len+1]=offsets[len]+(huffman_bitlen_counts[len]or 0)
end

local huffman_symbols={}
for symbol=0,max_symbol do
local bitlen=huffman_bitlens[symbol]or 0
if bitlen~=0 then
local offset=offsets[bitlen]
huffman_symbols[offset]=symbol
offsets[bitlen]=offsets[bitlen]+1
end
end


return left,huffman_bitlen_counts,huffman_symbols,min_bitlen
end








local function decodeUntilEndOfBlock(
state:DeflateState,
lcodes_huffman_bitlens:{number},
lcodes_huffman_symbols:{number},
lcodes_huffman_min_bitlen:number,
dcodes_huffman_bitlens:{number},
dcodes_huffman_symbols:{number},
dcodes_huffman_min_bitlen:number
)
local buffer,buffer_size,readBits,decode,readerBitlenLeft,resultBuffer=
state.buffer,
state.buffer_size,
state.ReadBits,
state.Decode,
state.ReaderBitlenLeft,
state.result_buffer
local dictionary=state.dictionary
local dict_string_table
local dict_strlen

local buffer_end=1
if dictionary and not buffer[0]then



dict_string_table=dictionary.string_table
dict_strlen=dictionary.strlen
buffer_end=-dict_strlen+1
for i=0,(-dict_strlen+1)<-257 and-257 or(-dict_strlen+1),-1 do
buffer[i]=_byte_to_char[dict_string_table[dict_strlen+i] ]
end
end

repeat
local symbol=
decode(lcodes_huffman_bitlens,lcodes_huffman_symbols,lcodes_huffman_min_bitlen)
if symbol<0 or symbol>285 then

return-10
elseif symbol<256 then
buffer_size=buffer_size+1
buffer[buffer_size]=_byte_to_char[symbol]
elseif symbol>256 then
symbol=symbol-256
local bitlen=_literal_deflate_code_to_base_len[symbol]
bitlen=(symbol>=8)
and(bitlen+readBits(_literal_deflate_code_to_extra_bitlen[symbol]))
or bitlen
symbol=
decode(dcodes_huffman_bitlens,dcodes_huffman_symbols,dcodes_huffman_min_bitlen)
if symbol<0 or symbol>29 then

return-10
end
local dist=_dist_deflate_code_to_base_dist[symbol]
dist=(dist>4)and(dist+readBits(_dist_deflate_code_to_extra_bitlen[symbol]))
or dist

local char_buffer_index=buffer_size-dist+1
if char_buffer_index<buffer_end then

return-11
end
if char_buffer_index>=-257 then
for _=1,bitlen do
buffer_size=buffer_size+1
buffer[buffer_size]=buffer[char_buffer_index]
char_buffer_index=char_buffer_index+1
end
else
char_buffer_index=dict_strlen+char_buffer_index
for _=1,bitlen do
buffer_size=buffer_size+1
buffer[buffer_size]=_byte_to_char[dict_string_table[char_buffer_index] ]
char_buffer_index=char_buffer_index+1
end
end
end

if readerBitlenLeft()<0 then
return 2
end

if buffer_size>=65536 then
resultBuffer[#resultBuffer+1]=table_concat(buffer,'',1,32768)
for i=32769,buffer_size do
buffer[i-32768]=buffer[i]
end
buffer_size=buffer_size-32768
buffer[buffer_size+1]=nil


end
until symbol==256

state.buffer_size=buffer_size

return 0
end




local function decompressStoreBlock(state:DeflateState):number
local buffer,buffer_size,readBits,readBytes,readerBitlenLeft,skipToByteBoundary,resultBuffer=
state.buffer,
state.buffer_size,
state.ReadBits,
state.ReadBytes,
state.ReaderBitlenLeft,
state.SkipToByteBoundary,
state.result_buffer

skipToByteBoundary()
local bytelen=readBits(16)
if readerBitlenLeft()<0 then
return 2
end
local bytelenComp=readBits(16)
if readerBitlenLeft()<0 then
return 2
end

if bytelen%256+bytelenComp%256~=255 then
return-2
end
if(bytelen-bytelen%256)/256+(bytelenComp-bytelenComp%256)/256~=255 then
return-2
end


buffer_size=readBytes(bytelen,buffer,buffer_size)
if buffer_size<0 then
return 2
end


if buffer_size>=65536 then
resultBuffer[#resultBuffer+1]=table_concat(buffer,'',1,32768)
for i=32769,buffer_size do
buffer[i-32768]=buffer[i]
end
buffer_size=buffer_size-32768
buffer[buffer_size+1]=nil
end
state.buffer_size=buffer_size
return 0
end




local function decompressFixBlock(state:DeflateState)
return decodeUntilEndOfBlock(
state,
_fix_block_literal_huffman_bitlen_count,
_fix_block_literal_huffman_to_deflate_code,
7,
_fix_block_dist_huffman_bitlen_count,
_fix_block_dist_huffman_to_deflate_code,
5
)
end




local function decompressDynamicBlock(state:DeflateState)
local readBits,decode=state.ReadBits,state.Decode
local nlen=readBits(5)+257
local ndist=readBits(5)+1
local ncode=readBits(4)+4
if nlen>286 or ndist>30 then

return-3
end

local rle_codes_huffman_bitlens={}

for i=1,ncode do
rle_codes_huffman_bitlens[_rle_codes_huffman_bitlen_order[i] ]=readBits(3)
end

local rle_codes_err,rle_codes_huffman_bitlen_counts,rle_codes_huffman_symbols,rle_codes_huffman_min_bitlen=
getHuffmanForDecode(rle_codes_huffman_bitlens,18,7)
if rle_codes_err~=0 then

return-4
end

local lcodes_huffman_bitlens={}
local dcodes_huffman_bitlens={}

local index=0
while index<nlen+ndist do
local symbol
local bitlen

symbol=decode(
rle_codes_huffman_bitlen_counts::{number},
rle_codes_huffman_symbols::{number},
rle_codes_huffman_min_bitlen::number
)

if symbol<0 then
return symbol
elseif symbol<16 then
if index<nlen then
lcodes_huffman_bitlens[index]=symbol
else
dcodes_huffman_bitlens[index-nlen]=symbol
end
index=index+1
else
bitlen=0
if symbol==16 then
if index==0 then


return-5
end
if index-1<nlen then
bitlen=lcodes_huffman_bitlens[index-1]
else
bitlen=dcodes_huffman_bitlens[index-nlen-1]
end
symbol=3+readBits(2)
elseif symbol==17 then
symbol=3+readBits(3)
else
symbol=11+readBits(7)
end
if index+symbol>nlen+ndist then


return-6
end
while symbol>0 do
symbol=symbol-1
if index<nlen then
lcodes_huffman_bitlens[index]=bitlen
else
dcodes_huffman_bitlens[index-nlen]=bitlen
end
index=index+1
end
end
end

if(lcodes_huffman_bitlens[256]or 0)==0 then

return-9
end

local lcodes_err,lcodes_huffman_bitlen_counts,lcodes_huffman_symbols,lcodes_huffman_min_bitlen=
getHuffmanForDecode(lcodes_huffman_bitlens,nlen-1,15)


local lcodes_huffman_bitlen_counts=lcodes_huffman_bitlen_counts::{number}
local lcodes_huffman_symbols=lcodes_huffman_symbols::{number}
local lcodes_huffman_min_bitlen=lcodes_huffman_min_bitlen::number



if
lcodes_err~=0
and(
lcodes_err<0
or nlen
~=(lcodes_huffman_bitlen_counts[0]or 0)+(lcodes_huffman_bitlen_counts[1]or 0)
)
then
return-7
end

local dcodes_err,dcodes_huffman_bitlen_counts,dcodes_huffman_symbols,dcodes_huffman_min_bitlen=
getHuffmanForDecode(dcodes_huffman_bitlens,ndist-1,15)


local dcodes_huffman_bitlen_counts=dcodes_huffman_bitlen_counts::{number}
local dcodes_huffman_symbols=dcodes_huffman_symbols::{number}
local dcodes_huffman_min_bitlen=dcodes_huffman_min_bitlen::number



if
dcodes_err~=0
and(
dcodes_err<0
or ndist
~=(dcodes_huffman_bitlen_counts[0]or 0)+(dcodes_huffman_bitlen_counts[1]or 0)
)
then
return-8
end


return decodeUntilEndOfBlock(
state,
lcodes_huffman_bitlen_counts,
lcodes_huffman_symbols,
lcodes_huffman_min_bitlen,
dcodes_huffman_bitlen_counts,
dcodes_huffman_symbols,
dcodes_huffman_min_bitlen
)
end




local function inflate(state:DeflateState):(string?,number?)
local readBits=state.ReadBits

local is_last_block
while not is_last_block do
is_last_block=(readBits(1)==1)
local block_type=readBits(2)
local status
if block_type==0 then
status=decompressStoreBlock(state)
elseif block_type==1 then
status=decompressFixBlock(state)
elseif block_type==2 then
status=decompressDynamicBlock(state)
else
return nil,-1
end
if status~=0 then
return nil,status
end
end

state.result_buffer[#state.result_buffer+1]=
table_concat(state.buffer,'',1,state.buffer_size)
local result=table_concat(state.result_buffer)
return result
end



local function decompressDeflateInternal(str:string,dictionary:Dictionary?):(string?,number?)
local state=createDecompressState(str,dictionary)
local result,status=inflate(state)
if not result then
return nil,status
end

local bitlen_left=state.ReaderBitlenLeft()
local bytelen_left=(bitlen_left-bitlen_left%8)/8
return result,bytelen_left
end



local function decompressZlibInternal(str:string,dictionary:Dictionary?):(string?,number?)
local state=createDecompressState(str,dictionary)
local readBits=state.ReadBits

local CMF=readBits(8)
if state.ReaderBitlenLeft()<0 then
return nil,2
end
local CM=CMF%16
local CINFO=(CMF-CM)/16
if CM~=8 then
return nil,-12
end
if CINFO>7 then
return nil,-13
end

local FLG=readBits(8)
if state.ReaderBitlenLeft()<0 then
return nil,2
end
if(CMF*256+FLG)%31~=0 then
return nil,-14
end

local FDIST=((FLG-FLG%32)/32%2)

if FDIST==1 then
if not dictionary then
return nil,-16
end
local byte3=readBits(8)
local byte2=readBits(8)
local byte1=readBits(8)
local byte0=readBits(8)
local actual_adler32=byte3*16777216+byte2*65536+byte1*256+byte0
if state.ReaderBitlenLeft()<0 then
return nil,2
end
if not isEqualAdler32(actual_adler32,dictionary.adler32)then
return nil,-17
end
end
local result,status=inflate(state)
if not result then
return nil,status
end
state.SkipToByteBoundary()

local adler_byte0=readBits(8)
local adler_byte1=readBits(8)
local adler_byte2=readBits(8)
local adler_byte3=readBits(8)
if state.ReaderBitlenLeft()<0 then
return nil,2
end

local adler32_expected=adler_byte0*16777216
+adler_byte1*65536
+adler_byte2*256
+adler_byte3
local adler32_actual=LibDeflate.adler32(result)
if not isEqualAdler32(adler32_expected,adler32_actual)then
return nil,-15
end

local bitlen_left=state.ReaderBitlenLeft()
local bytelen_left=(bitlen_left-bitlen_left%8)/8
return result,bytelen_left
end














function LibDeflate.decompressDeflate(str:string):(string?,number?)
local arg_valid,arg_err=isValidArguments(str)
if not arg_valid then
error('Usage: LibDeflate.decompressDeflate(str): '..arg_err::string,2)
end
return decompressDeflateInternal(str)
end



















function LibDeflate.decompressDeflateWithDict(
str:string,
dictionary:Dictionary
):(string?,number?)
local arg_valid,arg_err=isValidArguments(str,true,dictionary)
if not arg_valid then
error(
'Usage: LibDeflate.decompressDeflateWithDict(str, dictionary): '..arg_err::string,
2
)
end
return decompressDeflateInternal(str,dictionary)
end














function LibDeflate.decompressZlib(str:string):(string?,number?)
local arg_valid,arg_err=isValidArguments(str)
if not arg_valid then
error('Usage: LibDeflate.decompressZlib(str): '..arg_err::string,2)
end
return decompressZlibInternal(str)
end



















function LibDeflate.decompressZlibWithDict(str:string,dictionary:Dictionary):(string?,number?)
local arg_valid,arg_err=isValidArguments(str,true,dictionary)
if not arg_valid then
error('Usage: LibDeflate.decompressZlibWithDict(str, dictionary): '..arg_err::string,2)
end
return decompressZlibInternal(str,dictionary)
end


do
_fix_block_literal_huffman_bitlen={}
for sym=0,143 do
_fix_block_literal_huffman_bitlen[sym]=8
end
for sym=144,255 do
_fix_block_literal_huffman_bitlen[sym]=9
end
for sym=256,279 do
_fix_block_literal_huffman_bitlen[sym]=7
end
for sym=280,287 do
_fix_block_literal_huffman_bitlen[sym]=8
end

_fix_block_dist_huffman_bitlen={}
for dist=0,31 do
_fix_block_dist_huffman_bitlen[dist]=5
end
local status,bitlen_count,deflate_code=
getHuffmanForDecode(_fix_block_literal_huffman_bitlen,287,9)

_fix_block_literal_huffman_bitlen_count=bitlen_count::{number}
_fix_block_literal_huffman_to_deflate_code=deflate_code::{number}





local newStatus,new_bitlen_count,new_deflate_code=
getHuffmanForDecode(_fix_block_dist_huffman_bitlen,31,5)
status=newStatus

_fix_block_dist_huffman_bitlen_count=new_bitlen_count::{number}
_fix_block_dist_huffman_to_deflate_code=new_deflate_code::{number}






_fix_block_literal_huffman_code=getHuffmanCodeFromBitlen(
_fix_block_literal_huffman_bitlen_count,
_fix_block_literal_huffman_bitlen,
287,
9
)
_fix_block_dist_huffman_code=getHuffmanCodeFromBitlen(
_fix_block_dist_huffman_bitlen_count,
_fix_block_dist_huffman_bitlen,
31,
5
)
end

return LibDeflate]]></ProtectedString>
						<string name="ScriptGuid">{F0E20333-FBA6-4262-A7CC-C5AAEF1A9AEA}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">zlib</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXC5E02ED2A7EF4D2EAD2E8D69B1E8D37A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">internals</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0D08E3FE9554480E809E6ACDDF0F8F9D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[







local function minHeapPush(heap:{{number}},e:{number},heap_size:number)
heap_size=heap_size+1
heap[heap_size]=e
local value=e[1]
local pos=heap_size
local parent_pos=(pos-pos%2)/2

while parent_pos>=1 and heap[parent_pos][1]>value do
local t=heap[parent_pos]
heap[parent_pos]=e
heap[pos]=t
pos=parent_pos
parent_pos=(parent_pos-parent_pos%2)/2
end
end






local function minHeapPop(heap:{{number}},heap_size:number):{number}
local top=heap[1]
local e=heap[heap_size]
local value=e[1]
heap[1]=e
heap[heap_size]=top
heap_size=heap_size-1

local pos=1
local left_child_pos=pos*2
local right_child_pos=left_child_pos+1

while left_child_pos<=heap_size do
local left_child=heap[left_child_pos]
if right_child_pos<=heap_size and heap[right_child_pos][1]<left_child[1]then
local right_child=heap[right_child_pos]
if right_child[1]<value then
heap[right_child_pos]=e
heap[pos]=right_child
pos=right_child_pos
left_child_pos=pos*2
right_child_pos=left_child_pos+1
else
break
end
else
if left_child[1]<value then
heap[left_child_pos]=e
heap[pos]=left_child
pos=left_child_pos
left_child_pos=pos*2
right_child_pos=left_child_pos+1
else
break
end
end
end

return top
end

return{
push=minHeapPush,
pop=minHeapPop,
}]]></ProtectedString>
							<string name="ScriptGuid">{DF6C5B7E-E4DE-4971-B875-7CF09D34EAB3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MinHeap</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8D3261C647724E0C8162B66CC2447B39">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[



local _pow2={}

do
local pow=1
for i=0,32 do
_pow2[i]=pow
pow=pow*2
end
end







local function getStoreBlockSize(
block_start:number,
block_end:number,
total_bitlen:number
):number




local block_bitlen=3
total_bitlen=total_bitlen+3
local padding_bitlen=(8-total_bitlen%8)%8
block_bitlen=block_bitlen+padding_bitlen
block_bitlen=block_bitlen+32
block_bitlen=block_bitlen+(block_end-block_start+1)*8
return block_bitlen
end




local function compressStoreBlock(
writeBits,
writeString,
is_last_block:boolean,
str:string,
block_start:number,
block_end:number,
total_bitlen:number
)




writeBits(is_last_block and 1 or 0,1)
writeBits(0,2)
total_bitlen=total_bitlen+3
local padding_bitlen=(8-total_bitlen%8)%8
if padding_bitlen>0 then
writeBits(_pow2[padding_bitlen]-1,padding_bitlen)
end
local size=block_end-block_start+1
writeBits(size,16)


local comp=(255-size%256)+(255-(size-size%256)/256)*256
writeBits(comp,16)

writeString(str:sub(block_start,block_end))
end

return{
getStoreBlockSize=getStoreBlockSize,
compressStoreBlock=compressStoreBlock,
}]]></ProtectedString>
							<string name="ScriptGuid">{2E89AA69-F697-4357-88C4-6E3B9F5FA822}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">StoreBlock</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7E264A84038049B6A3169F610BD5F0E0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local compressionLevelConfigs=require(script.Parent.Parent:WaitForChild('CompressionLevels'))
local createDictionary=require(script.Parent.Parent:WaitForChild('createDictionary'))

type Dictionary=createDictionary.Dictionary



local _length_to_deflate_code={}



local _length_to_deflate_extra_bits={}



local _length_to_deflate_extra_bitlen={}



do
local a=18
local b=16
local c=265
local bitlen=1
for len=3,258 do
if len<=10 then
_length_to_deflate_code[len]=len+254
_length_to_deflate_extra_bitlen[len]=0
elseif len==258 then
_length_to_deflate_code[len]=285
_length_to_deflate_extra_bitlen[len]=0
else
if len>a then
a=a+b
b=b*2
c=c+4
bitlen=bitlen+1
end
local t=len-a-1+b/2
_length_to_deflate_code[len]=(t-(t%(b/8)))/(b/8)+c
_length_to_deflate_extra_bitlen[len]=bitlen
_length_to_deflate_extra_bits[len]=t%(b/8)
end
end
end


local _dist256_to_deflate_code={}



local _dist256_to_deflate_extra_bits={}



local _dist256_to_deflate_extra_bitlen={}



do
_dist256_to_deflate_code[1]=0
_dist256_to_deflate_code[2]=1
_dist256_to_deflate_extra_bitlen[1]=0
_dist256_to_deflate_extra_bitlen[2]=0

local a=3
local b=4
local code=2
local bitlen=0
for dist=3,256 do
if dist>b then
a=a*2
b=b*2
code=code+2
bitlen=bitlen+1
end
_dist256_to_deflate_code[dist]=(dist<=a)and code or(code+1)
_dist256_to_deflate_extra_bitlen[dist]=(bitlen<0)and 0 or bitlen
if b>=8 then
_dist256_to_deflate_extra_bits[dist]=(dist-b/2-1)%(b/4)
end
end
end











































local function getBlockLZ77Result(
level:number,
string_table,
hash_tables,
block_start:number,
block_end:number,
offset:number,
dictionary:Dictionary?
)
local config=compressionLevelConfigs[level]
local config_use_lazy,config_good_prev_length,config_max_lazy_match,config_nice_length,config_max_hash_chain=
config[1]::boolean,
config[2]::number?,
config[3]::number,
config[4]::number,
config[5]::number

local config_max_insert_length=(not config_use_lazy)and config_max_lazy_match or 2147483646
local config_good_hash_chain=(config_max_hash_chain-config_max_hash_chain%4/4)

local hash

local dict_hash_tables
local dict_string_table
local dict_string_len=0

if dictionary then
dict_hash_tables=dictionary.hash_tables
dict_string_table=dictionary.string_table
dict_string_len=dictionary.strlen




if block_end>=block_start and dict_string_len>=2 then
hash=dict_string_table[dict_string_len-1]*65536
+dict_string_table[dict_string_len]*256
+string_table[1]
local t=hash_tables[hash]
if not t then
t={}
hash_tables[hash]=t
end
t[#t+1]=-1
end
if block_end>=block_start+1 and dict_string_len>=1 then
hash=dict_string_table[dict_string_len]*65536
+string_table[1]*256
+string_table[2]
local t=hash_tables[hash]
if not t then
t={}
hash_tables[hash]=t
end
t[#t+1]=0
end
end

local dict_string_len_plus3=dict_string_len+3

hash=(string_table[block_start-offset]or 0)*256
+(string_table[block_start+1-offset]or 0)

local lcodes={}
local lcode_tblsize=0
local lcodes_counts={}
local dcodes={}
local dcodes_tblsize=0
local dcodes_counts={}

local lextra_bits={}
local lextra_bits_tblsize=0
local dextra_bits={}
local dextra_bits_tblsize=0

local match_available=false
local prev_len
local prev_dist
local cur_len=0
local cur_dist=0

local index=block_start
local index_end=block_end+(config_use_lazy and 1 or 0)





while index<=index_end do
local string_table_index=index-offset
local offset_minus_three=offset-3
prev_len=cur_len
prev_dist=cur_dist
cur_len=0

hash=(hash*256+(string_table[string_table_index+2]or 0))%16777216

local chain_index
local cur_chain
local hash_chain=hash_tables[hash]
local chain_old_size
if not hash_chain then
chain_old_size=0
hash_chain={}
hash_tables[hash]=hash_chain
if dict_hash_tables then
cur_chain=dict_hash_tables[hash]
chain_index=cur_chain and#cur_chain or 0
else
chain_index=0
end
else
chain_old_size=#hash_chain
cur_chain=hash_chain
chain_index=chain_old_size
end

if index<=block_end then
hash_chain[chain_old_size+1]=index
end

if
chain_index>0
and index+2<=block_end
and(not config_use_lazy or prev_len<config_max_lazy_match)
then
local depth=(config_use_lazy and prev_len>=config_good_prev_length::number)
and config_good_hash_chain
or config_max_hash_chain

local max_len_minus_one=block_end-index
max_len_minus_one=(max_len_minus_one>=257)and 257 or max_len_minus_one
max_len_minus_one=max_len_minus_one+string_table_index
local string_table_index_plus_three=string_table_index+3

while chain_index>=1 and depth>0 do
local prev=cur_chain[chain_index]

if index-prev>32768 then
break
end
if prev<index then
local sj=string_table_index_plus_three

if prev>=-257 then
local pj=prev-offset_minus_three
while sj<=max_len_minus_one and string_table[pj]==string_table[sj]do
sj=sj+1
pj=pj+1
end
else
local pj=dict_string_len_plus3+prev
while
sj<=max_len_minus_one
and dict_string_table[pj]==string_table[sj]
do
sj=sj+1
pj=pj+1
end
end
local j=sj-string_table_index
if j>cur_len then
cur_len=j
cur_dist=index-prev
end
if cur_len>=config_nice_length then
break
end
end

chain_index=chain_index-1
depth=depth-1
if chain_index==0 and prev>0 and dict_hash_tables then
cur_chain=dict_hash_tables[hash]
chain_index=cur_chain and#cur_chain or 0
end
end
end

if not config_use_lazy then
prev_len,prev_dist=cur_len,cur_dist
end
if
(not config_use_lazy or match_available)
and(prev_len>3 or(prev_len==3 and prev_dist<4096))
and cur_len<=prev_len
then
local code=_length_to_deflate_code[prev_len]
local length_extra_bits_bitlen=_length_to_deflate_extra_bitlen[prev_len]
local dist_code,dist_extra_bits_bitlen,dist_extra_bits
if prev_dist<=256 then
dist_code=_dist256_to_deflate_code[prev_dist]
dist_extra_bits=_dist256_to_deflate_extra_bits[prev_dist]
dist_extra_bits_bitlen=_dist256_to_deflate_extra_bitlen[prev_dist]
else
dist_code=16
dist_extra_bits_bitlen=7
local a=384
local b=512

while true do
if prev_dist<=a then
dist_extra_bits=(prev_dist-(b/2)-1)%(b/4)
break
elseif prev_dist<=b then
dist_extra_bits=(prev_dist-(b/2)-1)%(b/4)
dist_code=dist_code+1
break
else
dist_code=dist_code+2
dist_extra_bits_bitlen=dist_extra_bits_bitlen+1
a=a*2
b=b*2
end
end
end
lcode_tblsize=lcode_tblsize+1
lcodes[lcode_tblsize]=code
lcodes_counts[code]=(lcodes_counts[code]or 0)+1

dcodes_tblsize=dcodes_tblsize+1
dcodes[dcodes_tblsize]=dist_code
dcodes_counts[dist_code]=(dcodes_counts[dist_code]or 0)+1

if length_extra_bits_bitlen>0 then
local lenExtraBits=_length_to_deflate_extra_bits[prev_len]
lextra_bits_tblsize=lextra_bits_tblsize+1
lextra_bits[lextra_bits_tblsize]=lenExtraBits
end
if dist_extra_bits_bitlen>0 then
dextra_bits_tblsize=dextra_bits_tblsize+1
dextra_bits[dextra_bits_tblsize]=dist_extra_bits
end

for i=index+1,index+prev_len-(config_use_lazy and 2 or 1)do
hash=(hash*256+(string_table[i-offset+2]or 0))%16777216
if prev_len<=config_max_insert_length then
hash_chain=hash_tables[hash]
if not hash_chain then
hash_chain={}
hash_tables[hash]=hash_chain
end
hash_chain[#hash_chain+1]=i
end
end
index=index+prev_len-(config_use_lazy and 1 or 0)
match_available=false
elseif(not config_use_lazy)or match_available then
local code=
string_table[config_use_lazy and(string_table_index-1)or string_table_index]
lcode_tblsize=lcode_tblsize+1
lcodes[lcode_tblsize]=code
lcodes_counts[code]=(lcodes_counts[code]or 0)+1
index=index+1
else
match_available=true
index=index+1
end
end


lcode_tblsize=lcode_tblsize+1
lcodes[lcode_tblsize]=256
lcodes_counts[256]=(lcodes_counts[256]or 0)+1

return lcodes,lextra_bits,lcodes_counts,dcodes,dextra_bits,dcodes_counts
end

return getBlockLZ77Result]]></ProtectedString>
							<string name="ScriptGuid">{D8AB4648-90EA-4999-B554-16D25C2F9F12}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">getBlockLZ77Result</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEA650ECB0EEB47E6870724273619B731">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local compressionLevelConfigs=require(script.Parent.Parent:WaitForChild('CompressionLevels'))





local function isValidDictionary(dictionary:any?):(boolean,string?)
if type(dictionary)~='table'then
return false,`'dictionary' - table expected got '{type(dictionary)}'.`
end
if
type(dictionary.adler32)~='number'
or type(dictionary.string_table)~='table'
or type(dictionary.strlen)~='number'
or dictionary.strlen<=0
or dictionary.strlen>32768
or dictionary.strlen~=#dictionary.string_table
or type(dictionary.hash_tables)~='table'
then
return false,"'dictionary' - corrupted dictionary."
end
return true,''
end









local function isValidArguments(
str:string,
check_dictionary:boolean?,
dictionary:any?,
check_configs:boolean?,
configs:any?
):(boolean,string?)
if type(str)~='string'then
return false,`'str' - string expected got '{type(str)}'.`
end
if check_dictionary then
local dict_valid,dict_err=isValidDictionary(dictionary)
if not dict_valid then
return false,dict_err
end
end
if check_configs then
local type_configs=type(configs)
if type_configs~='nil'and type_configs~='table'then
return false,`'configs' - nil or table expected got '{type(configs)}'.`
end
if type_configs=='table'then
for k,v:any in pairs(configs::any)do
if k~='level'and k~='strategy'then
return false,`'configs' - unsupported table key in the configs: '{k}`
elseif k=='level'and not compressionLevelConfigs[v]then
return false,`'configs' - unsupported 'level': {v}.`
elseif
k=='strategy'
and v~='fixed'
and v~='huffman_only'
and v~='dynamic'
then

return false,`'configs' - unsupported 'strategy': '{v}'.`
end
end
end
end
return true,''
end

return isValidArguments]]></ProtectedString>
							<string name="ScriptGuid">{34062D68-3EEF-4CBF-B1A1-B96FED1E9E36}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">isValidArguments</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX43CCFD1A412243F682C86321404EDAB2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[







local function loadStringToTable(
str:string,
t:{number},
start:number,
stop:number,
offset:number
):{number}
local i=start-offset
while i<=stop-15-offset do
t[i],t[i+1],t[i+2],t[i+3],t[i+4],t[i+5],t[i+6],t[i+7],t[i+8],t[i+9],t[i+10],t[i+11],t[i+12],t[i+13],t[i+14],t[i+15]=
string.byte(str,i+offset,i+15+offset)
i=i+16
end
while i<=stop-offset do
t[i]=string.byte(str,i+offset,i+offset)
i=i+1
end
return t
end

return loadStringToTable]]></ProtectedString>
							<string name="ScriptGuid">{45F02B21-0836-41AD-8C1A-6618AB6AC823}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">loadStringToTable</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXCE59A544BD404F92B97E50E24DB7F7E6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">node_modules</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX1538E43F607142628DA4552EEC02C34B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">.luau-aliases</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Sound" referent="RBX6BC9450324DE4D469029526C28EC7F0A">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://87437544236708</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">selectfile</string>
					<int64 name="SourceAssetId">87437544236708</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX1CFEB5BC7F354A0FBCB65C5D1523C755">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://1293433423</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">filesent</string>
					<int64 name="SourceAssetId">1293433423</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXAC4F52D9476B47149D53B7B7173C65FF">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://115916891254154</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">recv</string>
					<int64 name="SourceAssetId">115916891254154</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXA4A08C3B1F5A4E23841A0A34DB31D01C">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://115436572186380</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">send</string>
					<int64 name="SourceAssetId">115436572186380</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX3AAB45AA6DBA40848FA28989E1B4D034">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://127441833735276</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">userjoined</string>
					<int64 name="SourceAssetId">127441833735276</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX02BF3ACB21A24C7290CD42D3A6B54A44">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://17692186249</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">userleft</string>
					<int64 name="SourceAssetId">17692186249</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXA8D71D186354405E987F817C178E66B6">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://15675059323</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">capturedscreenshot</string>
					<int64 name="SourceAssetId">17692186249</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="TextButton" referent="RBXF4D577663ECA480CA7732346B4A8F8A8">
				<Properties>
					<Font name="FontFace">
						<Family><url>rbxassetid://16658221428</url></Family>
						<Weight>700</Weight>
						<Style>Normal</Style>
					</Font>
					<float name="LineHeight">1</float>
					<string name="LocalizationMatchIdentifier"></string>
					<string name="LocalizationMatchedSourceText"></string>
					<int name="MaxVisibleGraphemes">-1</int>
					<string name="OpenTypeFeatures"></string>
					<bool name="RichText">false</bool>
					<string name="Text">Connect Chat</string>
					<Color3 name="TextColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<token name="TextDirection">0</token>
					<bool name="TextScaled">true</bool>
					<float name="TextSize">14</float>
					<Color3 name="TextStrokeColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<float name="TextStrokeTransparency">0</float>
					<float name="TextTransparency">0</float>
					<token name="TextTruncate">0</token>
					<bool name="TextWrapped">true</bool>
					<token name="TextXAlignment">2</token>
					<token name="TextYAlignment">1</token>
					<bool name="AutoButtonColor">true</bool>
					<Ref name="HoverHapticEffect">null</Ref>
					<bool name="Modal">false</bool>
					<Ref name="PressHapticEffect">null</Ref>
					<bool name="Selected">false</bool>
					<token name="Style">0</token>
					<bool name="Active">true</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>0.5</Y>
					</Vector2>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.639215708</R>
						<G>1</G>
						<B>0.529411793</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">true</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>0.850000024</XS>
						<XO>0</XO>
						<YS>0.850000024</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Connection</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXF4DD3C3B9F7E4F4ABB2F52C69CBD322E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Snapshot</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ImageLabel" referent="RBX2874EF4927F54BF8A60BA820D4C2739E">
					<Properties>
						<Content name="Image"><url>rbxassetid://18720210000</url></Content>
						<Color3 name="ImageColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0.5</float>
						<token name="ResampleMode">0</token>
						<token name="ScaleType">1</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>163</X>
								<Y>92</Y>
							</min>
							<max>
								<X>621</X>
								<Y>631</Y>
							</max>
						</Rect2D>
						<float name="SliceScale">1</float>
						<UDim2 name="TileSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">0</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ImageLabel</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ImageButton" referent="RBXFB85FA103C5C4462886F20199F1B4980">
					<Properties>
						<Content name="HoverImage"><null></null></Content>
						<Content name="Image"><url>rbxassetid://108748692600045</url></Content>
						<Color3 name="ImageColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<Content name="PressedImage"><null></null></Content>
						<token name="ResampleMode">0</token>
						<token name="ScaleType">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<float name="SliceScale">1</float>
						<UDim2 name="TileSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="AutoButtonColor">true</bool>
						<Ref name="HoverHapticEffect">null</Ref>
						<bool name="Modal">false</bool>
						<Ref name="PressHapticEffect">null</Ref>
						<bool name="Selected">false</bool>
						<token name="Style">0</token>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.0199999996</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.119999997</XS>
							<XO>0</XO>
							<YS>0.119999997</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ImageButton</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIAspectRatioConstraint" referent="RBX54FBACDD5D784DE09E5B4E77326B4CB6">
						<Properties>
							<float name="AspectRatio">1</float>
							<token name="AspectType">0</token>
							<token name="DominantAxis">0</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIAspectRatioConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UICorner" referent="RBXE9F62DF0E9C142058FA0C4C926C195C2">
						<Properties>
							<UDim name="CornerRadius">
								<S>0.100000001</S>
								<O>0</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX1DDFBA99E699487482BE322F07329ABC">
				<Properties>
					<token name="Style">0</token>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>0.5</Y>
					</Vector2>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<float name="BackgroundTransparency">0.5</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">NetworkFailureOverlay</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="TextLabel" referent="RBXB7962AE40EEC44DBAEF6A0D1BAE622CD">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxassetid://16658221428</url></Family>
							<Weight>400</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text">This plugin can only be used in multiplayer.</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TextLabel</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIPadding" referent="RBXFC96C4233EFF4AE6A2975BE7B0C8CD0A">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>12</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>12</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>12</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>12</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIAspectRatioConstraint" referent="RBX2A7D00FE65AE4855AB62A8B162765C63">
						<Properties>
							<float name="AspectRatio">8</float>
							<token name="AspectType">0</token>
							<token name="DominantAxis">0</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIAspectRatioConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX37696D91039E464EB0498BB196E97455">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Messages</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Frame" referent="RBXD471CFB684324999B5D6D504C1A4E46D">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">2</token>
						<Color3 name="BackgroundColor3">
							<R>0.21960786</R>
							<G>0.21960786</G>
							<B>0.21960786</B>
						</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">OtherPlayer</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ImageLabel" referent="RBX9AAB375ADFE34CD2BF191DCFC79DB393">
						<Properties>
							<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">3</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>42</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ImageLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBX425F8EEFC0E744909B9661139D07815A">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UICorner" referent="RBXB75C7CB1F8D140A89C5410EB8E8A5300">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX6D0EEDA92E91475D95A4C9AD0E4A1BBB">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBXADD5A6680E6F4A51BAB28F6C1E34B571">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">Username</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.854961812</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>30</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DisplayName</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBX9564DD4DAADC44B3ACD8778C582490DC">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">Long Text Message lolololoooooooooool</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">30</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">2</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>48</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Message</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBXFF1AADDD5222429DB7ABFBBA3DED37D1">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX03D49361358E49459AB1C1D3900A6909">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="TextBox" referent="RBX9332E091F16648BEA0F71302CFD2F289">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">@Username</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.25</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>22</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.8223297</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Username</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX28BFEE7EEB5C422D8C3EE8DAD70E73D6">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">2</token>
						<Color3 name="BackgroundColor3">
							<R>0.21960786</R>
							<G>0.21960786</G>
							<B>0.21960786</B>
						</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SelfPlayer</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ImageLabel" referent="RBX19B82243F0A74B32B6499C63B885A8DF">
						<Properties>
							<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">3</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>42</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ImageLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBXE89651BBDF8446DF94E269DEB7FB66F1">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UICorner" referent="RBXC82C8912B6F6458C85E38A10DF824C98">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBXCD2B2A21035D456EAA79DE19F3F88E22">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBXE76C65FA3C8C47D7AB2C6C49F512F415">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">Username</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-50</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.854961812</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>30</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DisplayName</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBX8994E84645A34FB28F9DB273C2082461">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">Long Text Message lolololoooooooooool</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">30</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">2</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>48</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Message</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBXE89797600ADE4BA99FB7CDCA74A9127C">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX800DE31AB2114C39B91C5E04A205AF27">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="TextBox" referent="RBXCD6CD0D2DE84488CB2FE694CC5C80454">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">@Username</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.25</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-50</XO>
								<YS>0</YS>
								<YO>22</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.8223297</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Username</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBXCF2F90184A0B4ACF9852E952ABFCDE1A">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">2</token>
						<Color3 name="BackgroundColor3">
							<R>0.21960786</R>
							<G>0.21960786</G>
							<B>0.21960786</B>
						</Color3>
						<float name="BackgroundTransparency">0.800000012</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">System</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UICorner" referent="RBX1926EAE6394544B3A4C07E4200DB124E">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX7B9BC4E19C8347A3B5C529EE0EB11BFA">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBX24066FC4CD0C4507B56E2933A5DD022A">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text"></string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">30</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.5</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">2</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Message</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBX0BA06B7E3BD0456D966E38065CB62D86">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX8E61435EE494448D9CBBC5F34A576887">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX1B3C664A13004CE48BABC519068A71C7">
				<Properties>
					<token name="Style">0</token>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Frame</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="TextBox" referent="RBX261DA8B3817D4177B50A7FF4C07FD9A6">
					<Properties>
						<bool name="ClearTextOnFocus">false</bool>
						<Font name="FontFace">
							<Family><url>rbxassetid://16658221428</url></Family>
							<Weight>400</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="MultiLine">false</bool>
						<string name="OpenTypeFeatures"></string>
						<Color3 name="PlaceholderColor3">
							<R>0.699999988</R>
							<G>0.699999988</G>
							<B>0.699999988</B>
						</Color3>
						<string name="PlaceholderText">Type a message</string>
						<bool name="RichText">true</bool>
						<bool name="ShowNativeInput">true</bool>
						<string name="Text"></string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextEditable">true</bool>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>1</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.313725501</R>
							<G>0.313725501</G>
							<B>0.313725501</B>
						</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.980000019</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TextBox</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIPadding" referent="RBXCE7C14BC818C403DB43465A94C412F7B">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UICorner" referent="RBX7FFFDFB147E9440EA38C512A8286BC75">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="UIPadding" referent="RBXDA4CFA2819BF4B3BB2198A3764098EBD">
					<Properties>
						<UDim name="PaddingBottom">
							<S>0</S>
							<O>4</O>
						</UDim>
						<UDim name="PaddingLeft">
							<S>0</S>
							<O>4</O>
						</UDim>
						<UDim name="PaddingRight">
							<S>0</S>
							<O>4</O>
						</UDim>
						<UDim name="PaddingTop">
							<S>0</S>
							<O>4</O>
						</UDim>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UIPadding</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ScrollingFrame" referent="RBX5AD672DCFA40491CAFDB22ED090C6D26">
					<Properties>
						<token name="AutomaticCanvasSize">2</token>
						<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
						<Vector2 name="CanvasPosition">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<UDim2 name="CanvasSize">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="ElasticBehavior">0</token>
						<token name="HorizontalScrollBarInset">0</token>
						<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
						<Color3 name="ScrollBarImageColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="ScrollBarImageTransparency">0</float>
						<int name="ScrollBarThickness">12</int>
						<token name="ScrollingDirection">4</token>
						<bool name="ScrollingEnabled">true</bool>
						<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
						<token name="VerticalScrollBarInset">1</token>
						<token name="VerticalScrollBarPosition">0</token>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0.649999976</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">true</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0.884415567</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ScrollingFrame</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UICorner" referent="RBX7F00240C97F74B62BA2430C1554ABE09">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIListLayout" referent="RBXD1068ACF0FAD417DA4904E6C774CED14">
						<Properties>
							<token name="HorizontalFlex">0</token>
							<token name="ItemLineAlignment">0</token>
							<UDim name="Padding">
								<S>0</S>
								<O>12</O>
							</UDim>
							<token name="VerticalFlex">0</token>
							<bool name="Wraps">false</bool>
							<token name="FillDirection">1</token>
							<token name="HorizontalAlignment">1</token>
							<token name="SortOrder">2</token>
							<token name="VerticalAlignment">1</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIListLayout</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX6749A314F1DA4260A61CACF8014F15CA">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>24</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageButton" referent="RBXD8BA8FB7B80846B7BCE219090AC60AB1">
					<Properties>
						<Content name="HoverImage"><null></null></Content>
						<Content name="Image"><url>rbxassetid://77171614083036</url></Content>
						<Color3 name="ImageColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<Content name="PressedImage"><null></null></Content>
						<token name="ResampleMode">0</token>
						<token name="ScaleType">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<float name="SliceScale">1</float>
						<UDim2 name="TileSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="AutoButtonColor">true</bool>
						<Ref name="HoverHapticEffect">null</Ref>
						<bool name="Modal">false</bool>
						<Ref name="PressHapticEffect">null</Ref>
						<bool name="Selected">false</bool>
						<token name="Style">0</token>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>1</X>
							<Y>1</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.313725501</R>
							<G>0.313725501</G>
							<B>0.313725501</B>
						</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.0969696939</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SelectImage</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UICorner" referent="RBX8AD8FF5B57594EC891685538656BD205">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIAspectRatioConstraint" referent="RBX8E4C37FF23E94690B2B91D7AF867640C">
						<Properties>
							<float name="AspectRatio">1</float>
							<token name="AspectType">0</token>
							<token name="DominantAxis">0</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIAspectRatioConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXEC46DB84CEFD4FB7832CC9E4E59B2992">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>1</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.0470588244</R>
								<G>0.0470588244</G>
								<B>0.0470588244</B>
							</Color3>
							<float name="BackgroundTransparency">0.100000001</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.949999988</XS>
								<XO>0</XO>
								<YS>-0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBXAA3F7B549270423D94115827D062E3D2">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX4FC3F2F746BD404FA3983F6BBED10EF7">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>12</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>12</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>12</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>12</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="TextButton" referent="RBX485F4F653DB14DC7AB1B48106A1BE1D6">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxassetid://16658221428</url></Family>
									<Weight>700</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Screenshot</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="AutoButtonColor">true</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">game</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="TextButton" referent="RBXC614C4EF3DBC41F2827D743D1DD11F45">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxassetid://16658221428</url></Family>
									<Weight>700</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Local File</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="AutoButtonColor">true</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>1</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">pc</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX2864475BCF964365BBFEF9809BA760AA">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.0941176489</R>
							<G>0.0941176489</G>
							<B>0.0941176489</B>
						</Color3>
						<float name="BackgroundTransparency">0.125</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.531365335</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.56273061</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ImageConfirm</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="TextLabel" referent="RBX0D919B6227CA46B9BD09B8DA9680E123">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">true</bool>
							<string name="Text">Are you sure you want to send this image?</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.200000003</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">TextLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX375914A89D7D4C8FA7712104AFCAE035">
						<Properties>
							<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">3</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0.25</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.349999994</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ImageLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="TextLabel" referent="RBX6A53CDDA4EB34DE6B52693CEDB102AAE">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxassetid://16658221428</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">filename.png</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.25</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">TextLabel</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UICorner" referent="RBX761F692F66BA426D9B984583D4261D1A">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>12</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBXA75BDA78FA3B42B4BF42363BCA80827F">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">false</bool>
							<string name="Text">Yes</string>
							<Color3 name="TextColor3">
								<R>0.82745105</R>
								<G>1</G>
								<B>0.788235366</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="AutoButtonColor">true</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<bool name="Modal">false</bool>
							<Ref name="PressHapticEffect">null</Ref>
							<bool name="Selected">false</bool>
							<token name="Style">0</token>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.129411772</R>
								<G>0.639215708</G>
								<B>0.254901975</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.0344947726</XS>
								<XO>0</XO>
								<YS>0.824686468</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.270126641</XS>
								<XO>0</XO>
								<YS>0.119158141</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Yes</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UIStroke" referent="RBX0A52DC0889034F23A75E53E3DD0E2DEA">
							<Properties>
								<token name="ApplyStrokeMode">1</token>
								<UDim name="BorderOffset">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="BorderStrokePosition">0</token>
								<Color3 name="Color">
									<R>0.0156862754</R>
									<G>0.254901975</G>
									<B>0.054901965</B>
								</Color3>
								<bool name="Enabled">true</bool>
								<token name="LineJoinMode">0</token>
								<token name="StrokeSizingMode">0</token>
								<float name="Thickness">3</float>
								<float name="Transparency">0</float>
								<int name="ZIndex">1</int>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIStroke</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIGradient" referent="RBX4E70B02DAC58494BA0416566C04932C5">
							<Properties>
								<ColorSequence name="Color">0 1 1 1 0 1 0.815686 0.815686 0.815686 0 </ColorSequence>
								<bool name="Enabled">true</bool>
								<Vector2 name="Offset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="Rotation">90</float>
								<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIGradient</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UICorner" referent="RBX25B24C2C668D42B8AA263D10E1E8FF9A">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBXBD7173F5F7B6423E8844AB0E63F52627">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">false</bool>
							<string name="Text">No</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>0.36470589</G>
								<B>0.36470589</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="AutoButtonColor">true</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<bool name="Modal">false</bool>
							<Ref name="PressHapticEffect">null</Ref>
							<bool name="Selected">false</bool>
							<token name="Style">0</token>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>1</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.639215708</R>
								<G>0.0352941193</G>
								<B>0.0352941193</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.304878056</XS>
								<XO>0</XO>
								<YS>0.954449236</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.270126641</XS>
								<XO>0</XO>
								<YS>0.119158149</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">No</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UIStroke" referent="RBX7F7EC3F03C424687B73EC14A90F455ED">
							<Properties>
								<token name="ApplyStrokeMode">1</token>
								<UDim name="BorderOffset">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="BorderStrokePosition">0</token>
								<Color3 name="Color">
									<R>0.325490206</R>
									<G>0.0196078438</G>
									<B>0.0196078438</B>
								</Color3>
								<bool name="Enabled">true</bool>
								<token name="LineJoinMode">0</token>
								<token name="StrokeSizingMode">0</token>
								<float name="Thickness">3</float>
								<float name="Transparency">0</float>
								<int name="ZIndex">1</int>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIStroke</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIGradient" referent="RBX61E251FFDC17405EBFDDEF761DDEDA5A">
							<Properties>
								<ColorSequence name="Color">0 1 1 1 0 1 0.815686 0.815686 0.815686 0 </ColorSequence>
								<bool name="Enabled">true</bool>
								<Vector2 name="Offset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="Rotation">90</float>
								<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIGradient</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UICorner" referent="RBX54C9C09E50084A1989FD7868AA4F2DA9">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UIPadding" referent="RBX669EC2E16FCE4E47BF9668B22F717B2B">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX19888FD102604FC383CDB742EF40E3C7">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.327526122</XS>
								<XO>0</XO>
								<YS>0.722907841</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.651916385</XS>
								<XO>0</XO>
								<YS>0.0862444937</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="TextLabel" referent="RBX4D7F72174F0E447FBC3C656D97827A40">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxassetid://16658221428</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Mark image as spoiler?</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.104941845</XS>
									<XO>0</XO>
									<YS>0.0758558512</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.793859124</XS>
									<XO>0</XO>
									<YS>0.847037911</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">TextLabel</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="TextButton" referent="RBXDFCF372627D44817AA1D5C1EFA5580D4">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text"></string>
								<Color3 name="TextColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">8</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="AutoButtonColor">true</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.101960793</R>
									<G>0.101960793</G>
									<B>0.101960793</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.49999994</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.0887763873</XS>
									<XO>0</XO>
									<YS>0.999999881</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Spoilered</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIStroke" referent="RBXA27DA5DEB7244ACA9734067043966D42">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">0</token>
									<token name="StrokeSizingMode">0</token>
									<float name="Thickness">2</float>
									<float name="Transparency">0</float>
									<int name="ZIndex">1</int>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIStroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBXA6068466861841C8BD1936346DA7397A">
								<Properties>
									<token name="Style">0</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.800000012</XS>
										<XO>0</XO>
										<YS>0.800000012</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Tick</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIAspectRatioConstraint" referent="RBXB453F527337E431193610652560D4A32">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIAspectRatioConstraint</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="ImageButton" referent="RBX35D084F0297E4546BFD69E2C8161BAEB">
				<Properties>
					<Content name="HoverImage"><null></null></Content>
					<Content name="Image"><null></null></Content>
					<Color3 name="ImageColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<Vector2 name="ImageRectOffset">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<Vector2 name="ImageRectSize">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<float name="ImageTransparency">0</float>
					<Content name="PressedImage"><null></null></Content>
					<token name="ResampleMode">0</token>
					<token name="ScaleType">0</token>
					<Rect2D name="SliceCenter">
						<min>
							<X>0</X>
							<Y>0</Y>
						</min>
						<max>
							<X>0</X>
							<Y>0</Y>
						</max>
					</Rect2D>
					<float name="SliceScale">1</float>
					<UDim2 name="TileSize">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<bool name="AutoButtonColor">false</bool>
					<Ref name="HoverHapticEffect">null</Ref>
					<bool name="Modal">false</bool>
					<Ref name="PressHapticEffect">null</Ref>
					<bool name="Selected">false</bool>
					<token name="Style">0</token>
					<bool name="Active">true</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<token name="AutomaticSize">2</token>
					<Color3 name="BackgroundColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>48</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>400</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Message</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="UICorner" referent="RBX2E7DBD9334E846A48DE4160E9B3EC120">
					<Properties>
						<UDim name="CornerRadius">
							<S>0</S>
							<O>8</O>
						</UDim>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UICorner</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="UISizeConstraint" referent="RBXCE4ADBE9994649518B117B14EFF34C1D">
					<Properties>
						<Vector2 name="MaxSize">
							<X>INF</X>
							<Y>350</Y>
						</Vector2>
						<Vector2 name="MinSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UISizeConstraint</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="CanvasGroup" referent="RBXA240626B6EDC4C09BD0E9756CB3CFD4B">
				<Properties>
					<Color3 name="GroupColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="GroupTransparency">0</float>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">true</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Spoiler</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ImageLabel" referent="RBXC14796A22660480E8C4F69185E637AB7">
					<Properties>
						<Content name="Image"><url>rbxasset://textures/loading/loadingvignette.png</url></Content>
						<Color3 name="ImageColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<Vector2 name="ImageRectOffset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<Vector2 name="ImageRectSize">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="ImageTransparency">0</float>
						<token name="ResampleMode">0</token>
						<token name="ScaleType">0</token>
						<Rect2D name="SliceCenter">
							<min>
								<X>0</X>
								<Y>0</Y>
							</min>
							<max>
								<X>0</X>
								<Y>0</Y>
							</max>
						</Rect2D>
						<float name="SliceScale">1</float>
						<UDim2 name="TileSize">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">3</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Spoiler</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UICorner" referent="RBX27525900DA8240E69008901554B34D33">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>7</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX86857E18D6E8433FBE4709D32E64EE7B">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>500</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">false</bool>
							<string name="Text">SPOILER</string>
							<Color3 name="TextColor3">
								<R>0.784313738</R>
								<G>0.784313738</G>
								<B>0.784313738</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0.25</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.400000006</XS>
								<XO>0</XO>
								<YS>0.25</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">5</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">TextButton</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UIAspectRatioConstraint" referent="RBXFE955CCDE635479B8CCB8547242AC3CF">
							<Properties>
								<float name="AspectRatio">3</float>
								<token name="AspectType">0</token>
								<token name="DominantAxis">0</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIAspectRatioConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UICorner" referent="RBXCBD958F35464458B8C7E545FEB814169">
							<Properties>
								<UDim name="CornerRadius">
									<S>1</S>
									<O>0</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX530AAEC6EB3D428AB1DEC9F5394AF7AB">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0.25</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0.25</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0.25</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0.25</S>
									<O>0</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBXE9A0AFC950B84DA18C5A54AC06C9925D">
				<Properties>
					<token name="Style">0</token>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">5</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">WindowOverlay</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="UIPadding" referent="RBXD8AF521671054B169D389643ABA53000">
					<Properties>
						<UDim name="PaddingBottom">
							<S>0</S>
							<O>8</O>
						</UDim>
						<UDim name="PaddingLeft">
							<S>0</S>
							<O>8</O>
						</UDim>
						<UDim name="PaddingRight">
							<S>0</S>
							<O>8</O>
						</UDim>
						<UDim name="PaddingTop">
							<S>0</S>
							<O>8</O>
						</UDim>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UIPadding</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXE65D2322C9264B4E855109CEB3815E01">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
							<Weight>400</Weight>
							<Style>Normal</Style>
							<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text"></string>
						<Color3 name="TextColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">8</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="AutoButtonColor">true</bool>
						<Ref name="HoverHapticEffect">null</Ref>
						<bool name="Modal">false</bool>
						<Ref name="PressHapticEffect">null</Ref>
						<bool name="Selected">false</bool>
						<token name="Style">0</token>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>1</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.100000001</XS>
							<XO>24</XO>
							<YS>0.100000001</YS>
							<YO>24</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Settings</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIPadding" referent="RBXF0E0FDA0F7FB477586C1F9047B67CBC8">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UICorner" referent="RBX62FC9D61F008446F91217E695EC49E2A">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIAspectRatioConstraint" referent="RBXA9BB5C6B7CBE49C1AEB9FAEC54FFF113">
						<Properties>
							<float name="AspectRatio">1</float>
							<token name="AspectType">0</token>
							<token name="DominantAxis">0</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIAspectRatioConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXBE058B1A6D914BA9A460D2B5489823C1">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ImageLabel" referent="RBX34660285ACE94BEA9B52F0195848BCAB">
							<Properties>
								<Content name="Image"><url>rbxassetid://4492476121</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<token name="ResampleMode">0</token>
								<token name="ScaleType">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ImageButton</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Sound" referent="RBX7C792E23F556427FAFEE022F152F3220">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://119354387183704</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">hover</string>
					<int64 name="SourceAssetId">1293433423</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBXCC0CB9F856264A21B7492D692C08B6F9">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://100809160609628</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize">AQAAAAYAAAB1bnVzZWQDAQ==</BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">click</string>
					<int64 name="SourceAssetId">1293433423</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX4067741A6493478FB8C54C727C170BE2">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://8968249849</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">stophover</string>
					<int64 name="SourceAssetId">1293433423</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ScrollingFrame" referent="RBXF6B3FBBEBA3E4240B5C64A7A9872F80A">
				<Properties>
					<token name="AutomaticCanvasSize">2</token>
					<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
					<Vector2 name="CanvasPosition">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<UDim2 name="CanvasSize">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<token name="ElasticBehavior">0</token>
					<token name="HorizontalScrollBarInset">0</token>
					<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
					<Color3 name="ScrollBarImageColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="ScrollBarImageTransparency">0</float>
					<int name="ScrollBarThickness">12</int>
					<token name="ScrollingDirection">4</token>
					<bool name="ScrollingEnabled">true</bool>
					<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
					<token name="VerticalScrollBarInset">1</token>
					<token name="VerticalScrollBarPosition">0</token>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0</X>
						<Y>0</Y>
					</Vector2>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.0941176489</R>
						<G>0.0941176489</G>
						<B>0.0941176489</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">true</bool>
					<bool name="Draggable">false</bool>
					<bool name="Interactable">true</bool>
					<int name="LayoutOrder">0</int>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<int name="SelectionOrder">0</int>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">2</int>
					<bool name="AutoLocalize">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">SettingsPage</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Frame" referent="RBXC01005CBB6C34044999E59FAF0AFE244">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">2</token>
						<Color3 name="BackgroundColor3">
							<R>0.21960786</R>
							<G>0.21960786</G>
							<B>0.21960786</B>
						</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">1</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Preview</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ImageLabel" referent="RBX34E51A5F2A3F47059A17BE681692CA03">
						<Properties>
							<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">3</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>42</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ImageLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBX92D6F0D962C24BE9B5B1FDC1C19F4B65">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UICorner" referent="RBX5DD22AA22B9E4C00AE924CDE28EF70DC">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX46BBA42AD35A4B489A5AD43264796244">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>4</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>4</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBXDD30B54D5E7D4ADB9163D92A9DDAF0B3">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">Username</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.854961812</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>30</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DisplayName</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextBox" referent="RBX0A08CF700302418F9FFC7FB4CA140E63">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">Hi! I&apos;m MadnessMyth</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">30</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">2</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>48</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Message</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBX1A00BF1B4548476CB1E086ABA528515E">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIPadding" referent="RBX3B4AD387C78E44E7BD3EF12889E03F79">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>8</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>8</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="TextBox" referent="RBX6A78010E3F9A422EA980F0F22650D71C">
						<Properties>
							<bool name="ClearTextOnFocus">false</bool>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="MultiLine">false</bool>
							<string name="OpenTypeFeatures"></string>
							<Color3 name="PlaceholderColor3">
								<R>0.699999988</R>
								<G>0.699999988</G>
								<B>0.699999988</B>
							</Color3>
							<string name="PlaceholderText"></string>
							<bool name="RichText">false</bool>
							<bool name="ShowNativeInput">true</bool>
							<string name="Text">@Username</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextEditable">false</bool>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.25</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>22</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.8223297</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Username</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="UIPadding" referent="RBXAD576DDA21B04835BDE88D78695B7425">
					<Properties>
						<UDim name="PaddingBottom">
							<S>0</S>
							<O>12</O>
						</UDim>
						<UDim name="PaddingLeft">
							<S>0</S>
							<O>12</O>
						</UDim>
						<UDim name="PaddingRight">
							<S>0</S>
							<O>12</O>
						</UDim>
						<UDim name="PaddingTop">
							<S>0</S>
							<O>12</O>
						</UDim>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UIPadding</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="UIListLayout" referent="RBXB5AE7BDF634E4B6B97C8C213A4C0D4E3">
					<Properties>
						<token name="HorizontalFlex">0</token>
						<token name="ItemLineAlignment">0</token>
						<UDim name="Padding">
							<S>0</S>
							<O>12</O>
						</UDim>
						<token name="VerticalFlex">0</token>
						<bool name="Wraps">false</bool>
						<token name="FillDirection">1</token>
						<token name="HorizontalAlignment">0</token>
						<token name="SortOrder">2</token>
						<token name="VerticalAlignment">1</token>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UIListLayout</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="TextLabel" referent="RBX0680418E96634517BCDADFFFF9E08C72">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxassetid://16658221428</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text">User Preview</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TextLabel</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIGradient" referent="RBX11CD25A1F176491C9805EE3785886441">
						<Properties>
							<ColorSequence name="Color">0 1 1 1 0 1 0.815686 0.815686 0.815686 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">90</float>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIGradient</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBXC9ED08FFC29D48959C4B33D45A7B910E">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxassetid://16658221428</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text">Profile Picture</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">2</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TextLabel</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIGradient" referent="RBXE80C3EF974774CB594B84BCAFA4A874C">
						<Properties>
							<ColorSequence name="Color">0 1 1 1 0 1 0.815686 0.815686 0.815686 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">90</float>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIGradient</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX1926EF734E424C48AD7FD508D4D7E0C7">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.21960786</R>
							<G>0.21960786</G>
							<B>0.21960786</B>
						</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">3</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>64</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">PFP</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UICorner" referent="RBXADDA7AC127E94F4689A50A0F2FFB4BFA">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX345D9C751EE64E6D8C5EADF90B4A924A">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX41A5BD97DBC34BF8B5BC6727C8748E22">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxassetid://16658221428</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">false</bool>
							<string name="Text">X</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">1</token>
							<bool name="AutoButtonColor">true</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<bool name="Modal">false</bool>
							<Ref name="PressHapticEffect">null</Ref>
							<bool name="Selected">false</bool>
							<token name="Style">0</token>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.129411772</R>
								<G>0.639215708</G>
								<B>0.254901975</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.161409363</XS>
								<XO>0</XO>
								<YS>0.964687824</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">X</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ImageButton" referent="RBXA9CBFF9A6ECD467F8E76572C7FCDF305">
						<Properties>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><url>rbxasset://textures/ui/GuiImagePlaceholder.png</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">3</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="AutoButtonColor">true</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<bool name="Modal">false</bool>
							<Ref name="PressHapticEffect">null</Ref>
							<bool name="Selected">false</bool>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">-1</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>100</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ImageLabel</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UICorner" referent="RBXD2F792992A3A493B9EF9B2BE6A3A565B">
							<Properties>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIAspectRatioConstraint" referent="RBX798A6692D857452C86554245AE65446A">
							<Properties>
								<float name="AspectRatio">1</float>
								<token name="AspectType">0</token>
								<token name="DominantAxis">0</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIAspectRatioConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UIListLayout" referent="RBXF4627CBA40814082B0FB071E7F2F3499">
						<Properties>
							<token name="HorizontalFlex">0</token>
							<token name="ItemLineAlignment">0</token>
							<UDim name="Padding">
								<S>0</S>
								<O>12</O>
							</UDim>
							<token name="VerticalFlex">0</token>
							<bool name="Wraps">false</bool>
							<token name="FillDirection">0</token>
							<token name="HorizontalAlignment">1</token>
							<token name="SortOrder">2</token>
							<token name="VerticalAlignment">0</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIListLayout</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX0A42DAE58157482EA6F06F5DFF483122">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxassetid://16658221428</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text">Display Name Override</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">5</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TextLabel</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIGradient" referent="RBX1EF3E142ECEA41EA80DEE9E880BE1447">
						<Properties>
							<ColorSequence name="Color">0 1 1 1 0 1 0.815686 0.815686 0.815686 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">90</float>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIGradient</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="TextBox" referent="RBX748F9405E7F140158973C8F158EBCE26">
					<Properties>
						<bool name="ClearTextOnFocus">false</bool>
						<Font name="FontFace">
							<Family><url>rbxassetid://16658221428</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="MultiLine">false</bool>
						<string name="OpenTypeFeatures"></string>
						<Color3 name="PlaceholderColor3">
							<R>0.699999988</R>
							<G>0.699999988</G>
							<B>0.699999988</B>
						</Color3>
						<string name="PlaceholderText">[empty]</string>
						<bool name="RichText">false</bool>
						<bool name="ShowNativeInput">true</bool>
						<string name="Text"></string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextEditable">true</bool>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0.00784313772</R>
							<G>0.00784313772</G>
							<B>0.00784313772</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0.75</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">6</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">DisplayName</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UICorner" referent="RBX49336A30ACB14F3EB63B69AEAB472F8E">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX9D7D86023D5B4822B232CF8F4213E75A">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>8</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIPadding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX1C4921D7734B4180B36F8A691E890E3D">
						<Properties>
							<ColorSequence name="Color">0 1 1 1 0 1 0.815686 0.815686 0.815686 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">90</float>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIGradient</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBXDAB0AB771CC84B24B0E7CE3FFE2211AD">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxassetid://16658221428</url></Family>
							<Weight>700</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text">Save</string>
						<Color3 name="TextColor3">
							<R>0.82745105</R>
							<G>1</G>
							<B>0.788235366</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="AutoButtonColor">true</bool>
						<Ref name="HoverHapticEffect">null</Ref>
						<bool name="Modal">false</bool>
						<Ref name="PressHapticEffect">null</Ref>
						<bool name="Selected">false</bool>
						<token name="Style">0</token>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>1</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.129411772</R>
							<G>0.639215708</G>
							<B>0.254901975</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">100</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.0344947726</XS>
							<XO>0</XO>
							<YS>0.824686468</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.270126641</XS>
							<XO>0</XO>
							<YS>0.119158141</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Save</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UICorner" referent="RBX42E61876B1044B1995764702425D5208">
						<Properties>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX8A34D5F500704D37B289AC8B942B5EE0">
						<Properties>
							<ColorSequence name="Color">0 1 1 1 0 1 0.815686 0.815686 0.815686 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">90</float>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIGradient</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIStroke" referent="RBXF955800EA8CA4F15B25AF70A02B23E86">
						<Properties>
							<token name="ApplyStrokeMode">1</token>
							<UDim name="BorderOffset">
								<S>0</S>
								<O>0</O>
							</UDim>
							<token name="BorderStrokePosition">0</token>
							<Color3 name="Color">
								<R>0.0156862754</R>
								<G>0.254901975</G>
								<B>0.054901965</B>
							</Color3>
							<bool name="Enabled">true</bool>
							<token name="LineJoinMode">0</token>
							<token name="StrokeSizingMode">0</token>
							<float name="Thickness">3</float>
							<float name="Transparency">0</float>
							<int name="ZIndex">1</int>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIStroke</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Sound" referent="RBX7F5C8A88815649CBA19ADA3AFC8E49FA">
				<Properties>
					<bool name="IsMutedForCapture">false</bool>
					<NumberRange name="LoopRegion">0 60000 </NumberRange>
					<bool name="Looped">false</bool>
					<bool name="PlayOnRemove">false</bool>
					<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
					<bool name="PlaybackRegionsEnabled">false</bool>
					<float name="PlaybackSpeed">1</float>
					<bool name="Playing">false</bool>
					<float name="RollOffMaxDistance">10000</float>
					<float name="RollOffMinDistance">10</float>
					<token name="RollOffMode">0</token>
					<Ref name="SoundGroup">null</Ref>
					<Content name="SoundId"><url>rbxassetid://346979891</url></Content>
					<double name="TimePosition">0</double>
					<float name="Volume">0.5</float>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">click-cogwheel</string>
					<int64 name="SourceAssetId">1293433423</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXFBA5D4DB07A84243BD1DB34CC05AD6FF">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[--!nocheck
local HttpService = game:GetService("HttpService")

local UpdateChecker = {}

local CACHE_SECONDS = 120

type FetchResult = {
	ok: boolean,
	status: number,
	body: string?,
	error: string?,
}

local cache: {[string]: {t:number, res:FetchResult}} = {}

local function fetchText(url: string): FetchResult
	local now = os.clock()
	local c = cache[url]
	if c and (now - c.t) < CACHE_SECONDS then
		return c.res
	end

	local ok, resp = pcall(function()
		return HttpService:RequestAsync({
			Url = url,
			Method = "GET",
			Headers = {
				["Cache-Control"] = "no-cache",
			},
		})
	end)

	if not ok then
		local res: FetchResult = { ok = false, status = 0, error = tostring(resp) }
		cache[url] = { t = now, res = res }
		return res
	end

	local r = resp :: any
	local res: FetchResult = {
		ok = (r.Success == true),
		status = tonumber(r.StatusCode) or 0,
		body = r.Body,
		error = r.Success and nil or (r.StatusMessage or "Request failed"),
	}

	cache[url] = { t = now, res = res }
	return res
end

local function parseVer(v: string): {number}
	v = v:gsub("^%s+", ""):gsub("%s+$", "")
	v = v:gsub("^v", "")
	local out = {}
	for n in v:gmatch("%d+") do
		out[#out+1] = tonumber(n) or 0
	end
	while #out < 3 do out[#out+1] = 0 end
	return out
end

local function isNewer(latest: string, current: string): boolean
	local a = parseVer(latest)
	local b = parseVer(current)
	local n = math.max(#a, #b)
	for i = 1, n do
		local ai = a[i] or 0
		local bi = b[i] or 0
		if ai ~= bi then
			return ai > bi
		end
	end
	return false
end


function UpdateChecker.ReadGitHubRaw(owner: string, repo: string, branch: string, filePath: string): FetchResult
	local url = ("https://raw.githubusercontent.com/%s/%s/%s/%s"):format(owner, repo, branch, filePath)
	return fetchText(url)
end

type VersionCheckResult = {
	ok: boolean,
	current: string,
	latest: string?,
	updateAvailable: boolean?,
	url: string?,
	error: string?,
}

function UpdateChecker.CheckVersionFile(owner: string, repo: string, branch: string, versionFilePath: string, currentVersion: string): VersionCheckResult
	local r = UpdateChecker.ReadGitHubRaw(owner, repo, branch, versionFilePath)
	if not r.ok or not r.body then
		return {
			ok = false,
			current = currentVersion,
			error = ("HTTP %d: %s"):format(r.status, r.error or "unknown error"),
		}
	end

	local latest = r.body:gsub("^%s+", ""):gsub("%s+$", "")
	if latest == "" then
		return { ok = false, current = currentVersion, error = "version file is empty" }
	end

	local update = isNewer(latest, currentVersion)
	return {
		ok = true,
		current = currentVersion,
		latest = latest,
		updateAvailable = update,
		url = ("https://github.com/%s/%s"):format(owner, repo),
	}
end

return UpdateChecker
]]></ProtectedString>
					<string name="ScriptGuid">{C8901ABA-ADB9-443A-93B6-62E444F2CE35}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">UpdateChecker</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>
